// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: schedulable_transaction_body.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_schedulable_5ftransaction_5fbody_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_schedulable_5ftransaction_5fbody_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "system_delete.pb.h"
#include "system_undelete.pb.h"
#include "freeze.pb.h"
#include "contract_call.pb.h"
#include "contract_create.pb.h"
#include "contract_update.pb.h"
#include "crypto_create.pb.h"
#include "crypto_delete.pb.h"
#include "crypto_transfer.pb.h"
#include "crypto_update.pb.h"
#include "crypto_approve_allowance.pb.h"
#include "crypto_delete_allowance.pb.h"
#include "file_append.pb.h"
#include "file_create.pb.h"
#include "file_delete.pb.h"
#include "file_update.pb.h"
#include "contract_delete.pb.h"
#include "consensus_create_topic.pb.h"
#include "consensus_update_topic.pb.h"
#include "consensus_delete_topic.pb.h"
#include "consensus_submit_message.pb.h"
#include "token_create.pb.h"
#include "token_freeze_account.pb.h"
#include "token_unfreeze_account.pb.h"
#include "token_grant_kyc.pb.h"
#include "token_revoke_kyc.pb.h"
#include "token_delete.pb.h"
#include "token_update.pb.h"
#include "token_mint.pb.h"
#include "token_burn.pb.h"
#include "token_wipe_account.pb.h"
#include "token_associate.pb.h"
#include "token_dissociate.pb.h"
#include "token_fee_schedule_update.pb.h"
#include "token_pause.pb.h"
#include "token_unpause.pb.h"
#include "schedule_delete.pb.h"
#include "util_prng.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_schedulable_5ftransaction_5fbody_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_schedulable_5ftransaction_5fbody_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_schedulable_5ftransaction_5fbody_2eproto;
namespace proto {
class SchedulableTransactionBody;
struct SchedulableTransactionBodyDefaultTypeInternal;
extern SchedulableTransactionBodyDefaultTypeInternal _SchedulableTransactionBody_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::SchedulableTransactionBody* Arena::CreateMaybeMessage<::proto::SchedulableTransactionBody>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

// ===================================================================

class SchedulableTransactionBody final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.SchedulableTransactionBody) */ {
 public:
  inline SchedulableTransactionBody() : SchedulableTransactionBody(nullptr) {}
  ~SchedulableTransactionBody() override;
  explicit PROTOBUF_CONSTEXPR SchedulableTransactionBody(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedulableTransactionBody(const SchedulableTransactionBody& from);
  SchedulableTransactionBody(SchedulableTransactionBody&& from) noexcept
    : SchedulableTransactionBody() {
    *this = ::std::move(from);
  }

  inline SchedulableTransactionBody& operator=(const SchedulableTransactionBody& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedulableTransactionBody& operator=(SchedulableTransactionBody&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchedulableTransactionBody& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kContractCall = 3,
    kContractCreateInstance = 4,
    kContractUpdateInstance = 5,
    kContractDeleteInstance = 6,
    kCryptoApproveAllowance = 37,
    kCryptoDeleteAllowance = 38,
    kCryptoCreateAccount = 7,
    kCryptoDelete = 8,
    kCryptoTransfer = 9,
    kCryptoUpdateAccount = 10,
    kFileAppend = 11,
    kFileCreate = 12,
    kFileDelete = 13,
    kFileUpdate = 14,
    kSystemDelete = 15,
    kSystemUndelete = 16,
    kFreeze = 17,
    kConsensusCreateTopic = 18,
    kConsensusUpdateTopic = 19,
    kConsensusDeleteTopic = 20,
    kConsensusSubmitMessage = 21,
    kTokenCreation = 22,
    kTokenFreeze = 23,
    kTokenUnfreeze = 24,
    kTokenGrantKyc = 25,
    kTokenRevokeKyc = 26,
    kTokenDeletion = 27,
    kTokenUpdate = 28,
    kTokenMint = 29,
    kTokenBurn = 30,
    kTokenWipe = 31,
    kTokenAssociate = 32,
    kTokenDissociate = 33,
    kTokenFeeScheduleUpdate = 39,
    kTokenPause = 35,
    kTokenUnpause = 36,
    kScheduleDelete = 34,
    kUtilPrng = 40,
    DATA_NOT_SET = 0,
  };

  static inline const SchedulableTransactionBody* internal_default_instance() {
    return reinterpret_cast<const SchedulableTransactionBody*>(
               &_SchedulableTransactionBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SchedulableTransactionBody& a, SchedulableTransactionBody& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedulableTransactionBody* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedulableTransactionBody* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedulableTransactionBody* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedulableTransactionBody>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchedulableTransactionBody& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchedulableTransactionBody& from) {
    SchedulableTransactionBody::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchedulableTransactionBody* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.SchedulableTransactionBody";
  }
  protected:
  explicit SchedulableTransactionBody(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemoFieldNumber = 2,
    kTransactionFeeFieldNumber = 1,
    kContractCallFieldNumber = 3,
    kContractCreateInstanceFieldNumber = 4,
    kContractUpdateInstanceFieldNumber = 5,
    kContractDeleteInstanceFieldNumber = 6,
    kCryptoApproveAllowanceFieldNumber = 37,
    kCryptoDeleteAllowanceFieldNumber = 38,
    kCryptoCreateAccountFieldNumber = 7,
    kCryptoDeleteFieldNumber = 8,
    kCryptoTransferFieldNumber = 9,
    kCryptoUpdateAccountFieldNumber = 10,
    kFileAppendFieldNumber = 11,
    kFileCreateFieldNumber = 12,
    kFileDeleteFieldNumber = 13,
    kFileUpdateFieldNumber = 14,
    kSystemDeleteFieldNumber = 15,
    kSystemUndeleteFieldNumber = 16,
    kFreezeFieldNumber = 17,
    kConsensusCreateTopicFieldNumber = 18,
    kConsensusUpdateTopicFieldNumber = 19,
    kConsensusDeleteTopicFieldNumber = 20,
    kConsensusSubmitMessageFieldNumber = 21,
    kTokenCreationFieldNumber = 22,
    kTokenFreezeFieldNumber = 23,
    kTokenUnfreezeFieldNumber = 24,
    kTokenGrantKycFieldNumber = 25,
    kTokenRevokeKycFieldNumber = 26,
    kTokenDeletionFieldNumber = 27,
    kTokenUpdateFieldNumber = 28,
    kTokenMintFieldNumber = 29,
    kTokenBurnFieldNumber = 30,
    kTokenWipeFieldNumber = 31,
    kTokenAssociateFieldNumber = 32,
    kTokenDissociateFieldNumber = 33,
    kTokenFeeScheduleUpdateFieldNumber = 39,
    kTokenPauseFieldNumber = 35,
    kTokenUnpauseFieldNumber = 36,
    kScheduleDeleteFieldNumber = 34,
    kUtilPrngFieldNumber = 40,
  };
  // string memo = 2;
  void clear_memo();
  const std::string& memo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memo();
  PROTOBUF_NODISCARD std::string* release_memo();
  void set_allocated_memo(std::string* memo);
  private:
  const std::string& _internal_memo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memo(const std::string& value);
  std::string* _internal_mutable_memo();
  public:

  // uint64 transactionFee = 1;
  void clear_transactionfee();
  uint64_t transactionfee() const;
  void set_transactionfee(uint64_t value);
  private:
  uint64_t _internal_transactionfee() const;
  void _internal_set_transactionfee(uint64_t value);
  public:

  // .proto.ContractCallTransactionBody contractCall = 3;
  bool has_contractcall() const;
  private:
  bool _internal_has_contractcall() const;
  public:
  void clear_contractcall();
  const ::proto::ContractCallTransactionBody& contractcall() const;
  PROTOBUF_NODISCARD ::proto::ContractCallTransactionBody* release_contractcall();
  ::proto::ContractCallTransactionBody* mutable_contractcall();
  void set_allocated_contractcall(::proto::ContractCallTransactionBody* contractcall);
  private:
  const ::proto::ContractCallTransactionBody& _internal_contractcall() const;
  ::proto::ContractCallTransactionBody* _internal_mutable_contractcall();
  public:
  void unsafe_arena_set_allocated_contractcall(
      ::proto::ContractCallTransactionBody* contractcall);
  ::proto::ContractCallTransactionBody* unsafe_arena_release_contractcall();

  // .proto.ContractCreateTransactionBody contractCreateInstance = 4;
  bool has_contractcreateinstance() const;
  private:
  bool _internal_has_contractcreateinstance() const;
  public:
  void clear_contractcreateinstance();
  const ::proto::ContractCreateTransactionBody& contractcreateinstance() const;
  PROTOBUF_NODISCARD ::proto::ContractCreateTransactionBody* release_contractcreateinstance();
  ::proto::ContractCreateTransactionBody* mutable_contractcreateinstance();
  void set_allocated_contractcreateinstance(::proto::ContractCreateTransactionBody* contractcreateinstance);
  private:
  const ::proto::ContractCreateTransactionBody& _internal_contractcreateinstance() const;
  ::proto::ContractCreateTransactionBody* _internal_mutable_contractcreateinstance();
  public:
  void unsafe_arena_set_allocated_contractcreateinstance(
      ::proto::ContractCreateTransactionBody* contractcreateinstance);
  ::proto::ContractCreateTransactionBody* unsafe_arena_release_contractcreateinstance();

  // .proto.ContractUpdateTransactionBody contractUpdateInstance = 5;
  bool has_contractupdateinstance() const;
  private:
  bool _internal_has_contractupdateinstance() const;
  public:
  void clear_contractupdateinstance();
  const ::proto::ContractUpdateTransactionBody& contractupdateinstance() const;
  PROTOBUF_NODISCARD ::proto::ContractUpdateTransactionBody* release_contractupdateinstance();
  ::proto::ContractUpdateTransactionBody* mutable_contractupdateinstance();
  void set_allocated_contractupdateinstance(::proto::ContractUpdateTransactionBody* contractupdateinstance);
  private:
  const ::proto::ContractUpdateTransactionBody& _internal_contractupdateinstance() const;
  ::proto::ContractUpdateTransactionBody* _internal_mutable_contractupdateinstance();
  public:
  void unsafe_arena_set_allocated_contractupdateinstance(
      ::proto::ContractUpdateTransactionBody* contractupdateinstance);
  ::proto::ContractUpdateTransactionBody* unsafe_arena_release_contractupdateinstance();

  // .proto.ContractDeleteTransactionBody contractDeleteInstance = 6;
  bool has_contractdeleteinstance() const;
  private:
  bool _internal_has_contractdeleteinstance() const;
  public:
  void clear_contractdeleteinstance();
  const ::proto::ContractDeleteTransactionBody& contractdeleteinstance() const;
  PROTOBUF_NODISCARD ::proto::ContractDeleteTransactionBody* release_contractdeleteinstance();
  ::proto::ContractDeleteTransactionBody* mutable_contractdeleteinstance();
  void set_allocated_contractdeleteinstance(::proto::ContractDeleteTransactionBody* contractdeleteinstance);
  private:
  const ::proto::ContractDeleteTransactionBody& _internal_contractdeleteinstance() const;
  ::proto::ContractDeleteTransactionBody* _internal_mutable_contractdeleteinstance();
  public:
  void unsafe_arena_set_allocated_contractdeleteinstance(
      ::proto::ContractDeleteTransactionBody* contractdeleteinstance);
  ::proto::ContractDeleteTransactionBody* unsafe_arena_release_contractdeleteinstance();

  // .proto.CryptoApproveAllowanceTransactionBody cryptoApproveAllowance = 37;
  bool has_cryptoapproveallowance() const;
  private:
  bool _internal_has_cryptoapproveallowance() const;
  public:
  void clear_cryptoapproveallowance();
  const ::proto::CryptoApproveAllowanceTransactionBody& cryptoapproveallowance() const;
  PROTOBUF_NODISCARD ::proto::CryptoApproveAllowanceTransactionBody* release_cryptoapproveallowance();
  ::proto::CryptoApproveAllowanceTransactionBody* mutable_cryptoapproveallowance();
  void set_allocated_cryptoapproveallowance(::proto::CryptoApproveAllowanceTransactionBody* cryptoapproveallowance);
  private:
  const ::proto::CryptoApproveAllowanceTransactionBody& _internal_cryptoapproveallowance() const;
  ::proto::CryptoApproveAllowanceTransactionBody* _internal_mutable_cryptoapproveallowance();
  public:
  void unsafe_arena_set_allocated_cryptoapproveallowance(
      ::proto::CryptoApproveAllowanceTransactionBody* cryptoapproveallowance);
  ::proto::CryptoApproveAllowanceTransactionBody* unsafe_arena_release_cryptoapproveallowance();

  // .proto.CryptoDeleteAllowanceTransactionBody cryptoDeleteAllowance = 38;
  bool has_cryptodeleteallowance() const;
  private:
  bool _internal_has_cryptodeleteallowance() const;
  public:
  void clear_cryptodeleteallowance();
  const ::proto::CryptoDeleteAllowanceTransactionBody& cryptodeleteallowance() const;
  PROTOBUF_NODISCARD ::proto::CryptoDeleteAllowanceTransactionBody* release_cryptodeleteallowance();
  ::proto::CryptoDeleteAllowanceTransactionBody* mutable_cryptodeleteallowance();
  void set_allocated_cryptodeleteallowance(::proto::CryptoDeleteAllowanceTransactionBody* cryptodeleteallowance);
  private:
  const ::proto::CryptoDeleteAllowanceTransactionBody& _internal_cryptodeleteallowance() const;
  ::proto::CryptoDeleteAllowanceTransactionBody* _internal_mutable_cryptodeleteallowance();
  public:
  void unsafe_arena_set_allocated_cryptodeleteallowance(
      ::proto::CryptoDeleteAllowanceTransactionBody* cryptodeleteallowance);
  ::proto::CryptoDeleteAllowanceTransactionBody* unsafe_arena_release_cryptodeleteallowance();

  // .proto.CryptoCreateTransactionBody cryptoCreateAccount = 7;
  bool has_cryptocreateaccount() const;
  private:
  bool _internal_has_cryptocreateaccount() const;
  public:
  void clear_cryptocreateaccount();
  const ::proto::CryptoCreateTransactionBody& cryptocreateaccount() const;
  PROTOBUF_NODISCARD ::proto::CryptoCreateTransactionBody* release_cryptocreateaccount();
  ::proto::CryptoCreateTransactionBody* mutable_cryptocreateaccount();
  void set_allocated_cryptocreateaccount(::proto::CryptoCreateTransactionBody* cryptocreateaccount);
  private:
  const ::proto::CryptoCreateTransactionBody& _internal_cryptocreateaccount() const;
  ::proto::CryptoCreateTransactionBody* _internal_mutable_cryptocreateaccount();
  public:
  void unsafe_arena_set_allocated_cryptocreateaccount(
      ::proto::CryptoCreateTransactionBody* cryptocreateaccount);
  ::proto::CryptoCreateTransactionBody* unsafe_arena_release_cryptocreateaccount();

  // .proto.CryptoDeleteTransactionBody cryptoDelete = 8;
  bool has_cryptodelete() const;
  private:
  bool _internal_has_cryptodelete() const;
  public:
  void clear_cryptodelete();
  const ::proto::CryptoDeleteTransactionBody& cryptodelete() const;
  PROTOBUF_NODISCARD ::proto::CryptoDeleteTransactionBody* release_cryptodelete();
  ::proto::CryptoDeleteTransactionBody* mutable_cryptodelete();
  void set_allocated_cryptodelete(::proto::CryptoDeleteTransactionBody* cryptodelete);
  private:
  const ::proto::CryptoDeleteTransactionBody& _internal_cryptodelete() const;
  ::proto::CryptoDeleteTransactionBody* _internal_mutable_cryptodelete();
  public:
  void unsafe_arena_set_allocated_cryptodelete(
      ::proto::CryptoDeleteTransactionBody* cryptodelete);
  ::proto::CryptoDeleteTransactionBody* unsafe_arena_release_cryptodelete();

  // .proto.CryptoTransferTransactionBody cryptoTransfer = 9;
  bool has_cryptotransfer() const;
  private:
  bool _internal_has_cryptotransfer() const;
  public:
  void clear_cryptotransfer();
  const ::proto::CryptoTransferTransactionBody& cryptotransfer() const;
  PROTOBUF_NODISCARD ::proto::CryptoTransferTransactionBody* release_cryptotransfer();
  ::proto::CryptoTransferTransactionBody* mutable_cryptotransfer();
  void set_allocated_cryptotransfer(::proto::CryptoTransferTransactionBody* cryptotransfer);
  private:
  const ::proto::CryptoTransferTransactionBody& _internal_cryptotransfer() const;
  ::proto::CryptoTransferTransactionBody* _internal_mutable_cryptotransfer();
  public:
  void unsafe_arena_set_allocated_cryptotransfer(
      ::proto::CryptoTransferTransactionBody* cryptotransfer);
  ::proto::CryptoTransferTransactionBody* unsafe_arena_release_cryptotransfer();

  // .proto.CryptoUpdateTransactionBody cryptoUpdateAccount = 10;
  bool has_cryptoupdateaccount() const;
  private:
  bool _internal_has_cryptoupdateaccount() const;
  public:
  void clear_cryptoupdateaccount();
  const ::proto::CryptoUpdateTransactionBody& cryptoupdateaccount() const;
  PROTOBUF_NODISCARD ::proto::CryptoUpdateTransactionBody* release_cryptoupdateaccount();
  ::proto::CryptoUpdateTransactionBody* mutable_cryptoupdateaccount();
  void set_allocated_cryptoupdateaccount(::proto::CryptoUpdateTransactionBody* cryptoupdateaccount);
  private:
  const ::proto::CryptoUpdateTransactionBody& _internal_cryptoupdateaccount() const;
  ::proto::CryptoUpdateTransactionBody* _internal_mutable_cryptoupdateaccount();
  public:
  void unsafe_arena_set_allocated_cryptoupdateaccount(
      ::proto::CryptoUpdateTransactionBody* cryptoupdateaccount);
  ::proto::CryptoUpdateTransactionBody* unsafe_arena_release_cryptoupdateaccount();

  // .proto.FileAppendTransactionBody fileAppend = 11;
  bool has_fileappend() const;
  private:
  bool _internal_has_fileappend() const;
  public:
  void clear_fileappend();
  const ::proto::FileAppendTransactionBody& fileappend() const;
  PROTOBUF_NODISCARD ::proto::FileAppendTransactionBody* release_fileappend();
  ::proto::FileAppendTransactionBody* mutable_fileappend();
  void set_allocated_fileappend(::proto::FileAppendTransactionBody* fileappend);
  private:
  const ::proto::FileAppendTransactionBody& _internal_fileappend() const;
  ::proto::FileAppendTransactionBody* _internal_mutable_fileappend();
  public:
  void unsafe_arena_set_allocated_fileappend(
      ::proto::FileAppendTransactionBody* fileappend);
  ::proto::FileAppendTransactionBody* unsafe_arena_release_fileappend();

  // .proto.FileCreateTransactionBody fileCreate = 12;
  bool has_filecreate() const;
  private:
  bool _internal_has_filecreate() const;
  public:
  void clear_filecreate();
  const ::proto::FileCreateTransactionBody& filecreate() const;
  PROTOBUF_NODISCARD ::proto::FileCreateTransactionBody* release_filecreate();
  ::proto::FileCreateTransactionBody* mutable_filecreate();
  void set_allocated_filecreate(::proto::FileCreateTransactionBody* filecreate);
  private:
  const ::proto::FileCreateTransactionBody& _internal_filecreate() const;
  ::proto::FileCreateTransactionBody* _internal_mutable_filecreate();
  public:
  void unsafe_arena_set_allocated_filecreate(
      ::proto::FileCreateTransactionBody* filecreate);
  ::proto::FileCreateTransactionBody* unsafe_arena_release_filecreate();

  // .proto.FileDeleteTransactionBody fileDelete = 13;
  bool has_filedelete() const;
  private:
  bool _internal_has_filedelete() const;
  public:
  void clear_filedelete();
  const ::proto::FileDeleteTransactionBody& filedelete() const;
  PROTOBUF_NODISCARD ::proto::FileDeleteTransactionBody* release_filedelete();
  ::proto::FileDeleteTransactionBody* mutable_filedelete();
  void set_allocated_filedelete(::proto::FileDeleteTransactionBody* filedelete);
  private:
  const ::proto::FileDeleteTransactionBody& _internal_filedelete() const;
  ::proto::FileDeleteTransactionBody* _internal_mutable_filedelete();
  public:
  void unsafe_arena_set_allocated_filedelete(
      ::proto::FileDeleteTransactionBody* filedelete);
  ::proto::FileDeleteTransactionBody* unsafe_arena_release_filedelete();

  // .proto.FileUpdateTransactionBody fileUpdate = 14;
  bool has_fileupdate() const;
  private:
  bool _internal_has_fileupdate() const;
  public:
  void clear_fileupdate();
  const ::proto::FileUpdateTransactionBody& fileupdate() const;
  PROTOBUF_NODISCARD ::proto::FileUpdateTransactionBody* release_fileupdate();
  ::proto::FileUpdateTransactionBody* mutable_fileupdate();
  void set_allocated_fileupdate(::proto::FileUpdateTransactionBody* fileupdate);
  private:
  const ::proto::FileUpdateTransactionBody& _internal_fileupdate() const;
  ::proto::FileUpdateTransactionBody* _internal_mutable_fileupdate();
  public:
  void unsafe_arena_set_allocated_fileupdate(
      ::proto::FileUpdateTransactionBody* fileupdate);
  ::proto::FileUpdateTransactionBody* unsafe_arena_release_fileupdate();

  // .proto.SystemDeleteTransactionBody systemDelete = 15;
  bool has_systemdelete() const;
  private:
  bool _internal_has_systemdelete() const;
  public:
  void clear_systemdelete();
  const ::proto::SystemDeleteTransactionBody& systemdelete() const;
  PROTOBUF_NODISCARD ::proto::SystemDeleteTransactionBody* release_systemdelete();
  ::proto::SystemDeleteTransactionBody* mutable_systemdelete();
  void set_allocated_systemdelete(::proto::SystemDeleteTransactionBody* systemdelete);
  private:
  const ::proto::SystemDeleteTransactionBody& _internal_systemdelete() const;
  ::proto::SystemDeleteTransactionBody* _internal_mutable_systemdelete();
  public:
  void unsafe_arena_set_allocated_systemdelete(
      ::proto::SystemDeleteTransactionBody* systemdelete);
  ::proto::SystemDeleteTransactionBody* unsafe_arena_release_systemdelete();

  // .proto.SystemUndeleteTransactionBody systemUndelete = 16;
  bool has_systemundelete() const;
  private:
  bool _internal_has_systemundelete() const;
  public:
  void clear_systemundelete();
  const ::proto::SystemUndeleteTransactionBody& systemundelete() const;
  PROTOBUF_NODISCARD ::proto::SystemUndeleteTransactionBody* release_systemundelete();
  ::proto::SystemUndeleteTransactionBody* mutable_systemundelete();
  void set_allocated_systemundelete(::proto::SystemUndeleteTransactionBody* systemundelete);
  private:
  const ::proto::SystemUndeleteTransactionBody& _internal_systemundelete() const;
  ::proto::SystemUndeleteTransactionBody* _internal_mutable_systemundelete();
  public:
  void unsafe_arena_set_allocated_systemundelete(
      ::proto::SystemUndeleteTransactionBody* systemundelete);
  ::proto::SystemUndeleteTransactionBody* unsafe_arena_release_systemundelete();

  // .proto.FreezeTransactionBody freeze = 17;
  bool has_freeze() const;
  private:
  bool _internal_has_freeze() const;
  public:
  void clear_freeze();
  const ::proto::FreezeTransactionBody& freeze() const;
  PROTOBUF_NODISCARD ::proto::FreezeTransactionBody* release_freeze();
  ::proto::FreezeTransactionBody* mutable_freeze();
  void set_allocated_freeze(::proto::FreezeTransactionBody* freeze);
  private:
  const ::proto::FreezeTransactionBody& _internal_freeze() const;
  ::proto::FreezeTransactionBody* _internal_mutable_freeze();
  public:
  void unsafe_arena_set_allocated_freeze(
      ::proto::FreezeTransactionBody* freeze);
  ::proto::FreezeTransactionBody* unsafe_arena_release_freeze();

  // .proto.ConsensusCreateTopicTransactionBody consensusCreateTopic = 18;
  bool has_consensuscreatetopic() const;
  private:
  bool _internal_has_consensuscreatetopic() const;
  public:
  void clear_consensuscreatetopic();
  const ::proto::ConsensusCreateTopicTransactionBody& consensuscreatetopic() const;
  PROTOBUF_NODISCARD ::proto::ConsensusCreateTopicTransactionBody* release_consensuscreatetopic();
  ::proto::ConsensusCreateTopicTransactionBody* mutable_consensuscreatetopic();
  void set_allocated_consensuscreatetopic(::proto::ConsensusCreateTopicTransactionBody* consensuscreatetopic);
  private:
  const ::proto::ConsensusCreateTopicTransactionBody& _internal_consensuscreatetopic() const;
  ::proto::ConsensusCreateTopicTransactionBody* _internal_mutable_consensuscreatetopic();
  public:
  void unsafe_arena_set_allocated_consensuscreatetopic(
      ::proto::ConsensusCreateTopicTransactionBody* consensuscreatetopic);
  ::proto::ConsensusCreateTopicTransactionBody* unsafe_arena_release_consensuscreatetopic();

  // .proto.ConsensusUpdateTopicTransactionBody consensusUpdateTopic = 19;
  bool has_consensusupdatetopic() const;
  private:
  bool _internal_has_consensusupdatetopic() const;
  public:
  void clear_consensusupdatetopic();
  const ::proto::ConsensusUpdateTopicTransactionBody& consensusupdatetopic() const;
  PROTOBUF_NODISCARD ::proto::ConsensusUpdateTopicTransactionBody* release_consensusupdatetopic();
  ::proto::ConsensusUpdateTopicTransactionBody* mutable_consensusupdatetopic();
  void set_allocated_consensusupdatetopic(::proto::ConsensusUpdateTopicTransactionBody* consensusupdatetopic);
  private:
  const ::proto::ConsensusUpdateTopicTransactionBody& _internal_consensusupdatetopic() const;
  ::proto::ConsensusUpdateTopicTransactionBody* _internal_mutable_consensusupdatetopic();
  public:
  void unsafe_arena_set_allocated_consensusupdatetopic(
      ::proto::ConsensusUpdateTopicTransactionBody* consensusupdatetopic);
  ::proto::ConsensusUpdateTopicTransactionBody* unsafe_arena_release_consensusupdatetopic();

  // .proto.ConsensusDeleteTopicTransactionBody consensusDeleteTopic = 20;
  bool has_consensusdeletetopic() const;
  private:
  bool _internal_has_consensusdeletetopic() const;
  public:
  void clear_consensusdeletetopic();
  const ::proto::ConsensusDeleteTopicTransactionBody& consensusdeletetopic() const;
  PROTOBUF_NODISCARD ::proto::ConsensusDeleteTopicTransactionBody* release_consensusdeletetopic();
  ::proto::ConsensusDeleteTopicTransactionBody* mutable_consensusdeletetopic();
  void set_allocated_consensusdeletetopic(::proto::ConsensusDeleteTopicTransactionBody* consensusdeletetopic);
  private:
  const ::proto::ConsensusDeleteTopicTransactionBody& _internal_consensusdeletetopic() const;
  ::proto::ConsensusDeleteTopicTransactionBody* _internal_mutable_consensusdeletetopic();
  public:
  void unsafe_arena_set_allocated_consensusdeletetopic(
      ::proto::ConsensusDeleteTopicTransactionBody* consensusdeletetopic);
  ::proto::ConsensusDeleteTopicTransactionBody* unsafe_arena_release_consensusdeletetopic();

  // .proto.ConsensusSubmitMessageTransactionBody consensusSubmitMessage = 21;
  bool has_consensussubmitmessage() const;
  private:
  bool _internal_has_consensussubmitmessage() const;
  public:
  void clear_consensussubmitmessage();
  const ::proto::ConsensusSubmitMessageTransactionBody& consensussubmitmessage() const;
  PROTOBUF_NODISCARD ::proto::ConsensusSubmitMessageTransactionBody* release_consensussubmitmessage();
  ::proto::ConsensusSubmitMessageTransactionBody* mutable_consensussubmitmessage();
  void set_allocated_consensussubmitmessage(::proto::ConsensusSubmitMessageTransactionBody* consensussubmitmessage);
  private:
  const ::proto::ConsensusSubmitMessageTransactionBody& _internal_consensussubmitmessage() const;
  ::proto::ConsensusSubmitMessageTransactionBody* _internal_mutable_consensussubmitmessage();
  public:
  void unsafe_arena_set_allocated_consensussubmitmessage(
      ::proto::ConsensusSubmitMessageTransactionBody* consensussubmitmessage);
  ::proto::ConsensusSubmitMessageTransactionBody* unsafe_arena_release_consensussubmitmessage();

  // .proto.TokenCreateTransactionBody tokenCreation = 22;
  bool has_tokencreation() const;
  private:
  bool _internal_has_tokencreation() const;
  public:
  void clear_tokencreation();
  const ::proto::TokenCreateTransactionBody& tokencreation() const;
  PROTOBUF_NODISCARD ::proto::TokenCreateTransactionBody* release_tokencreation();
  ::proto::TokenCreateTransactionBody* mutable_tokencreation();
  void set_allocated_tokencreation(::proto::TokenCreateTransactionBody* tokencreation);
  private:
  const ::proto::TokenCreateTransactionBody& _internal_tokencreation() const;
  ::proto::TokenCreateTransactionBody* _internal_mutable_tokencreation();
  public:
  void unsafe_arena_set_allocated_tokencreation(
      ::proto::TokenCreateTransactionBody* tokencreation);
  ::proto::TokenCreateTransactionBody* unsafe_arena_release_tokencreation();

  // .proto.TokenFreezeAccountTransactionBody tokenFreeze = 23;
  bool has_tokenfreeze() const;
  private:
  bool _internal_has_tokenfreeze() const;
  public:
  void clear_tokenfreeze();
  const ::proto::TokenFreezeAccountTransactionBody& tokenfreeze() const;
  PROTOBUF_NODISCARD ::proto::TokenFreezeAccountTransactionBody* release_tokenfreeze();
  ::proto::TokenFreezeAccountTransactionBody* mutable_tokenfreeze();
  void set_allocated_tokenfreeze(::proto::TokenFreezeAccountTransactionBody* tokenfreeze);
  private:
  const ::proto::TokenFreezeAccountTransactionBody& _internal_tokenfreeze() const;
  ::proto::TokenFreezeAccountTransactionBody* _internal_mutable_tokenfreeze();
  public:
  void unsafe_arena_set_allocated_tokenfreeze(
      ::proto::TokenFreezeAccountTransactionBody* tokenfreeze);
  ::proto::TokenFreezeAccountTransactionBody* unsafe_arena_release_tokenfreeze();

  // .proto.TokenUnfreezeAccountTransactionBody tokenUnfreeze = 24;
  bool has_tokenunfreeze() const;
  private:
  bool _internal_has_tokenunfreeze() const;
  public:
  void clear_tokenunfreeze();
  const ::proto::TokenUnfreezeAccountTransactionBody& tokenunfreeze() const;
  PROTOBUF_NODISCARD ::proto::TokenUnfreezeAccountTransactionBody* release_tokenunfreeze();
  ::proto::TokenUnfreezeAccountTransactionBody* mutable_tokenunfreeze();
  void set_allocated_tokenunfreeze(::proto::TokenUnfreezeAccountTransactionBody* tokenunfreeze);
  private:
  const ::proto::TokenUnfreezeAccountTransactionBody& _internal_tokenunfreeze() const;
  ::proto::TokenUnfreezeAccountTransactionBody* _internal_mutable_tokenunfreeze();
  public:
  void unsafe_arena_set_allocated_tokenunfreeze(
      ::proto::TokenUnfreezeAccountTransactionBody* tokenunfreeze);
  ::proto::TokenUnfreezeAccountTransactionBody* unsafe_arena_release_tokenunfreeze();

  // .proto.TokenGrantKycTransactionBody tokenGrantKyc = 25;
  bool has_tokengrantkyc() const;
  private:
  bool _internal_has_tokengrantkyc() const;
  public:
  void clear_tokengrantkyc();
  const ::proto::TokenGrantKycTransactionBody& tokengrantkyc() const;
  PROTOBUF_NODISCARD ::proto::TokenGrantKycTransactionBody* release_tokengrantkyc();
  ::proto::TokenGrantKycTransactionBody* mutable_tokengrantkyc();
  void set_allocated_tokengrantkyc(::proto::TokenGrantKycTransactionBody* tokengrantkyc);
  private:
  const ::proto::TokenGrantKycTransactionBody& _internal_tokengrantkyc() const;
  ::proto::TokenGrantKycTransactionBody* _internal_mutable_tokengrantkyc();
  public:
  void unsafe_arena_set_allocated_tokengrantkyc(
      ::proto::TokenGrantKycTransactionBody* tokengrantkyc);
  ::proto::TokenGrantKycTransactionBody* unsafe_arena_release_tokengrantkyc();

  // .proto.TokenRevokeKycTransactionBody tokenRevokeKyc = 26;
  bool has_tokenrevokekyc() const;
  private:
  bool _internal_has_tokenrevokekyc() const;
  public:
  void clear_tokenrevokekyc();
  const ::proto::TokenRevokeKycTransactionBody& tokenrevokekyc() const;
  PROTOBUF_NODISCARD ::proto::TokenRevokeKycTransactionBody* release_tokenrevokekyc();
  ::proto::TokenRevokeKycTransactionBody* mutable_tokenrevokekyc();
  void set_allocated_tokenrevokekyc(::proto::TokenRevokeKycTransactionBody* tokenrevokekyc);
  private:
  const ::proto::TokenRevokeKycTransactionBody& _internal_tokenrevokekyc() const;
  ::proto::TokenRevokeKycTransactionBody* _internal_mutable_tokenrevokekyc();
  public:
  void unsafe_arena_set_allocated_tokenrevokekyc(
      ::proto::TokenRevokeKycTransactionBody* tokenrevokekyc);
  ::proto::TokenRevokeKycTransactionBody* unsafe_arena_release_tokenrevokekyc();

  // .proto.TokenDeleteTransactionBody tokenDeletion = 27;
  bool has_tokendeletion() const;
  private:
  bool _internal_has_tokendeletion() const;
  public:
  void clear_tokendeletion();
  const ::proto::TokenDeleteTransactionBody& tokendeletion() const;
  PROTOBUF_NODISCARD ::proto::TokenDeleteTransactionBody* release_tokendeletion();
  ::proto::TokenDeleteTransactionBody* mutable_tokendeletion();
  void set_allocated_tokendeletion(::proto::TokenDeleteTransactionBody* tokendeletion);
  private:
  const ::proto::TokenDeleteTransactionBody& _internal_tokendeletion() const;
  ::proto::TokenDeleteTransactionBody* _internal_mutable_tokendeletion();
  public:
  void unsafe_arena_set_allocated_tokendeletion(
      ::proto::TokenDeleteTransactionBody* tokendeletion);
  ::proto::TokenDeleteTransactionBody* unsafe_arena_release_tokendeletion();

  // .proto.TokenUpdateTransactionBody tokenUpdate = 28;
  bool has_tokenupdate() const;
  private:
  bool _internal_has_tokenupdate() const;
  public:
  void clear_tokenupdate();
  const ::proto::TokenUpdateTransactionBody& tokenupdate() const;
  PROTOBUF_NODISCARD ::proto::TokenUpdateTransactionBody* release_tokenupdate();
  ::proto::TokenUpdateTransactionBody* mutable_tokenupdate();
  void set_allocated_tokenupdate(::proto::TokenUpdateTransactionBody* tokenupdate);
  private:
  const ::proto::TokenUpdateTransactionBody& _internal_tokenupdate() const;
  ::proto::TokenUpdateTransactionBody* _internal_mutable_tokenupdate();
  public:
  void unsafe_arena_set_allocated_tokenupdate(
      ::proto::TokenUpdateTransactionBody* tokenupdate);
  ::proto::TokenUpdateTransactionBody* unsafe_arena_release_tokenupdate();

  // .proto.TokenMintTransactionBody tokenMint = 29;
  bool has_tokenmint() const;
  private:
  bool _internal_has_tokenmint() const;
  public:
  void clear_tokenmint();
  const ::proto::TokenMintTransactionBody& tokenmint() const;
  PROTOBUF_NODISCARD ::proto::TokenMintTransactionBody* release_tokenmint();
  ::proto::TokenMintTransactionBody* mutable_tokenmint();
  void set_allocated_tokenmint(::proto::TokenMintTransactionBody* tokenmint);
  private:
  const ::proto::TokenMintTransactionBody& _internal_tokenmint() const;
  ::proto::TokenMintTransactionBody* _internal_mutable_tokenmint();
  public:
  void unsafe_arena_set_allocated_tokenmint(
      ::proto::TokenMintTransactionBody* tokenmint);
  ::proto::TokenMintTransactionBody* unsafe_arena_release_tokenmint();

  // .proto.TokenBurnTransactionBody tokenBurn = 30;
  bool has_tokenburn() const;
  private:
  bool _internal_has_tokenburn() const;
  public:
  void clear_tokenburn();
  const ::proto::TokenBurnTransactionBody& tokenburn() const;
  PROTOBUF_NODISCARD ::proto::TokenBurnTransactionBody* release_tokenburn();
  ::proto::TokenBurnTransactionBody* mutable_tokenburn();
  void set_allocated_tokenburn(::proto::TokenBurnTransactionBody* tokenburn);
  private:
  const ::proto::TokenBurnTransactionBody& _internal_tokenburn() const;
  ::proto::TokenBurnTransactionBody* _internal_mutable_tokenburn();
  public:
  void unsafe_arena_set_allocated_tokenburn(
      ::proto::TokenBurnTransactionBody* tokenburn);
  ::proto::TokenBurnTransactionBody* unsafe_arena_release_tokenburn();

  // .proto.TokenWipeAccountTransactionBody tokenWipe = 31;
  bool has_tokenwipe() const;
  private:
  bool _internal_has_tokenwipe() const;
  public:
  void clear_tokenwipe();
  const ::proto::TokenWipeAccountTransactionBody& tokenwipe() const;
  PROTOBUF_NODISCARD ::proto::TokenWipeAccountTransactionBody* release_tokenwipe();
  ::proto::TokenWipeAccountTransactionBody* mutable_tokenwipe();
  void set_allocated_tokenwipe(::proto::TokenWipeAccountTransactionBody* tokenwipe);
  private:
  const ::proto::TokenWipeAccountTransactionBody& _internal_tokenwipe() const;
  ::proto::TokenWipeAccountTransactionBody* _internal_mutable_tokenwipe();
  public:
  void unsafe_arena_set_allocated_tokenwipe(
      ::proto::TokenWipeAccountTransactionBody* tokenwipe);
  ::proto::TokenWipeAccountTransactionBody* unsafe_arena_release_tokenwipe();

  // .proto.TokenAssociateTransactionBody tokenAssociate = 32;
  bool has_tokenassociate() const;
  private:
  bool _internal_has_tokenassociate() const;
  public:
  void clear_tokenassociate();
  const ::proto::TokenAssociateTransactionBody& tokenassociate() const;
  PROTOBUF_NODISCARD ::proto::TokenAssociateTransactionBody* release_tokenassociate();
  ::proto::TokenAssociateTransactionBody* mutable_tokenassociate();
  void set_allocated_tokenassociate(::proto::TokenAssociateTransactionBody* tokenassociate);
  private:
  const ::proto::TokenAssociateTransactionBody& _internal_tokenassociate() const;
  ::proto::TokenAssociateTransactionBody* _internal_mutable_tokenassociate();
  public:
  void unsafe_arena_set_allocated_tokenassociate(
      ::proto::TokenAssociateTransactionBody* tokenassociate);
  ::proto::TokenAssociateTransactionBody* unsafe_arena_release_tokenassociate();

  // .proto.TokenDissociateTransactionBody tokenDissociate = 33;
  bool has_tokendissociate() const;
  private:
  bool _internal_has_tokendissociate() const;
  public:
  void clear_tokendissociate();
  const ::proto::TokenDissociateTransactionBody& tokendissociate() const;
  PROTOBUF_NODISCARD ::proto::TokenDissociateTransactionBody* release_tokendissociate();
  ::proto::TokenDissociateTransactionBody* mutable_tokendissociate();
  void set_allocated_tokendissociate(::proto::TokenDissociateTransactionBody* tokendissociate);
  private:
  const ::proto::TokenDissociateTransactionBody& _internal_tokendissociate() const;
  ::proto::TokenDissociateTransactionBody* _internal_mutable_tokendissociate();
  public:
  void unsafe_arena_set_allocated_tokendissociate(
      ::proto::TokenDissociateTransactionBody* tokendissociate);
  ::proto::TokenDissociateTransactionBody* unsafe_arena_release_tokendissociate();

  // .proto.TokenFeeScheduleUpdateTransactionBody token_fee_schedule_update = 39;
  bool has_token_fee_schedule_update() const;
  private:
  bool _internal_has_token_fee_schedule_update() const;
  public:
  void clear_token_fee_schedule_update();
  const ::proto::TokenFeeScheduleUpdateTransactionBody& token_fee_schedule_update() const;
  PROTOBUF_NODISCARD ::proto::TokenFeeScheduleUpdateTransactionBody* release_token_fee_schedule_update();
  ::proto::TokenFeeScheduleUpdateTransactionBody* mutable_token_fee_schedule_update();
  void set_allocated_token_fee_schedule_update(::proto::TokenFeeScheduleUpdateTransactionBody* token_fee_schedule_update);
  private:
  const ::proto::TokenFeeScheduleUpdateTransactionBody& _internal_token_fee_schedule_update() const;
  ::proto::TokenFeeScheduleUpdateTransactionBody* _internal_mutable_token_fee_schedule_update();
  public:
  void unsafe_arena_set_allocated_token_fee_schedule_update(
      ::proto::TokenFeeScheduleUpdateTransactionBody* token_fee_schedule_update);
  ::proto::TokenFeeScheduleUpdateTransactionBody* unsafe_arena_release_token_fee_schedule_update();

  // .proto.TokenPauseTransactionBody token_pause = 35;
  bool has_token_pause() const;
  private:
  bool _internal_has_token_pause() const;
  public:
  void clear_token_pause();
  const ::proto::TokenPauseTransactionBody& token_pause() const;
  PROTOBUF_NODISCARD ::proto::TokenPauseTransactionBody* release_token_pause();
  ::proto::TokenPauseTransactionBody* mutable_token_pause();
  void set_allocated_token_pause(::proto::TokenPauseTransactionBody* token_pause);
  private:
  const ::proto::TokenPauseTransactionBody& _internal_token_pause() const;
  ::proto::TokenPauseTransactionBody* _internal_mutable_token_pause();
  public:
  void unsafe_arena_set_allocated_token_pause(
      ::proto::TokenPauseTransactionBody* token_pause);
  ::proto::TokenPauseTransactionBody* unsafe_arena_release_token_pause();

  // .proto.TokenUnpauseTransactionBody token_unpause = 36;
  bool has_token_unpause() const;
  private:
  bool _internal_has_token_unpause() const;
  public:
  void clear_token_unpause();
  const ::proto::TokenUnpauseTransactionBody& token_unpause() const;
  PROTOBUF_NODISCARD ::proto::TokenUnpauseTransactionBody* release_token_unpause();
  ::proto::TokenUnpauseTransactionBody* mutable_token_unpause();
  void set_allocated_token_unpause(::proto::TokenUnpauseTransactionBody* token_unpause);
  private:
  const ::proto::TokenUnpauseTransactionBody& _internal_token_unpause() const;
  ::proto::TokenUnpauseTransactionBody* _internal_mutable_token_unpause();
  public:
  void unsafe_arena_set_allocated_token_unpause(
      ::proto::TokenUnpauseTransactionBody* token_unpause);
  ::proto::TokenUnpauseTransactionBody* unsafe_arena_release_token_unpause();

  // .proto.ScheduleDeleteTransactionBody scheduleDelete = 34;
  bool has_scheduledelete() const;
  private:
  bool _internal_has_scheduledelete() const;
  public:
  void clear_scheduledelete();
  const ::proto::ScheduleDeleteTransactionBody& scheduledelete() const;
  PROTOBUF_NODISCARD ::proto::ScheduleDeleteTransactionBody* release_scheduledelete();
  ::proto::ScheduleDeleteTransactionBody* mutable_scheduledelete();
  void set_allocated_scheduledelete(::proto::ScheduleDeleteTransactionBody* scheduledelete);
  private:
  const ::proto::ScheduleDeleteTransactionBody& _internal_scheduledelete() const;
  ::proto::ScheduleDeleteTransactionBody* _internal_mutable_scheduledelete();
  public:
  void unsafe_arena_set_allocated_scheduledelete(
      ::proto::ScheduleDeleteTransactionBody* scheduledelete);
  ::proto::ScheduleDeleteTransactionBody* unsafe_arena_release_scheduledelete();

  // .proto.UtilPrngTransactionBody util_prng = 40;
  bool has_util_prng() const;
  private:
  bool _internal_has_util_prng() const;
  public:
  void clear_util_prng();
  const ::proto::UtilPrngTransactionBody& util_prng() const;
  PROTOBUF_NODISCARD ::proto::UtilPrngTransactionBody* release_util_prng();
  ::proto::UtilPrngTransactionBody* mutable_util_prng();
  void set_allocated_util_prng(::proto::UtilPrngTransactionBody* util_prng);
  private:
  const ::proto::UtilPrngTransactionBody& _internal_util_prng() const;
  ::proto::UtilPrngTransactionBody* _internal_mutable_util_prng();
  public:
  void unsafe_arena_set_allocated_util_prng(
      ::proto::UtilPrngTransactionBody* util_prng);
  ::proto::UtilPrngTransactionBody* unsafe_arena_release_util_prng();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:proto.SchedulableTransactionBody)
 private:
  class _Internal;
  void set_has_contractcall();
  void set_has_contractcreateinstance();
  void set_has_contractupdateinstance();
  void set_has_contractdeleteinstance();
  void set_has_cryptoapproveallowance();
  void set_has_cryptodeleteallowance();
  void set_has_cryptocreateaccount();
  void set_has_cryptodelete();
  void set_has_cryptotransfer();
  void set_has_cryptoupdateaccount();
  void set_has_fileappend();
  void set_has_filecreate();
  void set_has_filedelete();
  void set_has_fileupdate();
  void set_has_systemdelete();
  void set_has_systemundelete();
  void set_has_freeze();
  void set_has_consensuscreatetopic();
  void set_has_consensusupdatetopic();
  void set_has_consensusdeletetopic();
  void set_has_consensussubmitmessage();
  void set_has_tokencreation();
  void set_has_tokenfreeze();
  void set_has_tokenunfreeze();
  void set_has_tokengrantkyc();
  void set_has_tokenrevokekyc();
  void set_has_tokendeletion();
  void set_has_tokenupdate();
  void set_has_tokenmint();
  void set_has_tokenburn();
  void set_has_tokenwipe();
  void set_has_tokenassociate();
  void set_has_tokendissociate();
  void set_has_token_fee_schedule_update();
  void set_has_token_pause();
  void set_has_token_unpause();
  void set_has_scheduledelete();
  void set_has_util_prng();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memo_;
    uint64_t transactionfee_;
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::proto::ContractCallTransactionBody* contractcall_;
      ::proto::ContractCreateTransactionBody* contractcreateinstance_;
      ::proto::ContractUpdateTransactionBody* contractupdateinstance_;
      ::proto::ContractDeleteTransactionBody* contractdeleteinstance_;
      ::proto::CryptoApproveAllowanceTransactionBody* cryptoapproveallowance_;
      ::proto::CryptoDeleteAllowanceTransactionBody* cryptodeleteallowance_;
      ::proto::CryptoCreateTransactionBody* cryptocreateaccount_;
      ::proto::CryptoDeleteTransactionBody* cryptodelete_;
      ::proto::CryptoTransferTransactionBody* cryptotransfer_;
      ::proto::CryptoUpdateTransactionBody* cryptoupdateaccount_;
      ::proto::FileAppendTransactionBody* fileappend_;
      ::proto::FileCreateTransactionBody* filecreate_;
      ::proto::FileDeleteTransactionBody* filedelete_;
      ::proto::FileUpdateTransactionBody* fileupdate_;
      ::proto::SystemDeleteTransactionBody* systemdelete_;
      ::proto::SystemUndeleteTransactionBody* systemundelete_;
      ::proto::FreezeTransactionBody* freeze_;
      ::proto::ConsensusCreateTopicTransactionBody* consensuscreatetopic_;
      ::proto::ConsensusUpdateTopicTransactionBody* consensusupdatetopic_;
      ::proto::ConsensusDeleteTopicTransactionBody* consensusdeletetopic_;
      ::proto::ConsensusSubmitMessageTransactionBody* consensussubmitmessage_;
      ::proto::TokenCreateTransactionBody* tokencreation_;
      ::proto::TokenFreezeAccountTransactionBody* tokenfreeze_;
      ::proto::TokenUnfreezeAccountTransactionBody* tokenunfreeze_;
      ::proto::TokenGrantKycTransactionBody* tokengrantkyc_;
      ::proto::TokenRevokeKycTransactionBody* tokenrevokekyc_;
      ::proto::TokenDeleteTransactionBody* tokendeletion_;
      ::proto::TokenUpdateTransactionBody* tokenupdate_;
      ::proto::TokenMintTransactionBody* tokenmint_;
      ::proto::TokenBurnTransactionBody* tokenburn_;
      ::proto::TokenWipeAccountTransactionBody* tokenwipe_;
      ::proto::TokenAssociateTransactionBody* tokenassociate_;
      ::proto::TokenDissociateTransactionBody* tokendissociate_;
      ::proto::TokenFeeScheduleUpdateTransactionBody* token_fee_schedule_update_;
      ::proto::TokenPauseTransactionBody* token_pause_;
      ::proto::TokenUnpauseTransactionBody* token_unpause_;
      ::proto::ScheduleDeleteTransactionBody* scheduledelete_;
      ::proto::UtilPrngTransactionBody* util_prng_;
    } data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schedulable_5ftransaction_5fbody_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SchedulableTransactionBody

// uint64 transactionFee = 1;
inline void SchedulableTransactionBody::clear_transactionfee() {
  _impl_.transactionfee_ = uint64_t{0u};
}
inline uint64_t SchedulableTransactionBody::_internal_transactionfee() const {
  return _impl_.transactionfee_;
}
inline uint64_t SchedulableTransactionBody::transactionfee() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.transactionFee)
  return _internal_transactionfee();
}
inline void SchedulableTransactionBody::_internal_set_transactionfee(uint64_t value) {
  
  _impl_.transactionfee_ = value;
}
inline void SchedulableTransactionBody::set_transactionfee(uint64_t value) {
  _internal_set_transactionfee(value);
  // @@protoc_insertion_point(field_set:proto.SchedulableTransactionBody.transactionFee)
}

// string memo = 2;
inline void SchedulableTransactionBody::clear_memo() {
  _impl_.memo_.ClearToEmpty();
}
inline const std::string& SchedulableTransactionBody::memo() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.memo)
  return _internal_memo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchedulableTransactionBody::set_memo(ArgT0&& arg0, ArgT... args) {
 
 _impl_.memo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SchedulableTransactionBody.memo)
}
inline std::string* SchedulableTransactionBody::mutable_memo() {
  std::string* _s = _internal_mutable_memo();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.memo)
  return _s;
}
inline const std::string& SchedulableTransactionBody::_internal_memo() const {
  return _impl_.memo_.Get();
}
inline void SchedulableTransactionBody::_internal_set_memo(const std::string& value) {
  
  _impl_.memo_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedulableTransactionBody::_internal_mutable_memo() {
  
  return _impl_.memo_.Mutable(GetArenaForAllocation());
}
inline std::string* SchedulableTransactionBody::release_memo() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.memo)
  return _impl_.memo_.Release();
}
inline void SchedulableTransactionBody::set_allocated_memo(std::string* memo) {
  if (memo != nullptr) {
    
  } else {
    
  }
  _impl_.memo_.SetAllocated(memo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.memo_.IsDefault()) {
    _impl_.memo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.SchedulableTransactionBody.memo)
}

// .proto.ContractCallTransactionBody contractCall = 3;
inline bool SchedulableTransactionBody::_internal_has_contractcall() const {
  return data_case() == kContractCall;
}
inline bool SchedulableTransactionBody::has_contractcall() const {
  return _internal_has_contractcall();
}
inline void SchedulableTransactionBody::set_has_contractcall() {
  _impl_._oneof_case_[0] = kContractCall;
}
inline ::proto::ContractCallTransactionBody* SchedulableTransactionBody::release_contractcall() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.contractCall)
  if (_internal_has_contractcall()) {
    clear_has_data();
    ::proto::ContractCallTransactionBody* temp = _impl_.data_.contractcall_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.contractcall_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ContractCallTransactionBody& SchedulableTransactionBody::_internal_contractcall() const {
  return _internal_has_contractcall()
      ? *_impl_.data_.contractcall_
      : reinterpret_cast< ::proto::ContractCallTransactionBody&>(::proto::_ContractCallTransactionBody_default_instance_);
}
inline const ::proto::ContractCallTransactionBody& SchedulableTransactionBody::contractcall() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.contractCall)
  return _internal_contractcall();
}
inline ::proto::ContractCallTransactionBody* SchedulableTransactionBody::unsafe_arena_release_contractcall() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.contractCall)
  if (_internal_has_contractcall()) {
    clear_has_data();
    ::proto::ContractCallTransactionBody* temp = _impl_.data_.contractcall_;
    _impl_.data_.contractcall_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_contractcall(::proto::ContractCallTransactionBody* contractcall) {
  clear_data();
  if (contractcall) {
    set_has_contractcall();
    _impl_.data_.contractcall_ = contractcall;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.contractCall)
}
inline ::proto::ContractCallTransactionBody* SchedulableTransactionBody::_internal_mutable_contractcall() {
  if (!_internal_has_contractcall()) {
    clear_data();
    set_has_contractcall();
    _impl_.data_.contractcall_ = CreateMaybeMessage< ::proto::ContractCallTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.contractcall_;
}
inline ::proto::ContractCallTransactionBody* SchedulableTransactionBody::mutable_contractcall() {
  ::proto::ContractCallTransactionBody* _msg = _internal_mutable_contractcall();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.contractCall)
  return _msg;
}

// .proto.ContractCreateTransactionBody contractCreateInstance = 4;
inline bool SchedulableTransactionBody::_internal_has_contractcreateinstance() const {
  return data_case() == kContractCreateInstance;
}
inline bool SchedulableTransactionBody::has_contractcreateinstance() const {
  return _internal_has_contractcreateinstance();
}
inline void SchedulableTransactionBody::set_has_contractcreateinstance() {
  _impl_._oneof_case_[0] = kContractCreateInstance;
}
inline ::proto::ContractCreateTransactionBody* SchedulableTransactionBody::release_contractcreateinstance() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.contractCreateInstance)
  if (_internal_has_contractcreateinstance()) {
    clear_has_data();
    ::proto::ContractCreateTransactionBody* temp = _impl_.data_.contractcreateinstance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.contractcreateinstance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ContractCreateTransactionBody& SchedulableTransactionBody::_internal_contractcreateinstance() const {
  return _internal_has_contractcreateinstance()
      ? *_impl_.data_.contractcreateinstance_
      : reinterpret_cast< ::proto::ContractCreateTransactionBody&>(::proto::_ContractCreateTransactionBody_default_instance_);
}
inline const ::proto::ContractCreateTransactionBody& SchedulableTransactionBody::contractcreateinstance() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.contractCreateInstance)
  return _internal_contractcreateinstance();
}
inline ::proto::ContractCreateTransactionBody* SchedulableTransactionBody::unsafe_arena_release_contractcreateinstance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.contractCreateInstance)
  if (_internal_has_contractcreateinstance()) {
    clear_has_data();
    ::proto::ContractCreateTransactionBody* temp = _impl_.data_.contractcreateinstance_;
    _impl_.data_.contractcreateinstance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_contractcreateinstance(::proto::ContractCreateTransactionBody* contractcreateinstance) {
  clear_data();
  if (contractcreateinstance) {
    set_has_contractcreateinstance();
    _impl_.data_.contractcreateinstance_ = contractcreateinstance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.contractCreateInstance)
}
inline ::proto::ContractCreateTransactionBody* SchedulableTransactionBody::_internal_mutable_contractcreateinstance() {
  if (!_internal_has_contractcreateinstance()) {
    clear_data();
    set_has_contractcreateinstance();
    _impl_.data_.contractcreateinstance_ = CreateMaybeMessage< ::proto::ContractCreateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.contractcreateinstance_;
}
inline ::proto::ContractCreateTransactionBody* SchedulableTransactionBody::mutable_contractcreateinstance() {
  ::proto::ContractCreateTransactionBody* _msg = _internal_mutable_contractcreateinstance();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.contractCreateInstance)
  return _msg;
}

// .proto.ContractUpdateTransactionBody contractUpdateInstance = 5;
inline bool SchedulableTransactionBody::_internal_has_contractupdateinstance() const {
  return data_case() == kContractUpdateInstance;
}
inline bool SchedulableTransactionBody::has_contractupdateinstance() const {
  return _internal_has_contractupdateinstance();
}
inline void SchedulableTransactionBody::set_has_contractupdateinstance() {
  _impl_._oneof_case_[0] = kContractUpdateInstance;
}
inline ::proto::ContractUpdateTransactionBody* SchedulableTransactionBody::release_contractupdateinstance() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.contractUpdateInstance)
  if (_internal_has_contractupdateinstance()) {
    clear_has_data();
    ::proto::ContractUpdateTransactionBody* temp = _impl_.data_.contractupdateinstance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.contractupdateinstance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ContractUpdateTransactionBody& SchedulableTransactionBody::_internal_contractupdateinstance() const {
  return _internal_has_contractupdateinstance()
      ? *_impl_.data_.contractupdateinstance_
      : reinterpret_cast< ::proto::ContractUpdateTransactionBody&>(::proto::_ContractUpdateTransactionBody_default_instance_);
}
inline const ::proto::ContractUpdateTransactionBody& SchedulableTransactionBody::contractupdateinstance() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.contractUpdateInstance)
  return _internal_contractupdateinstance();
}
inline ::proto::ContractUpdateTransactionBody* SchedulableTransactionBody::unsafe_arena_release_contractupdateinstance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.contractUpdateInstance)
  if (_internal_has_contractupdateinstance()) {
    clear_has_data();
    ::proto::ContractUpdateTransactionBody* temp = _impl_.data_.contractupdateinstance_;
    _impl_.data_.contractupdateinstance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_contractupdateinstance(::proto::ContractUpdateTransactionBody* contractupdateinstance) {
  clear_data();
  if (contractupdateinstance) {
    set_has_contractupdateinstance();
    _impl_.data_.contractupdateinstance_ = contractupdateinstance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.contractUpdateInstance)
}
inline ::proto::ContractUpdateTransactionBody* SchedulableTransactionBody::_internal_mutable_contractupdateinstance() {
  if (!_internal_has_contractupdateinstance()) {
    clear_data();
    set_has_contractupdateinstance();
    _impl_.data_.contractupdateinstance_ = CreateMaybeMessage< ::proto::ContractUpdateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.contractupdateinstance_;
}
inline ::proto::ContractUpdateTransactionBody* SchedulableTransactionBody::mutable_contractupdateinstance() {
  ::proto::ContractUpdateTransactionBody* _msg = _internal_mutable_contractupdateinstance();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.contractUpdateInstance)
  return _msg;
}

// .proto.ContractDeleteTransactionBody contractDeleteInstance = 6;
inline bool SchedulableTransactionBody::_internal_has_contractdeleteinstance() const {
  return data_case() == kContractDeleteInstance;
}
inline bool SchedulableTransactionBody::has_contractdeleteinstance() const {
  return _internal_has_contractdeleteinstance();
}
inline void SchedulableTransactionBody::set_has_contractdeleteinstance() {
  _impl_._oneof_case_[0] = kContractDeleteInstance;
}
inline ::proto::ContractDeleteTransactionBody* SchedulableTransactionBody::release_contractdeleteinstance() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.contractDeleteInstance)
  if (_internal_has_contractdeleteinstance()) {
    clear_has_data();
    ::proto::ContractDeleteTransactionBody* temp = _impl_.data_.contractdeleteinstance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.contractdeleteinstance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ContractDeleteTransactionBody& SchedulableTransactionBody::_internal_contractdeleteinstance() const {
  return _internal_has_contractdeleteinstance()
      ? *_impl_.data_.contractdeleteinstance_
      : reinterpret_cast< ::proto::ContractDeleteTransactionBody&>(::proto::_ContractDeleteTransactionBody_default_instance_);
}
inline const ::proto::ContractDeleteTransactionBody& SchedulableTransactionBody::contractdeleteinstance() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.contractDeleteInstance)
  return _internal_contractdeleteinstance();
}
inline ::proto::ContractDeleteTransactionBody* SchedulableTransactionBody::unsafe_arena_release_contractdeleteinstance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.contractDeleteInstance)
  if (_internal_has_contractdeleteinstance()) {
    clear_has_data();
    ::proto::ContractDeleteTransactionBody* temp = _impl_.data_.contractdeleteinstance_;
    _impl_.data_.contractdeleteinstance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_contractdeleteinstance(::proto::ContractDeleteTransactionBody* contractdeleteinstance) {
  clear_data();
  if (contractdeleteinstance) {
    set_has_contractdeleteinstance();
    _impl_.data_.contractdeleteinstance_ = contractdeleteinstance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.contractDeleteInstance)
}
inline ::proto::ContractDeleteTransactionBody* SchedulableTransactionBody::_internal_mutable_contractdeleteinstance() {
  if (!_internal_has_contractdeleteinstance()) {
    clear_data();
    set_has_contractdeleteinstance();
    _impl_.data_.contractdeleteinstance_ = CreateMaybeMessage< ::proto::ContractDeleteTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.contractdeleteinstance_;
}
inline ::proto::ContractDeleteTransactionBody* SchedulableTransactionBody::mutable_contractdeleteinstance() {
  ::proto::ContractDeleteTransactionBody* _msg = _internal_mutable_contractdeleteinstance();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.contractDeleteInstance)
  return _msg;
}

// .proto.CryptoApproveAllowanceTransactionBody cryptoApproveAllowance = 37;
inline bool SchedulableTransactionBody::_internal_has_cryptoapproveallowance() const {
  return data_case() == kCryptoApproveAllowance;
}
inline bool SchedulableTransactionBody::has_cryptoapproveallowance() const {
  return _internal_has_cryptoapproveallowance();
}
inline void SchedulableTransactionBody::set_has_cryptoapproveallowance() {
  _impl_._oneof_case_[0] = kCryptoApproveAllowance;
}
inline ::proto::CryptoApproveAllowanceTransactionBody* SchedulableTransactionBody::release_cryptoapproveallowance() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.cryptoApproveAllowance)
  if (_internal_has_cryptoapproveallowance()) {
    clear_has_data();
    ::proto::CryptoApproveAllowanceTransactionBody* temp = _impl_.data_.cryptoapproveallowance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.cryptoapproveallowance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::CryptoApproveAllowanceTransactionBody& SchedulableTransactionBody::_internal_cryptoapproveallowance() const {
  return _internal_has_cryptoapproveallowance()
      ? *_impl_.data_.cryptoapproveallowance_
      : reinterpret_cast< ::proto::CryptoApproveAllowanceTransactionBody&>(::proto::_CryptoApproveAllowanceTransactionBody_default_instance_);
}
inline const ::proto::CryptoApproveAllowanceTransactionBody& SchedulableTransactionBody::cryptoapproveallowance() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.cryptoApproveAllowance)
  return _internal_cryptoapproveallowance();
}
inline ::proto::CryptoApproveAllowanceTransactionBody* SchedulableTransactionBody::unsafe_arena_release_cryptoapproveallowance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.cryptoApproveAllowance)
  if (_internal_has_cryptoapproveallowance()) {
    clear_has_data();
    ::proto::CryptoApproveAllowanceTransactionBody* temp = _impl_.data_.cryptoapproveallowance_;
    _impl_.data_.cryptoapproveallowance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_cryptoapproveallowance(::proto::CryptoApproveAllowanceTransactionBody* cryptoapproveallowance) {
  clear_data();
  if (cryptoapproveallowance) {
    set_has_cryptoapproveallowance();
    _impl_.data_.cryptoapproveallowance_ = cryptoapproveallowance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.cryptoApproveAllowance)
}
inline ::proto::CryptoApproveAllowanceTransactionBody* SchedulableTransactionBody::_internal_mutable_cryptoapproveallowance() {
  if (!_internal_has_cryptoapproveallowance()) {
    clear_data();
    set_has_cryptoapproveallowance();
    _impl_.data_.cryptoapproveallowance_ = CreateMaybeMessage< ::proto::CryptoApproveAllowanceTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.cryptoapproveallowance_;
}
inline ::proto::CryptoApproveAllowanceTransactionBody* SchedulableTransactionBody::mutable_cryptoapproveallowance() {
  ::proto::CryptoApproveAllowanceTransactionBody* _msg = _internal_mutable_cryptoapproveallowance();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.cryptoApproveAllowance)
  return _msg;
}

// .proto.CryptoDeleteAllowanceTransactionBody cryptoDeleteAllowance = 38;
inline bool SchedulableTransactionBody::_internal_has_cryptodeleteallowance() const {
  return data_case() == kCryptoDeleteAllowance;
}
inline bool SchedulableTransactionBody::has_cryptodeleteallowance() const {
  return _internal_has_cryptodeleteallowance();
}
inline void SchedulableTransactionBody::set_has_cryptodeleteallowance() {
  _impl_._oneof_case_[0] = kCryptoDeleteAllowance;
}
inline ::proto::CryptoDeleteAllowanceTransactionBody* SchedulableTransactionBody::release_cryptodeleteallowance() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.cryptoDeleteAllowance)
  if (_internal_has_cryptodeleteallowance()) {
    clear_has_data();
    ::proto::CryptoDeleteAllowanceTransactionBody* temp = _impl_.data_.cryptodeleteallowance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.cryptodeleteallowance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::CryptoDeleteAllowanceTransactionBody& SchedulableTransactionBody::_internal_cryptodeleteallowance() const {
  return _internal_has_cryptodeleteallowance()
      ? *_impl_.data_.cryptodeleteallowance_
      : reinterpret_cast< ::proto::CryptoDeleteAllowanceTransactionBody&>(::proto::_CryptoDeleteAllowanceTransactionBody_default_instance_);
}
inline const ::proto::CryptoDeleteAllowanceTransactionBody& SchedulableTransactionBody::cryptodeleteallowance() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.cryptoDeleteAllowance)
  return _internal_cryptodeleteallowance();
}
inline ::proto::CryptoDeleteAllowanceTransactionBody* SchedulableTransactionBody::unsafe_arena_release_cryptodeleteallowance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.cryptoDeleteAllowance)
  if (_internal_has_cryptodeleteallowance()) {
    clear_has_data();
    ::proto::CryptoDeleteAllowanceTransactionBody* temp = _impl_.data_.cryptodeleteallowance_;
    _impl_.data_.cryptodeleteallowance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_cryptodeleteallowance(::proto::CryptoDeleteAllowanceTransactionBody* cryptodeleteallowance) {
  clear_data();
  if (cryptodeleteallowance) {
    set_has_cryptodeleteallowance();
    _impl_.data_.cryptodeleteallowance_ = cryptodeleteallowance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.cryptoDeleteAllowance)
}
inline ::proto::CryptoDeleteAllowanceTransactionBody* SchedulableTransactionBody::_internal_mutable_cryptodeleteallowance() {
  if (!_internal_has_cryptodeleteallowance()) {
    clear_data();
    set_has_cryptodeleteallowance();
    _impl_.data_.cryptodeleteallowance_ = CreateMaybeMessage< ::proto::CryptoDeleteAllowanceTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.cryptodeleteallowance_;
}
inline ::proto::CryptoDeleteAllowanceTransactionBody* SchedulableTransactionBody::mutable_cryptodeleteallowance() {
  ::proto::CryptoDeleteAllowanceTransactionBody* _msg = _internal_mutable_cryptodeleteallowance();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.cryptoDeleteAllowance)
  return _msg;
}

// .proto.CryptoCreateTransactionBody cryptoCreateAccount = 7;
inline bool SchedulableTransactionBody::_internal_has_cryptocreateaccount() const {
  return data_case() == kCryptoCreateAccount;
}
inline bool SchedulableTransactionBody::has_cryptocreateaccount() const {
  return _internal_has_cryptocreateaccount();
}
inline void SchedulableTransactionBody::set_has_cryptocreateaccount() {
  _impl_._oneof_case_[0] = kCryptoCreateAccount;
}
inline ::proto::CryptoCreateTransactionBody* SchedulableTransactionBody::release_cryptocreateaccount() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.cryptoCreateAccount)
  if (_internal_has_cryptocreateaccount()) {
    clear_has_data();
    ::proto::CryptoCreateTransactionBody* temp = _impl_.data_.cryptocreateaccount_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.cryptocreateaccount_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::CryptoCreateTransactionBody& SchedulableTransactionBody::_internal_cryptocreateaccount() const {
  return _internal_has_cryptocreateaccount()
      ? *_impl_.data_.cryptocreateaccount_
      : reinterpret_cast< ::proto::CryptoCreateTransactionBody&>(::proto::_CryptoCreateTransactionBody_default_instance_);
}
inline const ::proto::CryptoCreateTransactionBody& SchedulableTransactionBody::cryptocreateaccount() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.cryptoCreateAccount)
  return _internal_cryptocreateaccount();
}
inline ::proto::CryptoCreateTransactionBody* SchedulableTransactionBody::unsafe_arena_release_cryptocreateaccount() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.cryptoCreateAccount)
  if (_internal_has_cryptocreateaccount()) {
    clear_has_data();
    ::proto::CryptoCreateTransactionBody* temp = _impl_.data_.cryptocreateaccount_;
    _impl_.data_.cryptocreateaccount_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_cryptocreateaccount(::proto::CryptoCreateTransactionBody* cryptocreateaccount) {
  clear_data();
  if (cryptocreateaccount) {
    set_has_cryptocreateaccount();
    _impl_.data_.cryptocreateaccount_ = cryptocreateaccount;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.cryptoCreateAccount)
}
inline ::proto::CryptoCreateTransactionBody* SchedulableTransactionBody::_internal_mutable_cryptocreateaccount() {
  if (!_internal_has_cryptocreateaccount()) {
    clear_data();
    set_has_cryptocreateaccount();
    _impl_.data_.cryptocreateaccount_ = CreateMaybeMessage< ::proto::CryptoCreateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.cryptocreateaccount_;
}
inline ::proto::CryptoCreateTransactionBody* SchedulableTransactionBody::mutable_cryptocreateaccount() {
  ::proto::CryptoCreateTransactionBody* _msg = _internal_mutable_cryptocreateaccount();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.cryptoCreateAccount)
  return _msg;
}

// .proto.CryptoDeleteTransactionBody cryptoDelete = 8;
inline bool SchedulableTransactionBody::_internal_has_cryptodelete() const {
  return data_case() == kCryptoDelete;
}
inline bool SchedulableTransactionBody::has_cryptodelete() const {
  return _internal_has_cryptodelete();
}
inline void SchedulableTransactionBody::set_has_cryptodelete() {
  _impl_._oneof_case_[0] = kCryptoDelete;
}
inline ::proto::CryptoDeleteTransactionBody* SchedulableTransactionBody::release_cryptodelete() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.cryptoDelete)
  if (_internal_has_cryptodelete()) {
    clear_has_data();
    ::proto::CryptoDeleteTransactionBody* temp = _impl_.data_.cryptodelete_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.cryptodelete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::CryptoDeleteTransactionBody& SchedulableTransactionBody::_internal_cryptodelete() const {
  return _internal_has_cryptodelete()
      ? *_impl_.data_.cryptodelete_
      : reinterpret_cast< ::proto::CryptoDeleteTransactionBody&>(::proto::_CryptoDeleteTransactionBody_default_instance_);
}
inline const ::proto::CryptoDeleteTransactionBody& SchedulableTransactionBody::cryptodelete() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.cryptoDelete)
  return _internal_cryptodelete();
}
inline ::proto::CryptoDeleteTransactionBody* SchedulableTransactionBody::unsafe_arena_release_cryptodelete() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.cryptoDelete)
  if (_internal_has_cryptodelete()) {
    clear_has_data();
    ::proto::CryptoDeleteTransactionBody* temp = _impl_.data_.cryptodelete_;
    _impl_.data_.cryptodelete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_cryptodelete(::proto::CryptoDeleteTransactionBody* cryptodelete) {
  clear_data();
  if (cryptodelete) {
    set_has_cryptodelete();
    _impl_.data_.cryptodelete_ = cryptodelete;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.cryptoDelete)
}
inline ::proto::CryptoDeleteTransactionBody* SchedulableTransactionBody::_internal_mutable_cryptodelete() {
  if (!_internal_has_cryptodelete()) {
    clear_data();
    set_has_cryptodelete();
    _impl_.data_.cryptodelete_ = CreateMaybeMessage< ::proto::CryptoDeleteTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.cryptodelete_;
}
inline ::proto::CryptoDeleteTransactionBody* SchedulableTransactionBody::mutable_cryptodelete() {
  ::proto::CryptoDeleteTransactionBody* _msg = _internal_mutable_cryptodelete();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.cryptoDelete)
  return _msg;
}

// .proto.CryptoTransferTransactionBody cryptoTransfer = 9;
inline bool SchedulableTransactionBody::_internal_has_cryptotransfer() const {
  return data_case() == kCryptoTransfer;
}
inline bool SchedulableTransactionBody::has_cryptotransfer() const {
  return _internal_has_cryptotransfer();
}
inline void SchedulableTransactionBody::set_has_cryptotransfer() {
  _impl_._oneof_case_[0] = kCryptoTransfer;
}
inline ::proto::CryptoTransferTransactionBody* SchedulableTransactionBody::release_cryptotransfer() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.cryptoTransfer)
  if (_internal_has_cryptotransfer()) {
    clear_has_data();
    ::proto::CryptoTransferTransactionBody* temp = _impl_.data_.cryptotransfer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.cryptotransfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::CryptoTransferTransactionBody& SchedulableTransactionBody::_internal_cryptotransfer() const {
  return _internal_has_cryptotransfer()
      ? *_impl_.data_.cryptotransfer_
      : reinterpret_cast< ::proto::CryptoTransferTransactionBody&>(::proto::_CryptoTransferTransactionBody_default_instance_);
}
inline const ::proto::CryptoTransferTransactionBody& SchedulableTransactionBody::cryptotransfer() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.cryptoTransfer)
  return _internal_cryptotransfer();
}
inline ::proto::CryptoTransferTransactionBody* SchedulableTransactionBody::unsafe_arena_release_cryptotransfer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.cryptoTransfer)
  if (_internal_has_cryptotransfer()) {
    clear_has_data();
    ::proto::CryptoTransferTransactionBody* temp = _impl_.data_.cryptotransfer_;
    _impl_.data_.cryptotransfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_cryptotransfer(::proto::CryptoTransferTransactionBody* cryptotransfer) {
  clear_data();
  if (cryptotransfer) {
    set_has_cryptotransfer();
    _impl_.data_.cryptotransfer_ = cryptotransfer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.cryptoTransfer)
}
inline ::proto::CryptoTransferTransactionBody* SchedulableTransactionBody::_internal_mutable_cryptotransfer() {
  if (!_internal_has_cryptotransfer()) {
    clear_data();
    set_has_cryptotransfer();
    _impl_.data_.cryptotransfer_ = CreateMaybeMessage< ::proto::CryptoTransferTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.cryptotransfer_;
}
inline ::proto::CryptoTransferTransactionBody* SchedulableTransactionBody::mutable_cryptotransfer() {
  ::proto::CryptoTransferTransactionBody* _msg = _internal_mutable_cryptotransfer();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.cryptoTransfer)
  return _msg;
}

// .proto.CryptoUpdateTransactionBody cryptoUpdateAccount = 10;
inline bool SchedulableTransactionBody::_internal_has_cryptoupdateaccount() const {
  return data_case() == kCryptoUpdateAccount;
}
inline bool SchedulableTransactionBody::has_cryptoupdateaccount() const {
  return _internal_has_cryptoupdateaccount();
}
inline void SchedulableTransactionBody::set_has_cryptoupdateaccount() {
  _impl_._oneof_case_[0] = kCryptoUpdateAccount;
}
inline ::proto::CryptoUpdateTransactionBody* SchedulableTransactionBody::release_cryptoupdateaccount() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.cryptoUpdateAccount)
  if (_internal_has_cryptoupdateaccount()) {
    clear_has_data();
    ::proto::CryptoUpdateTransactionBody* temp = _impl_.data_.cryptoupdateaccount_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.cryptoupdateaccount_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::CryptoUpdateTransactionBody& SchedulableTransactionBody::_internal_cryptoupdateaccount() const {
  return _internal_has_cryptoupdateaccount()
      ? *_impl_.data_.cryptoupdateaccount_
      : reinterpret_cast< ::proto::CryptoUpdateTransactionBody&>(::proto::_CryptoUpdateTransactionBody_default_instance_);
}
inline const ::proto::CryptoUpdateTransactionBody& SchedulableTransactionBody::cryptoupdateaccount() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.cryptoUpdateAccount)
  return _internal_cryptoupdateaccount();
}
inline ::proto::CryptoUpdateTransactionBody* SchedulableTransactionBody::unsafe_arena_release_cryptoupdateaccount() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.cryptoUpdateAccount)
  if (_internal_has_cryptoupdateaccount()) {
    clear_has_data();
    ::proto::CryptoUpdateTransactionBody* temp = _impl_.data_.cryptoupdateaccount_;
    _impl_.data_.cryptoupdateaccount_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_cryptoupdateaccount(::proto::CryptoUpdateTransactionBody* cryptoupdateaccount) {
  clear_data();
  if (cryptoupdateaccount) {
    set_has_cryptoupdateaccount();
    _impl_.data_.cryptoupdateaccount_ = cryptoupdateaccount;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.cryptoUpdateAccount)
}
inline ::proto::CryptoUpdateTransactionBody* SchedulableTransactionBody::_internal_mutable_cryptoupdateaccount() {
  if (!_internal_has_cryptoupdateaccount()) {
    clear_data();
    set_has_cryptoupdateaccount();
    _impl_.data_.cryptoupdateaccount_ = CreateMaybeMessage< ::proto::CryptoUpdateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.cryptoupdateaccount_;
}
inline ::proto::CryptoUpdateTransactionBody* SchedulableTransactionBody::mutable_cryptoupdateaccount() {
  ::proto::CryptoUpdateTransactionBody* _msg = _internal_mutable_cryptoupdateaccount();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.cryptoUpdateAccount)
  return _msg;
}

// .proto.FileAppendTransactionBody fileAppend = 11;
inline bool SchedulableTransactionBody::_internal_has_fileappend() const {
  return data_case() == kFileAppend;
}
inline bool SchedulableTransactionBody::has_fileappend() const {
  return _internal_has_fileappend();
}
inline void SchedulableTransactionBody::set_has_fileappend() {
  _impl_._oneof_case_[0] = kFileAppend;
}
inline ::proto::FileAppendTransactionBody* SchedulableTransactionBody::release_fileappend() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.fileAppend)
  if (_internal_has_fileappend()) {
    clear_has_data();
    ::proto::FileAppendTransactionBody* temp = _impl_.data_.fileappend_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.fileappend_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::FileAppendTransactionBody& SchedulableTransactionBody::_internal_fileappend() const {
  return _internal_has_fileappend()
      ? *_impl_.data_.fileappend_
      : reinterpret_cast< ::proto::FileAppendTransactionBody&>(::proto::_FileAppendTransactionBody_default_instance_);
}
inline const ::proto::FileAppendTransactionBody& SchedulableTransactionBody::fileappend() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.fileAppend)
  return _internal_fileappend();
}
inline ::proto::FileAppendTransactionBody* SchedulableTransactionBody::unsafe_arena_release_fileappend() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.fileAppend)
  if (_internal_has_fileappend()) {
    clear_has_data();
    ::proto::FileAppendTransactionBody* temp = _impl_.data_.fileappend_;
    _impl_.data_.fileappend_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_fileappend(::proto::FileAppendTransactionBody* fileappend) {
  clear_data();
  if (fileappend) {
    set_has_fileappend();
    _impl_.data_.fileappend_ = fileappend;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.fileAppend)
}
inline ::proto::FileAppendTransactionBody* SchedulableTransactionBody::_internal_mutable_fileappend() {
  if (!_internal_has_fileappend()) {
    clear_data();
    set_has_fileappend();
    _impl_.data_.fileappend_ = CreateMaybeMessage< ::proto::FileAppendTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.fileappend_;
}
inline ::proto::FileAppendTransactionBody* SchedulableTransactionBody::mutable_fileappend() {
  ::proto::FileAppendTransactionBody* _msg = _internal_mutable_fileappend();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.fileAppend)
  return _msg;
}

// .proto.FileCreateTransactionBody fileCreate = 12;
inline bool SchedulableTransactionBody::_internal_has_filecreate() const {
  return data_case() == kFileCreate;
}
inline bool SchedulableTransactionBody::has_filecreate() const {
  return _internal_has_filecreate();
}
inline void SchedulableTransactionBody::set_has_filecreate() {
  _impl_._oneof_case_[0] = kFileCreate;
}
inline ::proto::FileCreateTransactionBody* SchedulableTransactionBody::release_filecreate() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.fileCreate)
  if (_internal_has_filecreate()) {
    clear_has_data();
    ::proto::FileCreateTransactionBody* temp = _impl_.data_.filecreate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.filecreate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::FileCreateTransactionBody& SchedulableTransactionBody::_internal_filecreate() const {
  return _internal_has_filecreate()
      ? *_impl_.data_.filecreate_
      : reinterpret_cast< ::proto::FileCreateTransactionBody&>(::proto::_FileCreateTransactionBody_default_instance_);
}
inline const ::proto::FileCreateTransactionBody& SchedulableTransactionBody::filecreate() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.fileCreate)
  return _internal_filecreate();
}
inline ::proto::FileCreateTransactionBody* SchedulableTransactionBody::unsafe_arena_release_filecreate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.fileCreate)
  if (_internal_has_filecreate()) {
    clear_has_data();
    ::proto::FileCreateTransactionBody* temp = _impl_.data_.filecreate_;
    _impl_.data_.filecreate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_filecreate(::proto::FileCreateTransactionBody* filecreate) {
  clear_data();
  if (filecreate) {
    set_has_filecreate();
    _impl_.data_.filecreate_ = filecreate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.fileCreate)
}
inline ::proto::FileCreateTransactionBody* SchedulableTransactionBody::_internal_mutable_filecreate() {
  if (!_internal_has_filecreate()) {
    clear_data();
    set_has_filecreate();
    _impl_.data_.filecreate_ = CreateMaybeMessage< ::proto::FileCreateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.filecreate_;
}
inline ::proto::FileCreateTransactionBody* SchedulableTransactionBody::mutable_filecreate() {
  ::proto::FileCreateTransactionBody* _msg = _internal_mutable_filecreate();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.fileCreate)
  return _msg;
}

// .proto.FileDeleteTransactionBody fileDelete = 13;
inline bool SchedulableTransactionBody::_internal_has_filedelete() const {
  return data_case() == kFileDelete;
}
inline bool SchedulableTransactionBody::has_filedelete() const {
  return _internal_has_filedelete();
}
inline void SchedulableTransactionBody::set_has_filedelete() {
  _impl_._oneof_case_[0] = kFileDelete;
}
inline ::proto::FileDeleteTransactionBody* SchedulableTransactionBody::release_filedelete() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.fileDelete)
  if (_internal_has_filedelete()) {
    clear_has_data();
    ::proto::FileDeleteTransactionBody* temp = _impl_.data_.filedelete_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.filedelete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::FileDeleteTransactionBody& SchedulableTransactionBody::_internal_filedelete() const {
  return _internal_has_filedelete()
      ? *_impl_.data_.filedelete_
      : reinterpret_cast< ::proto::FileDeleteTransactionBody&>(::proto::_FileDeleteTransactionBody_default_instance_);
}
inline const ::proto::FileDeleteTransactionBody& SchedulableTransactionBody::filedelete() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.fileDelete)
  return _internal_filedelete();
}
inline ::proto::FileDeleteTransactionBody* SchedulableTransactionBody::unsafe_arena_release_filedelete() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.fileDelete)
  if (_internal_has_filedelete()) {
    clear_has_data();
    ::proto::FileDeleteTransactionBody* temp = _impl_.data_.filedelete_;
    _impl_.data_.filedelete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_filedelete(::proto::FileDeleteTransactionBody* filedelete) {
  clear_data();
  if (filedelete) {
    set_has_filedelete();
    _impl_.data_.filedelete_ = filedelete;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.fileDelete)
}
inline ::proto::FileDeleteTransactionBody* SchedulableTransactionBody::_internal_mutable_filedelete() {
  if (!_internal_has_filedelete()) {
    clear_data();
    set_has_filedelete();
    _impl_.data_.filedelete_ = CreateMaybeMessage< ::proto::FileDeleteTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.filedelete_;
}
inline ::proto::FileDeleteTransactionBody* SchedulableTransactionBody::mutable_filedelete() {
  ::proto::FileDeleteTransactionBody* _msg = _internal_mutable_filedelete();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.fileDelete)
  return _msg;
}

// .proto.FileUpdateTransactionBody fileUpdate = 14;
inline bool SchedulableTransactionBody::_internal_has_fileupdate() const {
  return data_case() == kFileUpdate;
}
inline bool SchedulableTransactionBody::has_fileupdate() const {
  return _internal_has_fileupdate();
}
inline void SchedulableTransactionBody::set_has_fileupdate() {
  _impl_._oneof_case_[0] = kFileUpdate;
}
inline ::proto::FileUpdateTransactionBody* SchedulableTransactionBody::release_fileupdate() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.fileUpdate)
  if (_internal_has_fileupdate()) {
    clear_has_data();
    ::proto::FileUpdateTransactionBody* temp = _impl_.data_.fileupdate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.fileupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::FileUpdateTransactionBody& SchedulableTransactionBody::_internal_fileupdate() const {
  return _internal_has_fileupdate()
      ? *_impl_.data_.fileupdate_
      : reinterpret_cast< ::proto::FileUpdateTransactionBody&>(::proto::_FileUpdateTransactionBody_default_instance_);
}
inline const ::proto::FileUpdateTransactionBody& SchedulableTransactionBody::fileupdate() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.fileUpdate)
  return _internal_fileupdate();
}
inline ::proto::FileUpdateTransactionBody* SchedulableTransactionBody::unsafe_arena_release_fileupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.fileUpdate)
  if (_internal_has_fileupdate()) {
    clear_has_data();
    ::proto::FileUpdateTransactionBody* temp = _impl_.data_.fileupdate_;
    _impl_.data_.fileupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_fileupdate(::proto::FileUpdateTransactionBody* fileupdate) {
  clear_data();
  if (fileupdate) {
    set_has_fileupdate();
    _impl_.data_.fileupdate_ = fileupdate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.fileUpdate)
}
inline ::proto::FileUpdateTransactionBody* SchedulableTransactionBody::_internal_mutable_fileupdate() {
  if (!_internal_has_fileupdate()) {
    clear_data();
    set_has_fileupdate();
    _impl_.data_.fileupdate_ = CreateMaybeMessage< ::proto::FileUpdateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.fileupdate_;
}
inline ::proto::FileUpdateTransactionBody* SchedulableTransactionBody::mutable_fileupdate() {
  ::proto::FileUpdateTransactionBody* _msg = _internal_mutable_fileupdate();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.fileUpdate)
  return _msg;
}

// .proto.SystemDeleteTransactionBody systemDelete = 15;
inline bool SchedulableTransactionBody::_internal_has_systemdelete() const {
  return data_case() == kSystemDelete;
}
inline bool SchedulableTransactionBody::has_systemdelete() const {
  return _internal_has_systemdelete();
}
inline void SchedulableTransactionBody::set_has_systemdelete() {
  _impl_._oneof_case_[0] = kSystemDelete;
}
inline ::proto::SystemDeleteTransactionBody* SchedulableTransactionBody::release_systemdelete() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.systemDelete)
  if (_internal_has_systemdelete()) {
    clear_has_data();
    ::proto::SystemDeleteTransactionBody* temp = _impl_.data_.systemdelete_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.systemdelete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::SystemDeleteTransactionBody& SchedulableTransactionBody::_internal_systemdelete() const {
  return _internal_has_systemdelete()
      ? *_impl_.data_.systemdelete_
      : reinterpret_cast< ::proto::SystemDeleteTransactionBody&>(::proto::_SystemDeleteTransactionBody_default_instance_);
}
inline const ::proto::SystemDeleteTransactionBody& SchedulableTransactionBody::systemdelete() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.systemDelete)
  return _internal_systemdelete();
}
inline ::proto::SystemDeleteTransactionBody* SchedulableTransactionBody::unsafe_arena_release_systemdelete() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.systemDelete)
  if (_internal_has_systemdelete()) {
    clear_has_data();
    ::proto::SystemDeleteTransactionBody* temp = _impl_.data_.systemdelete_;
    _impl_.data_.systemdelete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_systemdelete(::proto::SystemDeleteTransactionBody* systemdelete) {
  clear_data();
  if (systemdelete) {
    set_has_systemdelete();
    _impl_.data_.systemdelete_ = systemdelete;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.systemDelete)
}
inline ::proto::SystemDeleteTransactionBody* SchedulableTransactionBody::_internal_mutable_systemdelete() {
  if (!_internal_has_systemdelete()) {
    clear_data();
    set_has_systemdelete();
    _impl_.data_.systemdelete_ = CreateMaybeMessage< ::proto::SystemDeleteTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.systemdelete_;
}
inline ::proto::SystemDeleteTransactionBody* SchedulableTransactionBody::mutable_systemdelete() {
  ::proto::SystemDeleteTransactionBody* _msg = _internal_mutable_systemdelete();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.systemDelete)
  return _msg;
}

// .proto.SystemUndeleteTransactionBody systemUndelete = 16;
inline bool SchedulableTransactionBody::_internal_has_systemundelete() const {
  return data_case() == kSystemUndelete;
}
inline bool SchedulableTransactionBody::has_systemundelete() const {
  return _internal_has_systemundelete();
}
inline void SchedulableTransactionBody::set_has_systemundelete() {
  _impl_._oneof_case_[0] = kSystemUndelete;
}
inline ::proto::SystemUndeleteTransactionBody* SchedulableTransactionBody::release_systemundelete() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.systemUndelete)
  if (_internal_has_systemundelete()) {
    clear_has_data();
    ::proto::SystemUndeleteTransactionBody* temp = _impl_.data_.systemundelete_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.systemundelete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::SystemUndeleteTransactionBody& SchedulableTransactionBody::_internal_systemundelete() const {
  return _internal_has_systemundelete()
      ? *_impl_.data_.systemundelete_
      : reinterpret_cast< ::proto::SystemUndeleteTransactionBody&>(::proto::_SystemUndeleteTransactionBody_default_instance_);
}
inline const ::proto::SystemUndeleteTransactionBody& SchedulableTransactionBody::systemundelete() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.systemUndelete)
  return _internal_systemundelete();
}
inline ::proto::SystemUndeleteTransactionBody* SchedulableTransactionBody::unsafe_arena_release_systemundelete() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.systemUndelete)
  if (_internal_has_systemundelete()) {
    clear_has_data();
    ::proto::SystemUndeleteTransactionBody* temp = _impl_.data_.systemundelete_;
    _impl_.data_.systemundelete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_systemundelete(::proto::SystemUndeleteTransactionBody* systemundelete) {
  clear_data();
  if (systemundelete) {
    set_has_systemundelete();
    _impl_.data_.systemundelete_ = systemundelete;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.systemUndelete)
}
inline ::proto::SystemUndeleteTransactionBody* SchedulableTransactionBody::_internal_mutable_systemundelete() {
  if (!_internal_has_systemundelete()) {
    clear_data();
    set_has_systemundelete();
    _impl_.data_.systemundelete_ = CreateMaybeMessage< ::proto::SystemUndeleteTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.systemundelete_;
}
inline ::proto::SystemUndeleteTransactionBody* SchedulableTransactionBody::mutable_systemundelete() {
  ::proto::SystemUndeleteTransactionBody* _msg = _internal_mutable_systemundelete();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.systemUndelete)
  return _msg;
}

// .proto.FreezeTransactionBody freeze = 17;
inline bool SchedulableTransactionBody::_internal_has_freeze() const {
  return data_case() == kFreeze;
}
inline bool SchedulableTransactionBody::has_freeze() const {
  return _internal_has_freeze();
}
inline void SchedulableTransactionBody::set_has_freeze() {
  _impl_._oneof_case_[0] = kFreeze;
}
inline ::proto::FreezeTransactionBody* SchedulableTransactionBody::release_freeze() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.freeze)
  if (_internal_has_freeze()) {
    clear_has_data();
    ::proto::FreezeTransactionBody* temp = _impl_.data_.freeze_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.freeze_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::FreezeTransactionBody& SchedulableTransactionBody::_internal_freeze() const {
  return _internal_has_freeze()
      ? *_impl_.data_.freeze_
      : reinterpret_cast< ::proto::FreezeTransactionBody&>(::proto::_FreezeTransactionBody_default_instance_);
}
inline const ::proto::FreezeTransactionBody& SchedulableTransactionBody::freeze() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.freeze)
  return _internal_freeze();
}
inline ::proto::FreezeTransactionBody* SchedulableTransactionBody::unsafe_arena_release_freeze() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.freeze)
  if (_internal_has_freeze()) {
    clear_has_data();
    ::proto::FreezeTransactionBody* temp = _impl_.data_.freeze_;
    _impl_.data_.freeze_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_freeze(::proto::FreezeTransactionBody* freeze) {
  clear_data();
  if (freeze) {
    set_has_freeze();
    _impl_.data_.freeze_ = freeze;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.freeze)
}
inline ::proto::FreezeTransactionBody* SchedulableTransactionBody::_internal_mutable_freeze() {
  if (!_internal_has_freeze()) {
    clear_data();
    set_has_freeze();
    _impl_.data_.freeze_ = CreateMaybeMessage< ::proto::FreezeTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.freeze_;
}
inline ::proto::FreezeTransactionBody* SchedulableTransactionBody::mutable_freeze() {
  ::proto::FreezeTransactionBody* _msg = _internal_mutable_freeze();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.freeze)
  return _msg;
}

// .proto.ConsensusCreateTopicTransactionBody consensusCreateTopic = 18;
inline bool SchedulableTransactionBody::_internal_has_consensuscreatetopic() const {
  return data_case() == kConsensusCreateTopic;
}
inline bool SchedulableTransactionBody::has_consensuscreatetopic() const {
  return _internal_has_consensuscreatetopic();
}
inline void SchedulableTransactionBody::set_has_consensuscreatetopic() {
  _impl_._oneof_case_[0] = kConsensusCreateTopic;
}
inline ::proto::ConsensusCreateTopicTransactionBody* SchedulableTransactionBody::release_consensuscreatetopic() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.consensusCreateTopic)
  if (_internal_has_consensuscreatetopic()) {
    clear_has_data();
    ::proto::ConsensusCreateTopicTransactionBody* temp = _impl_.data_.consensuscreatetopic_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.consensuscreatetopic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ConsensusCreateTopicTransactionBody& SchedulableTransactionBody::_internal_consensuscreatetopic() const {
  return _internal_has_consensuscreatetopic()
      ? *_impl_.data_.consensuscreatetopic_
      : reinterpret_cast< ::proto::ConsensusCreateTopicTransactionBody&>(::proto::_ConsensusCreateTopicTransactionBody_default_instance_);
}
inline const ::proto::ConsensusCreateTopicTransactionBody& SchedulableTransactionBody::consensuscreatetopic() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.consensusCreateTopic)
  return _internal_consensuscreatetopic();
}
inline ::proto::ConsensusCreateTopicTransactionBody* SchedulableTransactionBody::unsafe_arena_release_consensuscreatetopic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.consensusCreateTopic)
  if (_internal_has_consensuscreatetopic()) {
    clear_has_data();
    ::proto::ConsensusCreateTopicTransactionBody* temp = _impl_.data_.consensuscreatetopic_;
    _impl_.data_.consensuscreatetopic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_consensuscreatetopic(::proto::ConsensusCreateTopicTransactionBody* consensuscreatetopic) {
  clear_data();
  if (consensuscreatetopic) {
    set_has_consensuscreatetopic();
    _impl_.data_.consensuscreatetopic_ = consensuscreatetopic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.consensusCreateTopic)
}
inline ::proto::ConsensusCreateTopicTransactionBody* SchedulableTransactionBody::_internal_mutable_consensuscreatetopic() {
  if (!_internal_has_consensuscreatetopic()) {
    clear_data();
    set_has_consensuscreatetopic();
    _impl_.data_.consensuscreatetopic_ = CreateMaybeMessage< ::proto::ConsensusCreateTopicTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.consensuscreatetopic_;
}
inline ::proto::ConsensusCreateTopicTransactionBody* SchedulableTransactionBody::mutable_consensuscreatetopic() {
  ::proto::ConsensusCreateTopicTransactionBody* _msg = _internal_mutable_consensuscreatetopic();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.consensusCreateTopic)
  return _msg;
}

// .proto.ConsensusUpdateTopicTransactionBody consensusUpdateTopic = 19;
inline bool SchedulableTransactionBody::_internal_has_consensusupdatetopic() const {
  return data_case() == kConsensusUpdateTopic;
}
inline bool SchedulableTransactionBody::has_consensusupdatetopic() const {
  return _internal_has_consensusupdatetopic();
}
inline void SchedulableTransactionBody::set_has_consensusupdatetopic() {
  _impl_._oneof_case_[0] = kConsensusUpdateTopic;
}
inline ::proto::ConsensusUpdateTopicTransactionBody* SchedulableTransactionBody::release_consensusupdatetopic() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.consensusUpdateTopic)
  if (_internal_has_consensusupdatetopic()) {
    clear_has_data();
    ::proto::ConsensusUpdateTopicTransactionBody* temp = _impl_.data_.consensusupdatetopic_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.consensusupdatetopic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ConsensusUpdateTopicTransactionBody& SchedulableTransactionBody::_internal_consensusupdatetopic() const {
  return _internal_has_consensusupdatetopic()
      ? *_impl_.data_.consensusupdatetopic_
      : reinterpret_cast< ::proto::ConsensusUpdateTopicTransactionBody&>(::proto::_ConsensusUpdateTopicTransactionBody_default_instance_);
}
inline const ::proto::ConsensusUpdateTopicTransactionBody& SchedulableTransactionBody::consensusupdatetopic() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.consensusUpdateTopic)
  return _internal_consensusupdatetopic();
}
inline ::proto::ConsensusUpdateTopicTransactionBody* SchedulableTransactionBody::unsafe_arena_release_consensusupdatetopic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.consensusUpdateTopic)
  if (_internal_has_consensusupdatetopic()) {
    clear_has_data();
    ::proto::ConsensusUpdateTopicTransactionBody* temp = _impl_.data_.consensusupdatetopic_;
    _impl_.data_.consensusupdatetopic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_consensusupdatetopic(::proto::ConsensusUpdateTopicTransactionBody* consensusupdatetopic) {
  clear_data();
  if (consensusupdatetopic) {
    set_has_consensusupdatetopic();
    _impl_.data_.consensusupdatetopic_ = consensusupdatetopic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.consensusUpdateTopic)
}
inline ::proto::ConsensusUpdateTopicTransactionBody* SchedulableTransactionBody::_internal_mutable_consensusupdatetopic() {
  if (!_internal_has_consensusupdatetopic()) {
    clear_data();
    set_has_consensusupdatetopic();
    _impl_.data_.consensusupdatetopic_ = CreateMaybeMessage< ::proto::ConsensusUpdateTopicTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.consensusupdatetopic_;
}
inline ::proto::ConsensusUpdateTopicTransactionBody* SchedulableTransactionBody::mutable_consensusupdatetopic() {
  ::proto::ConsensusUpdateTopicTransactionBody* _msg = _internal_mutable_consensusupdatetopic();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.consensusUpdateTopic)
  return _msg;
}

// .proto.ConsensusDeleteTopicTransactionBody consensusDeleteTopic = 20;
inline bool SchedulableTransactionBody::_internal_has_consensusdeletetopic() const {
  return data_case() == kConsensusDeleteTopic;
}
inline bool SchedulableTransactionBody::has_consensusdeletetopic() const {
  return _internal_has_consensusdeletetopic();
}
inline void SchedulableTransactionBody::set_has_consensusdeletetopic() {
  _impl_._oneof_case_[0] = kConsensusDeleteTopic;
}
inline ::proto::ConsensusDeleteTopicTransactionBody* SchedulableTransactionBody::release_consensusdeletetopic() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.consensusDeleteTopic)
  if (_internal_has_consensusdeletetopic()) {
    clear_has_data();
    ::proto::ConsensusDeleteTopicTransactionBody* temp = _impl_.data_.consensusdeletetopic_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.consensusdeletetopic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ConsensusDeleteTopicTransactionBody& SchedulableTransactionBody::_internal_consensusdeletetopic() const {
  return _internal_has_consensusdeletetopic()
      ? *_impl_.data_.consensusdeletetopic_
      : reinterpret_cast< ::proto::ConsensusDeleteTopicTransactionBody&>(::proto::_ConsensusDeleteTopicTransactionBody_default_instance_);
}
inline const ::proto::ConsensusDeleteTopicTransactionBody& SchedulableTransactionBody::consensusdeletetopic() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.consensusDeleteTopic)
  return _internal_consensusdeletetopic();
}
inline ::proto::ConsensusDeleteTopicTransactionBody* SchedulableTransactionBody::unsafe_arena_release_consensusdeletetopic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.consensusDeleteTopic)
  if (_internal_has_consensusdeletetopic()) {
    clear_has_data();
    ::proto::ConsensusDeleteTopicTransactionBody* temp = _impl_.data_.consensusdeletetopic_;
    _impl_.data_.consensusdeletetopic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_consensusdeletetopic(::proto::ConsensusDeleteTopicTransactionBody* consensusdeletetopic) {
  clear_data();
  if (consensusdeletetopic) {
    set_has_consensusdeletetopic();
    _impl_.data_.consensusdeletetopic_ = consensusdeletetopic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.consensusDeleteTopic)
}
inline ::proto::ConsensusDeleteTopicTransactionBody* SchedulableTransactionBody::_internal_mutable_consensusdeletetopic() {
  if (!_internal_has_consensusdeletetopic()) {
    clear_data();
    set_has_consensusdeletetopic();
    _impl_.data_.consensusdeletetopic_ = CreateMaybeMessage< ::proto::ConsensusDeleteTopicTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.consensusdeletetopic_;
}
inline ::proto::ConsensusDeleteTopicTransactionBody* SchedulableTransactionBody::mutable_consensusdeletetopic() {
  ::proto::ConsensusDeleteTopicTransactionBody* _msg = _internal_mutable_consensusdeletetopic();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.consensusDeleteTopic)
  return _msg;
}

// .proto.ConsensusSubmitMessageTransactionBody consensusSubmitMessage = 21;
inline bool SchedulableTransactionBody::_internal_has_consensussubmitmessage() const {
  return data_case() == kConsensusSubmitMessage;
}
inline bool SchedulableTransactionBody::has_consensussubmitmessage() const {
  return _internal_has_consensussubmitmessage();
}
inline void SchedulableTransactionBody::set_has_consensussubmitmessage() {
  _impl_._oneof_case_[0] = kConsensusSubmitMessage;
}
inline ::proto::ConsensusSubmitMessageTransactionBody* SchedulableTransactionBody::release_consensussubmitmessage() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.consensusSubmitMessage)
  if (_internal_has_consensussubmitmessage()) {
    clear_has_data();
    ::proto::ConsensusSubmitMessageTransactionBody* temp = _impl_.data_.consensussubmitmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.consensussubmitmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ConsensusSubmitMessageTransactionBody& SchedulableTransactionBody::_internal_consensussubmitmessage() const {
  return _internal_has_consensussubmitmessage()
      ? *_impl_.data_.consensussubmitmessage_
      : reinterpret_cast< ::proto::ConsensusSubmitMessageTransactionBody&>(::proto::_ConsensusSubmitMessageTransactionBody_default_instance_);
}
inline const ::proto::ConsensusSubmitMessageTransactionBody& SchedulableTransactionBody::consensussubmitmessage() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.consensusSubmitMessage)
  return _internal_consensussubmitmessage();
}
inline ::proto::ConsensusSubmitMessageTransactionBody* SchedulableTransactionBody::unsafe_arena_release_consensussubmitmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.consensusSubmitMessage)
  if (_internal_has_consensussubmitmessage()) {
    clear_has_data();
    ::proto::ConsensusSubmitMessageTransactionBody* temp = _impl_.data_.consensussubmitmessage_;
    _impl_.data_.consensussubmitmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_consensussubmitmessage(::proto::ConsensusSubmitMessageTransactionBody* consensussubmitmessage) {
  clear_data();
  if (consensussubmitmessage) {
    set_has_consensussubmitmessage();
    _impl_.data_.consensussubmitmessage_ = consensussubmitmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.consensusSubmitMessage)
}
inline ::proto::ConsensusSubmitMessageTransactionBody* SchedulableTransactionBody::_internal_mutable_consensussubmitmessage() {
  if (!_internal_has_consensussubmitmessage()) {
    clear_data();
    set_has_consensussubmitmessage();
    _impl_.data_.consensussubmitmessage_ = CreateMaybeMessage< ::proto::ConsensusSubmitMessageTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.consensussubmitmessage_;
}
inline ::proto::ConsensusSubmitMessageTransactionBody* SchedulableTransactionBody::mutable_consensussubmitmessage() {
  ::proto::ConsensusSubmitMessageTransactionBody* _msg = _internal_mutable_consensussubmitmessage();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.consensusSubmitMessage)
  return _msg;
}

// .proto.TokenCreateTransactionBody tokenCreation = 22;
inline bool SchedulableTransactionBody::_internal_has_tokencreation() const {
  return data_case() == kTokenCreation;
}
inline bool SchedulableTransactionBody::has_tokencreation() const {
  return _internal_has_tokencreation();
}
inline void SchedulableTransactionBody::set_has_tokencreation() {
  _impl_._oneof_case_[0] = kTokenCreation;
}
inline ::proto::TokenCreateTransactionBody* SchedulableTransactionBody::release_tokencreation() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.tokenCreation)
  if (_internal_has_tokencreation()) {
    clear_has_data();
    ::proto::TokenCreateTransactionBody* temp = _impl_.data_.tokencreation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokencreation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenCreateTransactionBody& SchedulableTransactionBody::_internal_tokencreation() const {
  return _internal_has_tokencreation()
      ? *_impl_.data_.tokencreation_
      : reinterpret_cast< ::proto::TokenCreateTransactionBody&>(::proto::_TokenCreateTransactionBody_default_instance_);
}
inline const ::proto::TokenCreateTransactionBody& SchedulableTransactionBody::tokencreation() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.tokenCreation)
  return _internal_tokencreation();
}
inline ::proto::TokenCreateTransactionBody* SchedulableTransactionBody::unsafe_arena_release_tokencreation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.tokenCreation)
  if (_internal_has_tokencreation()) {
    clear_has_data();
    ::proto::TokenCreateTransactionBody* temp = _impl_.data_.tokencreation_;
    _impl_.data_.tokencreation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_tokencreation(::proto::TokenCreateTransactionBody* tokencreation) {
  clear_data();
  if (tokencreation) {
    set_has_tokencreation();
    _impl_.data_.tokencreation_ = tokencreation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.tokenCreation)
}
inline ::proto::TokenCreateTransactionBody* SchedulableTransactionBody::_internal_mutable_tokencreation() {
  if (!_internal_has_tokencreation()) {
    clear_data();
    set_has_tokencreation();
    _impl_.data_.tokencreation_ = CreateMaybeMessage< ::proto::TokenCreateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokencreation_;
}
inline ::proto::TokenCreateTransactionBody* SchedulableTransactionBody::mutable_tokencreation() {
  ::proto::TokenCreateTransactionBody* _msg = _internal_mutable_tokencreation();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.tokenCreation)
  return _msg;
}

// .proto.TokenFreezeAccountTransactionBody tokenFreeze = 23;
inline bool SchedulableTransactionBody::_internal_has_tokenfreeze() const {
  return data_case() == kTokenFreeze;
}
inline bool SchedulableTransactionBody::has_tokenfreeze() const {
  return _internal_has_tokenfreeze();
}
inline void SchedulableTransactionBody::set_has_tokenfreeze() {
  _impl_._oneof_case_[0] = kTokenFreeze;
}
inline ::proto::TokenFreezeAccountTransactionBody* SchedulableTransactionBody::release_tokenfreeze() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.tokenFreeze)
  if (_internal_has_tokenfreeze()) {
    clear_has_data();
    ::proto::TokenFreezeAccountTransactionBody* temp = _impl_.data_.tokenfreeze_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokenfreeze_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenFreezeAccountTransactionBody& SchedulableTransactionBody::_internal_tokenfreeze() const {
  return _internal_has_tokenfreeze()
      ? *_impl_.data_.tokenfreeze_
      : reinterpret_cast< ::proto::TokenFreezeAccountTransactionBody&>(::proto::_TokenFreezeAccountTransactionBody_default_instance_);
}
inline const ::proto::TokenFreezeAccountTransactionBody& SchedulableTransactionBody::tokenfreeze() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.tokenFreeze)
  return _internal_tokenfreeze();
}
inline ::proto::TokenFreezeAccountTransactionBody* SchedulableTransactionBody::unsafe_arena_release_tokenfreeze() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.tokenFreeze)
  if (_internal_has_tokenfreeze()) {
    clear_has_data();
    ::proto::TokenFreezeAccountTransactionBody* temp = _impl_.data_.tokenfreeze_;
    _impl_.data_.tokenfreeze_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_tokenfreeze(::proto::TokenFreezeAccountTransactionBody* tokenfreeze) {
  clear_data();
  if (tokenfreeze) {
    set_has_tokenfreeze();
    _impl_.data_.tokenfreeze_ = tokenfreeze;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.tokenFreeze)
}
inline ::proto::TokenFreezeAccountTransactionBody* SchedulableTransactionBody::_internal_mutable_tokenfreeze() {
  if (!_internal_has_tokenfreeze()) {
    clear_data();
    set_has_tokenfreeze();
    _impl_.data_.tokenfreeze_ = CreateMaybeMessage< ::proto::TokenFreezeAccountTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokenfreeze_;
}
inline ::proto::TokenFreezeAccountTransactionBody* SchedulableTransactionBody::mutable_tokenfreeze() {
  ::proto::TokenFreezeAccountTransactionBody* _msg = _internal_mutable_tokenfreeze();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.tokenFreeze)
  return _msg;
}

// .proto.TokenUnfreezeAccountTransactionBody tokenUnfreeze = 24;
inline bool SchedulableTransactionBody::_internal_has_tokenunfreeze() const {
  return data_case() == kTokenUnfreeze;
}
inline bool SchedulableTransactionBody::has_tokenunfreeze() const {
  return _internal_has_tokenunfreeze();
}
inline void SchedulableTransactionBody::set_has_tokenunfreeze() {
  _impl_._oneof_case_[0] = kTokenUnfreeze;
}
inline ::proto::TokenUnfreezeAccountTransactionBody* SchedulableTransactionBody::release_tokenunfreeze() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.tokenUnfreeze)
  if (_internal_has_tokenunfreeze()) {
    clear_has_data();
    ::proto::TokenUnfreezeAccountTransactionBody* temp = _impl_.data_.tokenunfreeze_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokenunfreeze_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenUnfreezeAccountTransactionBody& SchedulableTransactionBody::_internal_tokenunfreeze() const {
  return _internal_has_tokenunfreeze()
      ? *_impl_.data_.tokenunfreeze_
      : reinterpret_cast< ::proto::TokenUnfreezeAccountTransactionBody&>(::proto::_TokenUnfreezeAccountTransactionBody_default_instance_);
}
inline const ::proto::TokenUnfreezeAccountTransactionBody& SchedulableTransactionBody::tokenunfreeze() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.tokenUnfreeze)
  return _internal_tokenunfreeze();
}
inline ::proto::TokenUnfreezeAccountTransactionBody* SchedulableTransactionBody::unsafe_arena_release_tokenunfreeze() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.tokenUnfreeze)
  if (_internal_has_tokenunfreeze()) {
    clear_has_data();
    ::proto::TokenUnfreezeAccountTransactionBody* temp = _impl_.data_.tokenunfreeze_;
    _impl_.data_.tokenunfreeze_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_tokenunfreeze(::proto::TokenUnfreezeAccountTransactionBody* tokenunfreeze) {
  clear_data();
  if (tokenunfreeze) {
    set_has_tokenunfreeze();
    _impl_.data_.tokenunfreeze_ = tokenunfreeze;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.tokenUnfreeze)
}
inline ::proto::TokenUnfreezeAccountTransactionBody* SchedulableTransactionBody::_internal_mutable_tokenunfreeze() {
  if (!_internal_has_tokenunfreeze()) {
    clear_data();
    set_has_tokenunfreeze();
    _impl_.data_.tokenunfreeze_ = CreateMaybeMessage< ::proto::TokenUnfreezeAccountTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokenunfreeze_;
}
inline ::proto::TokenUnfreezeAccountTransactionBody* SchedulableTransactionBody::mutable_tokenunfreeze() {
  ::proto::TokenUnfreezeAccountTransactionBody* _msg = _internal_mutable_tokenunfreeze();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.tokenUnfreeze)
  return _msg;
}

// .proto.TokenGrantKycTransactionBody tokenGrantKyc = 25;
inline bool SchedulableTransactionBody::_internal_has_tokengrantkyc() const {
  return data_case() == kTokenGrantKyc;
}
inline bool SchedulableTransactionBody::has_tokengrantkyc() const {
  return _internal_has_tokengrantkyc();
}
inline void SchedulableTransactionBody::set_has_tokengrantkyc() {
  _impl_._oneof_case_[0] = kTokenGrantKyc;
}
inline ::proto::TokenGrantKycTransactionBody* SchedulableTransactionBody::release_tokengrantkyc() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.tokenGrantKyc)
  if (_internal_has_tokengrantkyc()) {
    clear_has_data();
    ::proto::TokenGrantKycTransactionBody* temp = _impl_.data_.tokengrantkyc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokengrantkyc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenGrantKycTransactionBody& SchedulableTransactionBody::_internal_tokengrantkyc() const {
  return _internal_has_tokengrantkyc()
      ? *_impl_.data_.tokengrantkyc_
      : reinterpret_cast< ::proto::TokenGrantKycTransactionBody&>(::proto::_TokenGrantKycTransactionBody_default_instance_);
}
inline const ::proto::TokenGrantKycTransactionBody& SchedulableTransactionBody::tokengrantkyc() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.tokenGrantKyc)
  return _internal_tokengrantkyc();
}
inline ::proto::TokenGrantKycTransactionBody* SchedulableTransactionBody::unsafe_arena_release_tokengrantkyc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.tokenGrantKyc)
  if (_internal_has_tokengrantkyc()) {
    clear_has_data();
    ::proto::TokenGrantKycTransactionBody* temp = _impl_.data_.tokengrantkyc_;
    _impl_.data_.tokengrantkyc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_tokengrantkyc(::proto::TokenGrantKycTransactionBody* tokengrantkyc) {
  clear_data();
  if (tokengrantkyc) {
    set_has_tokengrantkyc();
    _impl_.data_.tokengrantkyc_ = tokengrantkyc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.tokenGrantKyc)
}
inline ::proto::TokenGrantKycTransactionBody* SchedulableTransactionBody::_internal_mutable_tokengrantkyc() {
  if (!_internal_has_tokengrantkyc()) {
    clear_data();
    set_has_tokengrantkyc();
    _impl_.data_.tokengrantkyc_ = CreateMaybeMessage< ::proto::TokenGrantKycTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokengrantkyc_;
}
inline ::proto::TokenGrantKycTransactionBody* SchedulableTransactionBody::mutable_tokengrantkyc() {
  ::proto::TokenGrantKycTransactionBody* _msg = _internal_mutable_tokengrantkyc();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.tokenGrantKyc)
  return _msg;
}

// .proto.TokenRevokeKycTransactionBody tokenRevokeKyc = 26;
inline bool SchedulableTransactionBody::_internal_has_tokenrevokekyc() const {
  return data_case() == kTokenRevokeKyc;
}
inline bool SchedulableTransactionBody::has_tokenrevokekyc() const {
  return _internal_has_tokenrevokekyc();
}
inline void SchedulableTransactionBody::set_has_tokenrevokekyc() {
  _impl_._oneof_case_[0] = kTokenRevokeKyc;
}
inline ::proto::TokenRevokeKycTransactionBody* SchedulableTransactionBody::release_tokenrevokekyc() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.tokenRevokeKyc)
  if (_internal_has_tokenrevokekyc()) {
    clear_has_data();
    ::proto::TokenRevokeKycTransactionBody* temp = _impl_.data_.tokenrevokekyc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokenrevokekyc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenRevokeKycTransactionBody& SchedulableTransactionBody::_internal_tokenrevokekyc() const {
  return _internal_has_tokenrevokekyc()
      ? *_impl_.data_.tokenrevokekyc_
      : reinterpret_cast< ::proto::TokenRevokeKycTransactionBody&>(::proto::_TokenRevokeKycTransactionBody_default_instance_);
}
inline const ::proto::TokenRevokeKycTransactionBody& SchedulableTransactionBody::tokenrevokekyc() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.tokenRevokeKyc)
  return _internal_tokenrevokekyc();
}
inline ::proto::TokenRevokeKycTransactionBody* SchedulableTransactionBody::unsafe_arena_release_tokenrevokekyc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.tokenRevokeKyc)
  if (_internal_has_tokenrevokekyc()) {
    clear_has_data();
    ::proto::TokenRevokeKycTransactionBody* temp = _impl_.data_.tokenrevokekyc_;
    _impl_.data_.tokenrevokekyc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_tokenrevokekyc(::proto::TokenRevokeKycTransactionBody* tokenrevokekyc) {
  clear_data();
  if (tokenrevokekyc) {
    set_has_tokenrevokekyc();
    _impl_.data_.tokenrevokekyc_ = tokenrevokekyc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.tokenRevokeKyc)
}
inline ::proto::TokenRevokeKycTransactionBody* SchedulableTransactionBody::_internal_mutable_tokenrevokekyc() {
  if (!_internal_has_tokenrevokekyc()) {
    clear_data();
    set_has_tokenrevokekyc();
    _impl_.data_.tokenrevokekyc_ = CreateMaybeMessage< ::proto::TokenRevokeKycTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokenrevokekyc_;
}
inline ::proto::TokenRevokeKycTransactionBody* SchedulableTransactionBody::mutable_tokenrevokekyc() {
  ::proto::TokenRevokeKycTransactionBody* _msg = _internal_mutable_tokenrevokekyc();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.tokenRevokeKyc)
  return _msg;
}

// .proto.TokenDeleteTransactionBody tokenDeletion = 27;
inline bool SchedulableTransactionBody::_internal_has_tokendeletion() const {
  return data_case() == kTokenDeletion;
}
inline bool SchedulableTransactionBody::has_tokendeletion() const {
  return _internal_has_tokendeletion();
}
inline void SchedulableTransactionBody::set_has_tokendeletion() {
  _impl_._oneof_case_[0] = kTokenDeletion;
}
inline ::proto::TokenDeleteTransactionBody* SchedulableTransactionBody::release_tokendeletion() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.tokenDeletion)
  if (_internal_has_tokendeletion()) {
    clear_has_data();
    ::proto::TokenDeleteTransactionBody* temp = _impl_.data_.tokendeletion_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokendeletion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenDeleteTransactionBody& SchedulableTransactionBody::_internal_tokendeletion() const {
  return _internal_has_tokendeletion()
      ? *_impl_.data_.tokendeletion_
      : reinterpret_cast< ::proto::TokenDeleteTransactionBody&>(::proto::_TokenDeleteTransactionBody_default_instance_);
}
inline const ::proto::TokenDeleteTransactionBody& SchedulableTransactionBody::tokendeletion() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.tokenDeletion)
  return _internal_tokendeletion();
}
inline ::proto::TokenDeleteTransactionBody* SchedulableTransactionBody::unsafe_arena_release_tokendeletion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.tokenDeletion)
  if (_internal_has_tokendeletion()) {
    clear_has_data();
    ::proto::TokenDeleteTransactionBody* temp = _impl_.data_.tokendeletion_;
    _impl_.data_.tokendeletion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_tokendeletion(::proto::TokenDeleteTransactionBody* tokendeletion) {
  clear_data();
  if (tokendeletion) {
    set_has_tokendeletion();
    _impl_.data_.tokendeletion_ = tokendeletion;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.tokenDeletion)
}
inline ::proto::TokenDeleteTransactionBody* SchedulableTransactionBody::_internal_mutable_tokendeletion() {
  if (!_internal_has_tokendeletion()) {
    clear_data();
    set_has_tokendeletion();
    _impl_.data_.tokendeletion_ = CreateMaybeMessage< ::proto::TokenDeleteTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokendeletion_;
}
inline ::proto::TokenDeleteTransactionBody* SchedulableTransactionBody::mutable_tokendeletion() {
  ::proto::TokenDeleteTransactionBody* _msg = _internal_mutable_tokendeletion();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.tokenDeletion)
  return _msg;
}

// .proto.TokenUpdateTransactionBody tokenUpdate = 28;
inline bool SchedulableTransactionBody::_internal_has_tokenupdate() const {
  return data_case() == kTokenUpdate;
}
inline bool SchedulableTransactionBody::has_tokenupdate() const {
  return _internal_has_tokenupdate();
}
inline void SchedulableTransactionBody::set_has_tokenupdate() {
  _impl_._oneof_case_[0] = kTokenUpdate;
}
inline ::proto::TokenUpdateTransactionBody* SchedulableTransactionBody::release_tokenupdate() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.tokenUpdate)
  if (_internal_has_tokenupdate()) {
    clear_has_data();
    ::proto::TokenUpdateTransactionBody* temp = _impl_.data_.tokenupdate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokenupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenUpdateTransactionBody& SchedulableTransactionBody::_internal_tokenupdate() const {
  return _internal_has_tokenupdate()
      ? *_impl_.data_.tokenupdate_
      : reinterpret_cast< ::proto::TokenUpdateTransactionBody&>(::proto::_TokenUpdateTransactionBody_default_instance_);
}
inline const ::proto::TokenUpdateTransactionBody& SchedulableTransactionBody::tokenupdate() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.tokenUpdate)
  return _internal_tokenupdate();
}
inline ::proto::TokenUpdateTransactionBody* SchedulableTransactionBody::unsafe_arena_release_tokenupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.tokenUpdate)
  if (_internal_has_tokenupdate()) {
    clear_has_data();
    ::proto::TokenUpdateTransactionBody* temp = _impl_.data_.tokenupdate_;
    _impl_.data_.tokenupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_tokenupdate(::proto::TokenUpdateTransactionBody* tokenupdate) {
  clear_data();
  if (tokenupdate) {
    set_has_tokenupdate();
    _impl_.data_.tokenupdate_ = tokenupdate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.tokenUpdate)
}
inline ::proto::TokenUpdateTransactionBody* SchedulableTransactionBody::_internal_mutable_tokenupdate() {
  if (!_internal_has_tokenupdate()) {
    clear_data();
    set_has_tokenupdate();
    _impl_.data_.tokenupdate_ = CreateMaybeMessage< ::proto::TokenUpdateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokenupdate_;
}
inline ::proto::TokenUpdateTransactionBody* SchedulableTransactionBody::mutable_tokenupdate() {
  ::proto::TokenUpdateTransactionBody* _msg = _internal_mutable_tokenupdate();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.tokenUpdate)
  return _msg;
}

// .proto.TokenMintTransactionBody tokenMint = 29;
inline bool SchedulableTransactionBody::_internal_has_tokenmint() const {
  return data_case() == kTokenMint;
}
inline bool SchedulableTransactionBody::has_tokenmint() const {
  return _internal_has_tokenmint();
}
inline void SchedulableTransactionBody::set_has_tokenmint() {
  _impl_._oneof_case_[0] = kTokenMint;
}
inline ::proto::TokenMintTransactionBody* SchedulableTransactionBody::release_tokenmint() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.tokenMint)
  if (_internal_has_tokenmint()) {
    clear_has_data();
    ::proto::TokenMintTransactionBody* temp = _impl_.data_.tokenmint_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokenmint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenMintTransactionBody& SchedulableTransactionBody::_internal_tokenmint() const {
  return _internal_has_tokenmint()
      ? *_impl_.data_.tokenmint_
      : reinterpret_cast< ::proto::TokenMintTransactionBody&>(::proto::_TokenMintTransactionBody_default_instance_);
}
inline const ::proto::TokenMintTransactionBody& SchedulableTransactionBody::tokenmint() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.tokenMint)
  return _internal_tokenmint();
}
inline ::proto::TokenMintTransactionBody* SchedulableTransactionBody::unsafe_arena_release_tokenmint() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.tokenMint)
  if (_internal_has_tokenmint()) {
    clear_has_data();
    ::proto::TokenMintTransactionBody* temp = _impl_.data_.tokenmint_;
    _impl_.data_.tokenmint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_tokenmint(::proto::TokenMintTransactionBody* tokenmint) {
  clear_data();
  if (tokenmint) {
    set_has_tokenmint();
    _impl_.data_.tokenmint_ = tokenmint;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.tokenMint)
}
inline ::proto::TokenMintTransactionBody* SchedulableTransactionBody::_internal_mutable_tokenmint() {
  if (!_internal_has_tokenmint()) {
    clear_data();
    set_has_tokenmint();
    _impl_.data_.tokenmint_ = CreateMaybeMessage< ::proto::TokenMintTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokenmint_;
}
inline ::proto::TokenMintTransactionBody* SchedulableTransactionBody::mutable_tokenmint() {
  ::proto::TokenMintTransactionBody* _msg = _internal_mutable_tokenmint();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.tokenMint)
  return _msg;
}

// .proto.TokenBurnTransactionBody tokenBurn = 30;
inline bool SchedulableTransactionBody::_internal_has_tokenburn() const {
  return data_case() == kTokenBurn;
}
inline bool SchedulableTransactionBody::has_tokenburn() const {
  return _internal_has_tokenburn();
}
inline void SchedulableTransactionBody::set_has_tokenburn() {
  _impl_._oneof_case_[0] = kTokenBurn;
}
inline ::proto::TokenBurnTransactionBody* SchedulableTransactionBody::release_tokenburn() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.tokenBurn)
  if (_internal_has_tokenburn()) {
    clear_has_data();
    ::proto::TokenBurnTransactionBody* temp = _impl_.data_.tokenburn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokenburn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenBurnTransactionBody& SchedulableTransactionBody::_internal_tokenburn() const {
  return _internal_has_tokenburn()
      ? *_impl_.data_.tokenburn_
      : reinterpret_cast< ::proto::TokenBurnTransactionBody&>(::proto::_TokenBurnTransactionBody_default_instance_);
}
inline const ::proto::TokenBurnTransactionBody& SchedulableTransactionBody::tokenburn() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.tokenBurn)
  return _internal_tokenburn();
}
inline ::proto::TokenBurnTransactionBody* SchedulableTransactionBody::unsafe_arena_release_tokenburn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.tokenBurn)
  if (_internal_has_tokenburn()) {
    clear_has_data();
    ::proto::TokenBurnTransactionBody* temp = _impl_.data_.tokenburn_;
    _impl_.data_.tokenburn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_tokenburn(::proto::TokenBurnTransactionBody* tokenburn) {
  clear_data();
  if (tokenburn) {
    set_has_tokenburn();
    _impl_.data_.tokenburn_ = tokenburn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.tokenBurn)
}
inline ::proto::TokenBurnTransactionBody* SchedulableTransactionBody::_internal_mutable_tokenburn() {
  if (!_internal_has_tokenburn()) {
    clear_data();
    set_has_tokenburn();
    _impl_.data_.tokenburn_ = CreateMaybeMessage< ::proto::TokenBurnTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokenburn_;
}
inline ::proto::TokenBurnTransactionBody* SchedulableTransactionBody::mutable_tokenburn() {
  ::proto::TokenBurnTransactionBody* _msg = _internal_mutable_tokenburn();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.tokenBurn)
  return _msg;
}

// .proto.TokenWipeAccountTransactionBody tokenWipe = 31;
inline bool SchedulableTransactionBody::_internal_has_tokenwipe() const {
  return data_case() == kTokenWipe;
}
inline bool SchedulableTransactionBody::has_tokenwipe() const {
  return _internal_has_tokenwipe();
}
inline void SchedulableTransactionBody::set_has_tokenwipe() {
  _impl_._oneof_case_[0] = kTokenWipe;
}
inline ::proto::TokenWipeAccountTransactionBody* SchedulableTransactionBody::release_tokenwipe() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.tokenWipe)
  if (_internal_has_tokenwipe()) {
    clear_has_data();
    ::proto::TokenWipeAccountTransactionBody* temp = _impl_.data_.tokenwipe_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokenwipe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenWipeAccountTransactionBody& SchedulableTransactionBody::_internal_tokenwipe() const {
  return _internal_has_tokenwipe()
      ? *_impl_.data_.tokenwipe_
      : reinterpret_cast< ::proto::TokenWipeAccountTransactionBody&>(::proto::_TokenWipeAccountTransactionBody_default_instance_);
}
inline const ::proto::TokenWipeAccountTransactionBody& SchedulableTransactionBody::tokenwipe() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.tokenWipe)
  return _internal_tokenwipe();
}
inline ::proto::TokenWipeAccountTransactionBody* SchedulableTransactionBody::unsafe_arena_release_tokenwipe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.tokenWipe)
  if (_internal_has_tokenwipe()) {
    clear_has_data();
    ::proto::TokenWipeAccountTransactionBody* temp = _impl_.data_.tokenwipe_;
    _impl_.data_.tokenwipe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_tokenwipe(::proto::TokenWipeAccountTransactionBody* tokenwipe) {
  clear_data();
  if (tokenwipe) {
    set_has_tokenwipe();
    _impl_.data_.tokenwipe_ = tokenwipe;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.tokenWipe)
}
inline ::proto::TokenWipeAccountTransactionBody* SchedulableTransactionBody::_internal_mutable_tokenwipe() {
  if (!_internal_has_tokenwipe()) {
    clear_data();
    set_has_tokenwipe();
    _impl_.data_.tokenwipe_ = CreateMaybeMessage< ::proto::TokenWipeAccountTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokenwipe_;
}
inline ::proto::TokenWipeAccountTransactionBody* SchedulableTransactionBody::mutable_tokenwipe() {
  ::proto::TokenWipeAccountTransactionBody* _msg = _internal_mutable_tokenwipe();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.tokenWipe)
  return _msg;
}

// .proto.TokenAssociateTransactionBody tokenAssociate = 32;
inline bool SchedulableTransactionBody::_internal_has_tokenassociate() const {
  return data_case() == kTokenAssociate;
}
inline bool SchedulableTransactionBody::has_tokenassociate() const {
  return _internal_has_tokenassociate();
}
inline void SchedulableTransactionBody::set_has_tokenassociate() {
  _impl_._oneof_case_[0] = kTokenAssociate;
}
inline ::proto::TokenAssociateTransactionBody* SchedulableTransactionBody::release_tokenassociate() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.tokenAssociate)
  if (_internal_has_tokenassociate()) {
    clear_has_data();
    ::proto::TokenAssociateTransactionBody* temp = _impl_.data_.tokenassociate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokenassociate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenAssociateTransactionBody& SchedulableTransactionBody::_internal_tokenassociate() const {
  return _internal_has_tokenassociate()
      ? *_impl_.data_.tokenassociate_
      : reinterpret_cast< ::proto::TokenAssociateTransactionBody&>(::proto::_TokenAssociateTransactionBody_default_instance_);
}
inline const ::proto::TokenAssociateTransactionBody& SchedulableTransactionBody::tokenassociate() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.tokenAssociate)
  return _internal_tokenassociate();
}
inline ::proto::TokenAssociateTransactionBody* SchedulableTransactionBody::unsafe_arena_release_tokenassociate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.tokenAssociate)
  if (_internal_has_tokenassociate()) {
    clear_has_data();
    ::proto::TokenAssociateTransactionBody* temp = _impl_.data_.tokenassociate_;
    _impl_.data_.tokenassociate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_tokenassociate(::proto::TokenAssociateTransactionBody* tokenassociate) {
  clear_data();
  if (tokenassociate) {
    set_has_tokenassociate();
    _impl_.data_.tokenassociate_ = tokenassociate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.tokenAssociate)
}
inline ::proto::TokenAssociateTransactionBody* SchedulableTransactionBody::_internal_mutable_tokenassociate() {
  if (!_internal_has_tokenassociate()) {
    clear_data();
    set_has_tokenassociate();
    _impl_.data_.tokenassociate_ = CreateMaybeMessage< ::proto::TokenAssociateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokenassociate_;
}
inline ::proto::TokenAssociateTransactionBody* SchedulableTransactionBody::mutable_tokenassociate() {
  ::proto::TokenAssociateTransactionBody* _msg = _internal_mutable_tokenassociate();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.tokenAssociate)
  return _msg;
}

// .proto.TokenDissociateTransactionBody tokenDissociate = 33;
inline bool SchedulableTransactionBody::_internal_has_tokendissociate() const {
  return data_case() == kTokenDissociate;
}
inline bool SchedulableTransactionBody::has_tokendissociate() const {
  return _internal_has_tokendissociate();
}
inline void SchedulableTransactionBody::set_has_tokendissociate() {
  _impl_._oneof_case_[0] = kTokenDissociate;
}
inline ::proto::TokenDissociateTransactionBody* SchedulableTransactionBody::release_tokendissociate() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.tokenDissociate)
  if (_internal_has_tokendissociate()) {
    clear_has_data();
    ::proto::TokenDissociateTransactionBody* temp = _impl_.data_.tokendissociate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokendissociate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenDissociateTransactionBody& SchedulableTransactionBody::_internal_tokendissociate() const {
  return _internal_has_tokendissociate()
      ? *_impl_.data_.tokendissociate_
      : reinterpret_cast< ::proto::TokenDissociateTransactionBody&>(::proto::_TokenDissociateTransactionBody_default_instance_);
}
inline const ::proto::TokenDissociateTransactionBody& SchedulableTransactionBody::tokendissociate() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.tokenDissociate)
  return _internal_tokendissociate();
}
inline ::proto::TokenDissociateTransactionBody* SchedulableTransactionBody::unsafe_arena_release_tokendissociate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.tokenDissociate)
  if (_internal_has_tokendissociate()) {
    clear_has_data();
    ::proto::TokenDissociateTransactionBody* temp = _impl_.data_.tokendissociate_;
    _impl_.data_.tokendissociate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_tokendissociate(::proto::TokenDissociateTransactionBody* tokendissociate) {
  clear_data();
  if (tokendissociate) {
    set_has_tokendissociate();
    _impl_.data_.tokendissociate_ = tokendissociate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.tokenDissociate)
}
inline ::proto::TokenDissociateTransactionBody* SchedulableTransactionBody::_internal_mutable_tokendissociate() {
  if (!_internal_has_tokendissociate()) {
    clear_data();
    set_has_tokendissociate();
    _impl_.data_.tokendissociate_ = CreateMaybeMessage< ::proto::TokenDissociateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokendissociate_;
}
inline ::proto::TokenDissociateTransactionBody* SchedulableTransactionBody::mutable_tokendissociate() {
  ::proto::TokenDissociateTransactionBody* _msg = _internal_mutable_tokendissociate();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.tokenDissociate)
  return _msg;
}

// .proto.TokenFeeScheduleUpdateTransactionBody token_fee_schedule_update = 39;
inline bool SchedulableTransactionBody::_internal_has_token_fee_schedule_update() const {
  return data_case() == kTokenFeeScheduleUpdate;
}
inline bool SchedulableTransactionBody::has_token_fee_schedule_update() const {
  return _internal_has_token_fee_schedule_update();
}
inline void SchedulableTransactionBody::set_has_token_fee_schedule_update() {
  _impl_._oneof_case_[0] = kTokenFeeScheduleUpdate;
}
inline ::proto::TokenFeeScheduleUpdateTransactionBody* SchedulableTransactionBody::release_token_fee_schedule_update() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.token_fee_schedule_update)
  if (_internal_has_token_fee_schedule_update()) {
    clear_has_data();
    ::proto::TokenFeeScheduleUpdateTransactionBody* temp = _impl_.data_.token_fee_schedule_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.token_fee_schedule_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenFeeScheduleUpdateTransactionBody& SchedulableTransactionBody::_internal_token_fee_schedule_update() const {
  return _internal_has_token_fee_schedule_update()
      ? *_impl_.data_.token_fee_schedule_update_
      : reinterpret_cast< ::proto::TokenFeeScheduleUpdateTransactionBody&>(::proto::_TokenFeeScheduleUpdateTransactionBody_default_instance_);
}
inline const ::proto::TokenFeeScheduleUpdateTransactionBody& SchedulableTransactionBody::token_fee_schedule_update() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.token_fee_schedule_update)
  return _internal_token_fee_schedule_update();
}
inline ::proto::TokenFeeScheduleUpdateTransactionBody* SchedulableTransactionBody::unsafe_arena_release_token_fee_schedule_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.token_fee_schedule_update)
  if (_internal_has_token_fee_schedule_update()) {
    clear_has_data();
    ::proto::TokenFeeScheduleUpdateTransactionBody* temp = _impl_.data_.token_fee_schedule_update_;
    _impl_.data_.token_fee_schedule_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_token_fee_schedule_update(::proto::TokenFeeScheduleUpdateTransactionBody* token_fee_schedule_update) {
  clear_data();
  if (token_fee_schedule_update) {
    set_has_token_fee_schedule_update();
    _impl_.data_.token_fee_schedule_update_ = token_fee_schedule_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.token_fee_schedule_update)
}
inline ::proto::TokenFeeScheduleUpdateTransactionBody* SchedulableTransactionBody::_internal_mutable_token_fee_schedule_update() {
  if (!_internal_has_token_fee_schedule_update()) {
    clear_data();
    set_has_token_fee_schedule_update();
    _impl_.data_.token_fee_schedule_update_ = CreateMaybeMessage< ::proto::TokenFeeScheduleUpdateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.token_fee_schedule_update_;
}
inline ::proto::TokenFeeScheduleUpdateTransactionBody* SchedulableTransactionBody::mutable_token_fee_schedule_update() {
  ::proto::TokenFeeScheduleUpdateTransactionBody* _msg = _internal_mutable_token_fee_schedule_update();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.token_fee_schedule_update)
  return _msg;
}

// .proto.TokenPauseTransactionBody token_pause = 35;
inline bool SchedulableTransactionBody::_internal_has_token_pause() const {
  return data_case() == kTokenPause;
}
inline bool SchedulableTransactionBody::has_token_pause() const {
  return _internal_has_token_pause();
}
inline void SchedulableTransactionBody::set_has_token_pause() {
  _impl_._oneof_case_[0] = kTokenPause;
}
inline ::proto::TokenPauseTransactionBody* SchedulableTransactionBody::release_token_pause() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.token_pause)
  if (_internal_has_token_pause()) {
    clear_has_data();
    ::proto::TokenPauseTransactionBody* temp = _impl_.data_.token_pause_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.token_pause_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenPauseTransactionBody& SchedulableTransactionBody::_internal_token_pause() const {
  return _internal_has_token_pause()
      ? *_impl_.data_.token_pause_
      : reinterpret_cast< ::proto::TokenPauseTransactionBody&>(::proto::_TokenPauseTransactionBody_default_instance_);
}
inline const ::proto::TokenPauseTransactionBody& SchedulableTransactionBody::token_pause() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.token_pause)
  return _internal_token_pause();
}
inline ::proto::TokenPauseTransactionBody* SchedulableTransactionBody::unsafe_arena_release_token_pause() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.token_pause)
  if (_internal_has_token_pause()) {
    clear_has_data();
    ::proto::TokenPauseTransactionBody* temp = _impl_.data_.token_pause_;
    _impl_.data_.token_pause_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_token_pause(::proto::TokenPauseTransactionBody* token_pause) {
  clear_data();
  if (token_pause) {
    set_has_token_pause();
    _impl_.data_.token_pause_ = token_pause;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.token_pause)
}
inline ::proto::TokenPauseTransactionBody* SchedulableTransactionBody::_internal_mutable_token_pause() {
  if (!_internal_has_token_pause()) {
    clear_data();
    set_has_token_pause();
    _impl_.data_.token_pause_ = CreateMaybeMessage< ::proto::TokenPauseTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.token_pause_;
}
inline ::proto::TokenPauseTransactionBody* SchedulableTransactionBody::mutable_token_pause() {
  ::proto::TokenPauseTransactionBody* _msg = _internal_mutable_token_pause();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.token_pause)
  return _msg;
}

// .proto.TokenUnpauseTransactionBody token_unpause = 36;
inline bool SchedulableTransactionBody::_internal_has_token_unpause() const {
  return data_case() == kTokenUnpause;
}
inline bool SchedulableTransactionBody::has_token_unpause() const {
  return _internal_has_token_unpause();
}
inline void SchedulableTransactionBody::set_has_token_unpause() {
  _impl_._oneof_case_[0] = kTokenUnpause;
}
inline ::proto::TokenUnpauseTransactionBody* SchedulableTransactionBody::release_token_unpause() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.token_unpause)
  if (_internal_has_token_unpause()) {
    clear_has_data();
    ::proto::TokenUnpauseTransactionBody* temp = _impl_.data_.token_unpause_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.token_unpause_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenUnpauseTransactionBody& SchedulableTransactionBody::_internal_token_unpause() const {
  return _internal_has_token_unpause()
      ? *_impl_.data_.token_unpause_
      : reinterpret_cast< ::proto::TokenUnpauseTransactionBody&>(::proto::_TokenUnpauseTransactionBody_default_instance_);
}
inline const ::proto::TokenUnpauseTransactionBody& SchedulableTransactionBody::token_unpause() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.token_unpause)
  return _internal_token_unpause();
}
inline ::proto::TokenUnpauseTransactionBody* SchedulableTransactionBody::unsafe_arena_release_token_unpause() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.token_unpause)
  if (_internal_has_token_unpause()) {
    clear_has_data();
    ::proto::TokenUnpauseTransactionBody* temp = _impl_.data_.token_unpause_;
    _impl_.data_.token_unpause_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_token_unpause(::proto::TokenUnpauseTransactionBody* token_unpause) {
  clear_data();
  if (token_unpause) {
    set_has_token_unpause();
    _impl_.data_.token_unpause_ = token_unpause;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.token_unpause)
}
inline ::proto::TokenUnpauseTransactionBody* SchedulableTransactionBody::_internal_mutable_token_unpause() {
  if (!_internal_has_token_unpause()) {
    clear_data();
    set_has_token_unpause();
    _impl_.data_.token_unpause_ = CreateMaybeMessage< ::proto::TokenUnpauseTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.token_unpause_;
}
inline ::proto::TokenUnpauseTransactionBody* SchedulableTransactionBody::mutable_token_unpause() {
  ::proto::TokenUnpauseTransactionBody* _msg = _internal_mutable_token_unpause();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.token_unpause)
  return _msg;
}

// .proto.ScheduleDeleteTransactionBody scheduleDelete = 34;
inline bool SchedulableTransactionBody::_internal_has_scheduledelete() const {
  return data_case() == kScheduleDelete;
}
inline bool SchedulableTransactionBody::has_scheduledelete() const {
  return _internal_has_scheduledelete();
}
inline void SchedulableTransactionBody::set_has_scheduledelete() {
  _impl_._oneof_case_[0] = kScheduleDelete;
}
inline ::proto::ScheduleDeleteTransactionBody* SchedulableTransactionBody::release_scheduledelete() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.scheduleDelete)
  if (_internal_has_scheduledelete()) {
    clear_has_data();
    ::proto::ScheduleDeleteTransactionBody* temp = _impl_.data_.scheduledelete_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.scheduledelete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ScheduleDeleteTransactionBody& SchedulableTransactionBody::_internal_scheduledelete() const {
  return _internal_has_scheduledelete()
      ? *_impl_.data_.scheduledelete_
      : reinterpret_cast< ::proto::ScheduleDeleteTransactionBody&>(::proto::_ScheduleDeleteTransactionBody_default_instance_);
}
inline const ::proto::ScheduleDeleteTransactionBody& SchedulableTransactionBody::scheduledelete() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.scheduleDelete)
  return _internal_scheduledelete();
}
inline ::proto::ScheduleDeleteTransactionBody* SchedulableTransactionBody::unsafe_arena_release_scheduledelete() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.scheduleDelete)
  if (_internal_has_scheduledelete()) {
    clear_has_data();
    ::proto::ScheduleDeleteTransactionBody* temp = _impl_.data_.scheduledelete_;
    _impl_.data_.scheduledelete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_scheduledelete(::proto::ScheduleDeleteTransactionBody* scheduledelete) {
  clear_data();
  if (scheduledelete) {
    set_has_scheduledelete();
    _impl_.data_.scheduledelete_ = scheduledelete;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.scheduleDelete)
}
inline ::proto::ScheduleDeleteTransactionBody* SchedulableTransactionBody::_internal_mutable_scheduledelete() {
  if (!_internal_has_scheduledelete()) {
    clear_data();
    set_has_scheduledelete();
    _impl_.data_.scheduledelete_ = CreateMaybeMessage< ::proto::ScheduleDeleteTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.scheduledelete_;
}
inline ::proto::ScheduleDeleteTransactionBody* SchedulableTransactionBody::mutable_scheduledelete() {
  ::proto::ScheduleDeleteTransactionBody* _msg = _internal_mutable_scheduledelete();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.scheduleDelete)
  return _msg;
}

// .proto.UtilPrngTransactionBody util_prng = 40;
inline bool SchedulableTransactionBody::_internal_has_util_prng() const {
  return data_case() == kUtilPrng;
}
inline bool SchedulableTransactionBody::has_util_prng() const {
  return _internal_has_util_prng();
}
inline void SchedulableTransactionBody::set_has_util_prng() {
  _impl_._oneof_case_[0] = kUtilPrng;
}
inline ::proto::UtilPrngTransactionBody* SchedulableTransactionBody::release_util_prng() {
  // @@protoc_insertion_point(field_release:proto.SchedulableTransactionBody.util_prng)
  if (_internal_has_util_prng()) {
    clear_has_data();
    ::proto::UtilPrngTransactionBody* temp = _impl_.data_.util_prng_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.util_prng_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::UtilPrngTransactionBody& SchedulableTransactionBody::_internal_util_prng() const {
  return _internal_has_util_prng()
      ? *_impl_.data_.util_prng_
      : reinterpret_cast< ::proto::UtilPrngTransactionBody&>(::proto::_UtilPrngTransactionBody_default_instance_);
}
inline const ::proto::UtilPrngTransactionBody& SchedulableTransactionBody::util_prng() const {
  // @@protoc_insertion_point(field_get:proto.SchedulableTransactionBody.util_prng)
  return _internal_util_prng();
}
inline ::proto::UtilPrngTransactionBody* SchedulableTransactionBody::unsafe_arena_release_util_prng() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.SchedulableTransactionBody.util_prng)
  if (_internal_has_util_prng()) {
    clear_has_data();
    ::proto::UtilPrngTransactionBody* temp = _impl_.data_.util_prng_;
    _impl_.data_.util_prng_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulableTransactionBody::unsafe_arena_set_allocated_util_prng(::proto::UtilPrngTransactionBody* util_prng) {
  clear_data();
  if (util_prng) {
    set_has_util_prng();
    _impl_.data_.util_prng_ = util_prng;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.SchedulableTransactionBody.util_prng)
}
inline ::proto::UtilPrngTransactionBody* SchedulableTransactionBody::_internal_mutable_util_prng() {
  if (!_internal_has_util_prng()) {
    clear_data();
    set_has_util_prng();
    _impl_.data_.util_prng_ = CreateMaybeMessage< ::proto::UtilPrngTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.util_prng_;
}
inline ::proto::UtilPrngTransactionBody* SchedulableTransactionBody::mutable_util_prng() {
  ::proto::UtilPrngTransactionBody* _msg = _internal_mutable_util_prng();
  // @@protoc_insertion_point(field_mutable:proto.SchedulableTransactionBody.util_prng)
  return _msg;
}

inline bool SchedulableTransactionBody::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void SchedulableTransactionBody::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline SchedulableTransactionBody::DataCase SchedulableTransactionBody::data_case() const {
  return SchedulableTransactionBody::DataCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_schedulable_5ftransaction_5fbody_2eproto
