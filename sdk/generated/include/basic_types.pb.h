// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: basic_types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_basic_5ftypes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_basic_5ftypes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "timestamp.pb.h"
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_basic_5ftypes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_basic_5ftypes_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_basic_5ftypes_2eproto;
namespace proto {
class AccountAmount;
struct AccountAmountDefaultTypeInternal;
extern AccountAmountDefaultTypeInternal _AccountAmount_default_instance_;
class AccountID;
struct AccountIDDefaultTypeInternal;
extern AccountIDDefaultTypeInternal _AccountID_default_instance_;
class ContractID;
struct ContractIDDefaultTypeInternal;
extern ContractIDDefaultTypeInternal _ContractID_default_instance_;
class CurrentAndNextFeeSchedule;
struct CurrentAndNextFeeScheduleDefaultTypeInternal;
extern CurrentAndNextFeeScheduleDefaultTypeInternal _CurrentAndNextFeeSchedule_default_instance_;
class FeeComponents;
struct FeeComponentsDefaultTypeInternal;
extern FeeComponentsDefaultTypeInternal _FeeComponents_default_instance_;
class FeeData;
struct FeeDataDefaultTypeInternal;
extern FeeDataDefaultTypeInternal _FeeData_default_instance_;
class FeeSchedule;
struct FeeScheduleDefaultTypeInternal;
extern FeeScheduleDefaultTypeInternal _FeeSchedule_default_instance_;
class FileID;
struct FileIDDefaultTypeInternal;
extern FileIDDefaultTypeInternal _FileID_default_instance_;
class Fraction;
struct FractionDefaultTypeInternal;
extern FractionDefaultTypeInternal _Fraction_default_instance_;
class Key;
struct KeyDefaultTypeInternal;
extern KeyDefaultTypeInternal _Key_default_instance_;
class KeyList;
struct KeyListDefaultTypeInternal;
extern KeyListDefaultTypeInternal _KeyList_default_instance_;
class NftTransfer;
struct NftTransferDefaultTypeInternal;
extern NftTransferDefaultTypeInternal _NftTransfer_default_instance_;
class NodeAddress;
struct NodeAddressDefaultTypeInternal;
extern NodeAddressDefaultTypeInternal _NodeAddress_default_instance_;
class NodeAddressBook;
struct NodeAddressBookDefaultTypeInternal;
extern NodeAddressBookDefaultTypeInternal _NodeAddressBook_default_instance_;
class RealmID;
struct RealmIDDefaultTypeInternal;
extern RealmIDDefaultTypeInternal _RealmID_default_instance_;
class ScheduleID;
struct ScheduleIDDefaultTypeInternal;
extern ScheduleIDDefaultTypeInternal _ScheduleID_default_instance_;
class SemanticVersion;
struct SemanticVersionDefaultTypeInternal;
extern SemanticVersionDefaultTypeInternal _SemanticVersion_default_instance_;
class ServiceEndpoint;
struct ServiceEndpointDefaultTypeInternal;
extern ServiceEndpointDefaultTypeInternal _ServiceEndpoint_default_instance_;
class ServicesConfigurationList;
struct ServicesConfigurationListDefaultTypeInternal;
extern ServicesConfigurationListDefaultTypeInternal _ServicesConfigurationList_default_instance_;
class Setting;
struct SettingDefaultTypeInternal;
extern SettingDefaultTypeInternal _Setting_default_instance_;
class ShardID;
struct ShardIDDefaultTypeInternal;
extern ShardIDDefaultTypeInternal _ShardID_default_instance_;
class Signature;
struct SignatureDefaultTypeInternal;
extern SignatureDefaultTypeInternal _Signature_default_instance_;
class SignatureList;
struct SignatureListDefaultTypeInternal;
extern SignatureListDefaultTypeInternal _SignatureList_default_instance_;
class SignatureMap;
struct SignatureMapDefaultTypeInternal;
extern SignatureMapDefaultTypeInternal _SignatureMap_default_instance_;
class SignaturePair;
struct SignaturePairDefaultTypeInternal;
extern SignaturePairDefaultTypeInternal _SignaturePair_default_instance_;
class StakingInfo;
struct StakingInfoDefaultTypeInternal;
extern StakingInfoDefaultTypeInternal _StakingInfo_default_instance_;
class ThresholdKey;
struct ThresholdKeyDefaultTypeInternal;
extern ThresholdKeyDefaultTypeInternal _ThresholdKey_default_instance_;
class ThresholdSignature;
struct ThresholdSignatureDefaultTypeInternal;
extern ThresholdSignatureDefaultTypeInternal _ThresholdSignature_default_instance_;
class TokenAssociation;
struct TokenAssociationDefaultTypeInternal;
extern TokenAssociationDefaultTypeInternal _TokenAssociation_default_instance_;
class TokenBalance;
struct TokenBalanceDefaultTypeInternal;
extern TokenBalanceDefaultTypeInternal _TokenBalance_default_instance_;
class TokenBalances;
struct TokenBalancesDefaultTypeInternal;
extern TokenBalancesDefaultTypeInternal _TokenBalances_default_instance_;
class TokenID;
struct TokenIDDefaultTypeInternal;
extern TokenIDDefaultTypeInternal _TokenID_default_instance_;
class TokenRelationship;
struct TokenRelationshipDefaultTypeInternal;
extern TokenRelationshipDefaultTypeInternal _TokenRelationship_default_instance_;
class TokenTransferList;
struct TokenTransferListDefaultTypeInternal;
extern TokenTransferListDefaultTypeInternal _TokenTransferList_default_instance_;
class TopicID;
struct TopicIDDefaultTypeInternal;
extern TopicIDDefaultTypeInternal _TopicID_default_instance_;
class TransactionFeeSchedule;
struct TransactionFeeScheduleDefaultTypeInternal;
extern TransactionFeeScheduleDefaultTypeInternal _TransactionFeeSchedule_default_instance_;
class TransactionID;
struct TransactionIDDefaultTypeInternal;
extern TransactionIDDefaultTypeInternal _TransactionID_default_instance_;
class TransferList;
struct TransferListDefaultTypeInternal;
extern TransferListDefaultTypeInternal _TransferList_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::AccountAmount* Arena::CreateMaybeMessage<::proto::AccountAmount>(Arena*);
template<> ::proto::AccountID* Arena::CreateMaybeMessage<::proto::AccountID>(Arena*);
template<> ::proto::ContractID* Arena::CreateMaybeMessage<::proto::ContractID>(Arena*);
template<> ::proto::CurrentAndNextFeeSchedule* Arena::CreateMaybeMessage<::proto::CurrentAndNextFeeSchedule>(Arena*);
template<> ::proto::FeeComponents* Arena::CreateMaybeMessage<::proto::FeeComponents>(Arena*);
template<> ::proto::FeeData* Arena::CreateMaybeMessage<::proto::FeeData>(Arena*);
template<> ::proto::FeeSchedule* Arena::CreateMaybeMessage<::proto::FeeSchedule>(Arena*);
template<> ::proto::FileID* Arena::CreateMaybeMessage<::proto::FileID>(Arena*);
template<> ::proto::Fraction* Arena::CreateMaybeMessage<::proto::Fraction>(Arena*);
template<> ::proto::Key* Arena::CreateMaybeMessage<::proto::Key>(Arena*);
template<> ::proto::KeyList* Arena::CreateMaybeMessage<::proto::KeyList>(Arena*);
template<> ::proto::NftTransfer* Arena::CreateMaybeMessage<::proto::NftTransfer>(Arena*);
template<> ::proto::NodeAddress* Arena::CreateMaybeMessage<::proto::NodeAddress>(Arena*);
template<> ::proto::NodeAddressBook* Arena::CreateMaybeMessage<::proto::NodeAddressBook>(Arena*);
template<> ::proto::RealmID* Arena::CreateMaybeMessage<::proto::RealmID>(Arena*);
template<> ::proto::ScheduleID* Arena::CreateMaybeMessage<::proto::ScheduleID>(Arena*);
template<> ::proto::SemanticVersion* Arena::CreateMaybeMessage<::proto::SemanticVersion>(Arena*);
template<> ::proto::ServiceEndpoint* Arena::CreateMaybeMessage<::proto::ServiceEndpoint>(Arena*);
template<> ::proto::ServicesConfigurationList* Arena::CreateMaybeMessage<::proto::ServicesConfigurationList>(Arena*);
template<> ::proto::Setting* Arena::CreateMaybeMessage<::proto::Setting>(Arena*);
template<> ::proto::ShardID* Arena::CreateMaybeMessage<::proto::ShardID>(Arena*);
template<> ::proto::Signature* Arena::CreateMaybeMessage<::proto::Signature>(Arena*);
template<> ::proto::SignatureList* Arena::CreateMaybeMessage<::proto::SignatureList>(Arena*);
template<> ::proto::SignatureMap* Arena::CreateMaybeMessage<::proto::SignatureMap>(Arena*);
template<> ::proto::SignaturePair* Arena::CreateMaybeMessage<::proto::SignaturePair>(Arena*);
template<> ::proto::StakingInfo* Arena::CreateMaybeMessage<::proto::StakingInfo>(Arena*);
template<> ::proto::ThresholdKey* Arena::CreateMaybeMessage<::proto::ThresholdKey>(Arena*);
template<> ::proto::ThresholdSignature* Arena::CreateMaybeMessage<::proto::ThresholdSignature>(Arena*);
template<> ::proto::TokenAssociation* Arena::CreateMaybeMessage<::proto::TokenAssociation>(Arena*);
template<> ::proto::TokenBalance* Arena::CreateMaybeMessage<::proto::TokenBalance>(Arena*);
template<> ::proto::TokenBalances* Arena::CreateMaybeMessage<::proto::TokenBalances>(Arena*);
template<> ::proto::TokenID* Arena::CreateMaybeMessage<::proto::TokenID>(Arena*);
template<> ::proto::TokenRelationship* Arena::CreateMaybeMessage<::proto::TokenRelationship>(Arena*);
template<> ::proto::TokenTransferList* Arena::CreateMaybeMessage<::proto::TokenTransferList>(Arena*);
template<> ::proto::TopicID* Arena::CreateMaybeMessage<::proto::TopicID>(Arena*);
template<> ::proto::TransactionFeeSchedule* Arena::CreateMaybeMessage<::proto::TransactionFeeSchedule>(Arena*);
template<> ::proto::TransactionID* Arena::CreateMaybeMessage<::proto::TransactionID>(Arena*);
template<> ::proto::TransferList* Arena::CreateMaybeMessage<::proto::TransferList>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

enum TokenType : int {
  FUNGIBLE_COMMON = 0,
  NON_FUNGIBLE_UNIQUE = 1,
  TokenType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TokenType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TokenType_IsValid(int value);
constexpr TokenType TokenType_MIN = FUNGIBLE_COMMON;
constexpr TokenType TokenType_MAX = NON_FUNGIBLE_UNIQUE;
constexpr int TokenType_ARRAYSIZE = TokenType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TokenType_descriptor();
template<typename T>
inline const std::string& TokenType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TokenType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TokenType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TokenType_descriptor(), enum_t_value);
}
inline bool TokenType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TokenType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TokenType>(
    TokenType_descriptor(), name, value);
}
enum SubType : int {
  DEFAULT = 0,
  TOKEN_FUNGIBLE_COMMON = 1,
  TOKEN_NON_FUNGIBLE_UNIQUE = 2,
  TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES = 3,
  TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES = 4,
  SCHEDULE_CREATE_CONTRACT_CALL = 5,
  SubType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SubType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SubType_IsValid(int value);
constexpr SubType SubType_MIN = DEFAULT;
constexpr SubType SubType_MAX = SCHEDULE_CREATE_CONTRACT_CALL;
constexpr int SubType_ARRAYSIZE = SubType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SubType_descriptor();
template<typename T>
inline const std::string& SubType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SubType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SubType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SubType_descriptor(), enum_t_value);
}
inline bool SubType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SubType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SubType>(
    SubType_descriptor(), name, value);
}
enum TokenSupplyType : int {
  INFINITE = 0,
  FINITE = 1,
  TokenSupplyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TokenSupplyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TokenSupplyType_IsValid(int value);
constexpr TokenSupplyType TokenSupplyType_MIN = INFINITE;
constexpr TokenSupplyType TokenSupplyType_MAX = FINITE;
constexpr int TokenSupplyType_ARRAYSIZE = TokenSupplyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TokenSupplyType_descriptor();
template<typename T>
inline const std::string& TokenSupplyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TokenSupplyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TokenSupplyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TokenSupplyType_descriptor(), enum_t_value);
}
inline bool TokenSupplyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TokenSupplyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TokenSupplyType>(
    TokenSupplyType_descriptor(), name, value);
}
enum TokenFreezeStatus : int {
  FreezeNotApplicable = 0,
  Frozen = 1,
  Unfrozen = 2,
  TokenFreezeStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TokenFreezeStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TokenFreezeStatus_IsValid(int value);
constexpr TokenFreezeStatus TokenFreezeStatus_MIN = FreezeNotApplicable;
constexpr TokenFreezeStatus TokenFreezeStatus_MAX = Unfrozen;
constexpr int TokenFreezeStatus_ARRAYSIZE = TokenFreezeStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TokenFreezeStatus_descriptor();
template<typename T>
inline const std::string& TokenFreezeStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TokenFreezeStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TokenFreezeStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TokenFreezeStatus_descriptor(), enum_t_value);
}
inline bool TokenFreezeStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TokenFreezeStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TokenFreezeStatus>(
    TokenFreezeStatus_descriptor(), name, value);
}
enum TokenKycStatus : int {
  KycNotApplicable = 0,
  Granted = 1,
  Revoked = 2,
  TokenKycStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TokenKycStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TokenKycStatus_IsValid(int value);
constexpr TokenKycStatus TokenKycStatus_MIN = KycNotApplicable;
constexpr TokenKycStatus TokenKycStatus_MAX = Revoked;
constexpr int TokenKycStatus_ARRAYSIZE = TokenKycStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TokenKycStatus_descriptor();
template<typename T>
inline const std::string& TokenKycStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TokenKycStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TokenKycStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TokenKycStatus_descriptor(), enum_t_value);
}
inline bool TokenKycStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TokenKycStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TokenKycStatus>(
    TokenKycStatus_descriptor(), name, value);
}
enum TokenPauseStatus : int {
  PauseNotApplicable = 0,
  Paused = 1,
  Unpaused = 2,
  TokenPauseStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TokenPauseStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TokenPauseStatus_IsValid(int value);
constexpr TokenPauseStatus TokenPauseStatus_MIN = PauseNotApplicable;
constexpr TokenPauseStatus TokenPauseStatus_MAX = Unpaused;
constexpr int TokenPauseStatus_ARRAYSIZE = TokenPauseStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TokenPauseStatus_descriptor();
template<typename T>
inline const std::string& TokenPauseStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TokenPauseStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TokenPauseStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TokenPauseStatus_descriptor(), enum_t_value);
}
inline bool TokenPauseStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TokenPauseStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TokenPauseStatus>(
    TokenPauseStatus_descriptor(), name, value);
}
enum HederaFunctionality : int {
  NONE = 0,
  CryptoTransfer = 1,
  CryptoUpdate = 2,
  CryptoDelete = 3,
  CryptoAddLiveHash = 4,
  CryptoDeleteLiveHash = 5,
  ContractCall = 6,
  ContractCreate = 7,
  ContractUpdate = 8,
  FileCreate = 9,
  FileAppend = 10,
  FileUpdate = 11,
  FileDelete = 12,
  CryptoGetAccountBalance = 13,
  CryptoGetAccountRecords = 14,
  CryptoGetInfo = 15,
  ContractCallLocal = 16,
  ContractGetInfo = 17,
  ContractGetBytecode = 18,
  GetBySolidityID = 19,
  GetByKey = 20,
  CryptoGetLiveHash = 21,
  CryptoGetStakers = 22,
  FileGetContents = 23,
  FileGetInfo = 24,
  TransactionGetRecord = 25,
  ContractGetRecords = 26,
  CryptoCreate = 27,
  SystemDelete = 28,
  SystemUndelete = 29,
  ContractDelete = 30,
  Freeze = 31,
  CreateTransactionRecord = 32,
  CryptoAccountAutoRenew = 33,
  ContractAutoRenew = 34,
  GetVersionInfo = 35,
  TransactionGetReceipt = 36,
  ConsensusCreateTopic = 50,
  ConsensusUpdateTopic = 51,
  ConsensusDeleteTopic = 52,
  ConsensusGetTopicInfo = 53,
  ConsensusSubmitMessage = 54,
  UncheckedSubmit = 55,
  TokenCreate = 56,
  TokenGetInfo = 58,
  TokenFreezeAccount = 59,
  TokenUnfreezeAccount = 60,
  TokenGrantKycToAccount = 61,
  TokenRevokeKycFromAccount = 62,
  TokenDelete = 63,
  TokenUpdate = 64,
  TokenMint = 65,
  TokenBurn = 66,
  TokenAccountWipe = 67,
  TokenAssociateToAccount = 68,
  TokenDissociateFromAccount = 69,
  ScheduleCreate = 70,
  ScheduleDelete = 71,
  ScheduleSign = 72,
  ScheduleGetInfo = 73,
  TokenGetAccountNftInfos = 74,
  TokenGetNftInfo = 75,
  TokenGetNftInfos = 76,
  TokenFeeScheduleUpdate = 77,
  NetworkGetExecutionTime = 78,
  TokenPause = 79,
  TokenUnpause = 80,
  CryptoApproveAllowance = 81,
  CryptoDeleteAllowance = 82,
  GetAccountDetails = 83,
  EthereumTransaction = 84,
  NodeStakeUpdate = 85,
  UtilPrng = 86,
  HederaFunctionality_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  HederaFunctionality_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool HederaFunctionality_IsValid(int value);
constexpr HederaFunctionality HederaFunctionality_MIN = NONE;
constexpr HederaFunctionality HederaFunctionality_MAX = UtilPrng;
constexpr int HederaFunctionality_ARRAYSIZE = HederaFunctionality_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HederaFunctionality_descriptor();
template<typename T>
inline const std::string& HederaFunctionality_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HederaFunctionality>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HederaFunctionality_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HederaFunctionality_descriptor(), enum_t_value);
}
inline bool HederaFunctionality_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HederaFunctionality* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HederaFunctionality>(
    HederaFunctionality_descriptor(), name, value);
}
// ===================================================================

class ShardID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ShardID) */ {
 public:
  inline ShardID() : ShardID(nullptr) {}
  ~ShardID() override;
  explicit PROTOBUF_CONSTEXPR ShardID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardID(const ShardID& from);
  ShardID(ShardID&& from) noexcept
    : ShardID() {
    *this = ::std::move(from);
  }

  inline ShardID& operator=(const ShardID& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardID& operator=(ShardID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardID& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardID* internal_default_instance() {
    return reinterpret_cast<const ShardID*>(
               &_ShardID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ShardID& a, ShardID& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShardID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShardID& from) {
    ShardID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShardID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ShardID";
  }
  protected:
  explicit ShardID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShardNumFieldNumber = 1,
  };
  // int64 shardNum = 1;
  void clear_shardnum();
  int64_t shardnum() const;
  void set_shardnum(int64_t value);
  private:
  int64_t _internal_shardnum() const;
  void _internal_set_shardnum(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ShardID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t shardnum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class RealmID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.RealmID) */ {
 public:
  inline RealmID() : RealmID(nullptr) {}
  ~RealmID() override;
  explicit PROTOBUF_CONSTEXPR RealmID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RealmID(const RealmID& from);
  RealmID(RealmID&& from) noexcept
    : RealmID() {
    *this = ::std::move(from);
  }

  inline RealmID& operator=(const RealmID& from) {
    CopyFrom(from);
    return *this;
  }
  inline RealmID& operator=(RealmID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RealmID& default_instance() {
    return *internal_default_instance();
  }
  static inline const RealmID* internal_default_instance() {
    return reinterpret_cast<const RealmID*>(
               &_RealmID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RealmID& a, RealmID& b) {
    a.Swap(&b);
  }
  inline void Swap(RealmID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RealmID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RealmID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RealmID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RealmID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RealmID& from) {
    RealmID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RealmID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RealmID";
  }
  protected:
  explicit RealmID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShardNumFieldNumber = 1,
    kRealmNumFieldNumber = 2,
  };
  // int64 shardNum = 1;
  void clear_shardnum();
  int64_t shardnum() const;
  void set_shardnum(int64_t value);
  private:
  int64_t _internal_shardnum() const;
  void _internal_set_shardnum(int64_t value);
  public:

  // int64 realmNum = 2;
  void clear_realmnum();
  int64_t realmnum() const;
  void set_realmnum(int64_t value);
  private:
  int64_t _internal_realmnum() const;
  void _internal_set_realmnum(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.RealmID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t shardnum_;
    int64_t realmnum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class AccountID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.AccountID) */ {
 public:
  inline AccountID() : AccountID(nullptr) {}
  ~AccountID() override;
  explicit PROTOBUF_CONSTEXPR AccountID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountID(const AccountID& from);
  AccountID(AccountID&& from) noexcept
    : AccountID() {
    *this = ::std::move(from);
  }

  inline AccountID& operator=(const AccountID& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountID& operator=(AccountID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountID& default_instance() {
    return *internal_default_instance();
  }
  enum AccountCase {
    kAccountNum = 3,
    kAlias = 4,
    ACCOUNT_NOT_SET = 0,
  };

  static inline const AccountID* internal_default_instance() {
    return reinterpret_cast<const AccountID*>(
               &_AccountID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AccountID& a, AccountID& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccountID& from) {
    AccountID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.AccountID";
  }
  protected:
  explicit AccountID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShardNumFieldNumber = 1,
    kRealmNumFieldNumber = 2,
    kAccountNumFieldNumber = 3,
    kAliasFieldNumber = 4,
  };
  // int64 shardNum = 1;
  void clear_shardnum();
  int64_t shardnum() const;
  void set_shardnum(int64_t value);
  private:
  int64_t _internal_shardnum() const;
  void _internal_set_shardnum(int64_t value);
  public:

  // int64 realmNum = 2;
  void clear_realmnum();
  int64_t realmnum() const;
  void set_realmnum(int64_t value);
  private:
  int64_t _internal_realmnum() const;
  void _internal_set_realmnum(int64_t value);
  public:

  // int64 accountNum = 3;
  bool has_accountnum() const;
  private:
  bool _internal_has_accountnum() const;
  public:
  void clear_accountnum();
  int64_t accountnum() const;
  void set_accountnum(int64_t value);
  private:
  int64_t _internal_accountnum() const;
  void _internal_set_accountnum(int64_t value);
  public:

  // bytes alias = 4;
  bool has_alias() const;
  private:
  bool _internal_has_alias() const;
  public:
  void clear_alias();
  const std::string& alias() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_alias(ArgT0&& arg0, ArgT... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* alias);
  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(const std::string& value);
  std::string* _internal_mutable_alias();
  public:

  void clear_account();
  AccountCase account_case() const;
  // @@protoc_insertion_point(class_scope:proto.AccountID)
 private:
  class _Internal;
  void set_has_accountnum();
  void set_has_alias();

  inline bool has_account() const;
  inline void clear_has_account();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t shardnum_;
    int64_t realmnum_;
    union AccountUnion {
      constexpr AccountUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int64_t accountnum_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alias_;
    } account_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class FileID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.FileID) */ {
 public:
  inline FileID() : FileID(nullptr) {}
  ~FileID() override;
  explicit PROTOBUF_CONSTEXPR FileID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileID(const FileID& from);
  FileID(FileID&& from) noexcept
    : FileID() {
    *this = ::std::move(from);
  }

  inline FileID& operator=(const FileID& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileID& operator=(FileID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileID& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileID* internal_default_instance() {
    return reinterpret_cast<const FileID*>(
               &_FileID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FileID& a, FileID& b) {
    a.Swap(&b);
  }
  inline void Swap(FileID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileID& from) {
    FileID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.FileID";
  }
  protected:
  explicit FileID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShardNumFieldNumber = 1,
    kRealmNumFieldNumber = 2,
    kFileNumFieldNumber = 3,
  };
  // int64 shardNum = 1;
  void clear_shardnum();
  int64_t shardnum() const;
  void set_shardnum(int64_t value);
  private:
  int64_t _internal_shardnum() const;
  void _internal_set_shardnum(int64_t value);
  public:

  // int64 realmNum = 2;
  void clear_realmnum();
  int64_t realmnum() const;
  void set_realmnum(int64_t value);
  private:
  int64_t _internal_realmnum() const;
  void _internal_set_realmnum(int64_t value);
  public:

  // int64 fileNum = 3;
  void clear_filenum();
  int64_t filenum() const;
  void set_filenum(int64_t value);
  private:
  int64_t _internal_filenum() const;
  void _internal_set_filenum(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.FileID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t shardnum_;
    int64_t realmnum_;
    int64_t filenum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class ContractID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ContractID) */ {
 public:
  inline ContractID() : ContractID(nullptr) {}
  ~ContractID() override;
  explicit PROTOBUF_CONSTEXPR ContractID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractID(const ContractID& from);
  ContractID(ContractID&& from) noexcept
    : ContractID() {
    *this = ::std::move(from);
  }

  inline ContractID& operator=(const ContractID& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractID& operator=(ContractID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractID& default_instance() {
    return *internal_default_instance();
  }
  enum ContractCase {
    kContractNum = 3,
    kEvmAddress = 4,
    CONTRACT_NOT_SET = 0,
  };

  static inline const ContractID* internal_default_instance() {
    return reinterpret_cast<const ContractID*>(
               &_ContractID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ContractID& a, ContractID& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContractID& from) {
    ContractID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ContractID";
  }
  protected:
  explicit ContractID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShardNumFieldNumber = 1,
    kRealmNumFieldNumber = 2,
    kContractNumFieldNumber = 3,
    kEvmAddressFieldNumber = 4,
  };
  // int64 shardNum = 1;
  void clear_shardnum();
  int64_t shardnum() const;
  void set_shardnum(int64_t value);
  private:
  int64_t _internal_shardnum() const;
  void _internal_set_shardnum(int64_t value);
  public:

  // int64 realmNum = 2;
  void clear_realmnum();
  int64_t realmnum() const;
  void set_realmnum(int64_t value);
  private:
  int64_t _internal_realmnum() const;
  void _internal_set_realmnum(int64_t value);
  public:

  // int64 contractNum = 3;
  bool has_contractnum() const;
  private:
  bool _internal_has_contractnum() const;
  public:
  void clear_contractnum();
  int64_t contractnum() const;
  void set_contractnum(int64_t value);
  private:
  int64_t _internal_contractnum() const;
  void _internal_set_contractnum(int64_t value);
  public:

  // bytes evm_address = 4;
  bool has_evm_address() const;
  private:
  bool _internal_has_evm_address() const;
  public:
  void clear_evm_address();
  const std::string& evm_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_evm_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_evm_address();
  PROTOBUF_NODISCARD std::string* release_evm_address();
  void set_allocated_evm_address(std::string* evm_address);
  private:
  const std::string& _internal_evm_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_evm_address(const std::string& value);
  std::string* _internal_mutable_evm_address();
  public:

  void clear_contract();
  ContractCase contract_case() const;
  // @@protoc_insertion_point(class_scope:proto.ContractID)
 private:
  class _Internal;
  void set_has_contractnum();
  void set_has_evm_address();

  inline bool has_contract() const;
  inline void clear_has_contract();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t shardnum_;
    int64_t realmnum_;
    union ContractUnion {
      constexpr ContractUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int64_t contractnum_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr evm_address_;
    } contract_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class TransactionID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.TransactionID) */ {
 public:
  inline TransactionID() : TransactionID(nullptr) {}
  ~TransactionID() override;
  explicit PROTOBUF_CONSTEXPR TransactionID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionID(const TransactionID& from);
  TransactionID(TransactionID&& from) noexcept
    : TransactionID() {
    *this = ::std::move(from);
  }

  inline TransactionID& operator=(const TransactionID& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionID& operator=(TransactionID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionID& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionID* internal_default_instance() {
    return reinterpret_cast<const TransactionID*>(
               &_TransactionID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TransactionID& a, TransactionID& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransactionID& from) {
    TransactionID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.TransactionID";
  }
  protected:
  explicit TransactionID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionValidStartFieldNumber = 1,
    kAccountIDFieldNumber = 2,
    kScheduledFieldNumber = 3,
    kNonceFieldNumber = 4,
  };
  // .proto.Timestamp transactionValidStart = 1;
  bool has_transactionvalidstart() const;
  private:
  bool _internal_has_transactionvalidstart() const;
  public:
  void clear_transactionvalidstart();
  const ::proto::Timestamp& transactionvalidstart() const;
  PROTOBUF_NODISCARD ::proto::Timestamp* release_transactionvalidstart();
  ::proto::Timestamp* mutable_transactionvalidstart();
  void set_allocated_transactionvalidstart(::proto::Timestamp* transactionvalidstart);
  private:
  const ::proto::Timestamp& _internal_transactionvalidstart() const;
  ::proto::Timestamp* _internal_mutable_transactionvalidstart();
  public:
  void unsafe_arena_set_allocated_transactionvalidstart(
      ::proto::Timestamp* transactionvalidstart);
  ::proto::Timestamp* unsafe_arena_release_transactionvalidstart();

  // .proto.AccountID accountID = 2;
  bool has_accountid() const;
  private:
  bool _internal_has_accountid() const;
  public:
  void clear_accountid();
  const ::proto::AccountID& accountid() const;
  PROTOBUF_NODISCARD ::proto::AccountID* release_accountid();
  ::proto::AccountID* mutable_accountid();
  void set_allocated_accountid(::proto::AccountID* accountid);
  private:
  const ::proto::AccountID& _internal_accountid() const;
  ::proto::AccountID* _internal_mutable_accountid();
  public:
  void unsafe_arena_set_allocated_accountid(
      ::proto::AccountID* accountid);
  ::proto::AccountID* unsafe_arena_release_accountid();

  // bool scheduled = 3;
  void clear_scheduled();
  bool scheduled() const;
  void set_scheduled(bool value);
  private:
  bool _internal_scheduled() const;
  void _internal_set_scheduled(bool value);
  public:

  // int32 nonce = 4;
  void clear_nonce();
  int32_t nonce() const;
  void set_nonce(int32_t value);
  private:
  int32_t _internal_nonce() const;
  void _internal_set_nonce(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.TransactionID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::Timestamp* transactionvalidstart_;
    ::proto::AccountID* accountid_;
    bool scheduled_;
    int32_t nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class AccountAmount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.AccountAmount) */ {
 public:
  inline AccountAmount() : AccountAmount(nullptr) {}
  ~AccountAmount() override;
  explicit PROTOBUF_CONSTEXPR AccountAmount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountAmount(const AccountAmount& from);
  AccountAmount(AccountAmount&& from) noexcept
    : AccountAmount() {
    *this = ::std::move(from);
  }

  inline AccountAmount& operator=(const AccountAmount& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountAmount& operator=(AccountAmount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountAmount& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountAmount* internal_default_instance() {
    return reinterpret_cast<const AccountAmount*>(
               &_AccountAmount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AccountAmount& a, AccountAmount& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountAmount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountAmount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountAmount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountAmount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountAmount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccountAmount& from) {
    AccountAmount::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountAmount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.AccountAmount";
  }
  protected:
  explicit AccountAmount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIDFieldNumber = 1,
    kAmountFieldNumber = 2,
    kIsApprovalFieldNumber = 3,
  };
  // .proto.AccountID accountID = 1;
  bool has_accountid() const;
  private:
  bool _internal_has_accountid() const;
  public:
  void clear_accountid();
  const ::proto::AccountID& accountid() const;
  PROTOBUF_NODISCARD ::proto::AccountID* release_accountid();
  ::proto::AccountID* mutable_accountid();
  void set_allocated_accountid(::proto::AccountID* accountid);
  private:
  const ::proto::AccountID& _internal_accountid() const;
  ::proto::AccountID* _internal_mutable_accountid();
  public:
  void unsafe_arena_set_allocated_accountid(
      ::proto::AccountID* accountid);
  ::proto::AccountID* unsafe_arena_release_accountid();

  // sint64 amount = 2;
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // bool is_approval = 3;
  void clear_is_approval();
  bool is_approval() const;
  void set_is_approval(bool value);
  private:
  bool _internal_is_approval() const;
  void _internal_set_is_approval(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.AccountAmount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::AccountID* accountid_;
    int64_t amount_;
    bool is_approval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class TransferList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.TransferList) */ {
 public:
  inline TransferList() : TransferList(nullptr) {}
  ~TransferList() override;
  explicit PROTOBUF_CONSTEXPR TransferList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferList(const TransferList& from);
  TransferList(TransferList&& from) noexcept
    : TransferList() {
    *this = ::std::move(from);
  }

  inline TransferList& operator=(const TransferList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferList& operator=(TransferList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferList* internal_default_instance() {
    return reinterpret_cast<const TransferList*>(
               &_TransferList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TransferList& a, TransferList& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransferList& from) {
    TransferList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.TransferList";
  }
  protected:
  explicit TransferList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountAmountsFieldNumber = 1,
  };
  // repeated .proto.AccountAmount accountAmounts = 1;
  int accountamounts_size() const;
  private:
  int _internal_accountamounts_size() const;
  public:
  void clear_accountamounts();
  ::proto::AccountAmount* mutable_accountamounts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::AccountAmount >*
      mutable_accountamounts();
  private:
  const ::proto::AccountAmount& _internal_accountamounts(int index) const;
  ::proto::AccountAmount* _internal_add_accountamounts();
  public:
  const ::proto::AccountAmount& accountamounts(int index) const;
  ::proto::AccountAmount* add_accountamounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::AccountAmount >&
      accountamounts() const;

  // @@protoc_insertion_point(class_scope:proto.TransferList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::AccountAmount > accountamounts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class NftTransfer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.NftTransfer) */ {
 public:
  inline NftTransfer() : NftTransfer(nullptr) {}
  ~NftTransfer() override;
  explicit PROTOBUF_CONSTEXPR NftTransfer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NftTransfer(const NftTransfer& from);
  NftTransfer(NftTransfer&& from) noexcept
    : NftTransfer() {
    *this = ::std::move(from);
  }

  inline NftTransfer& operator=(const NftTransfer& from) {
    CopyFrom(from);
    return *this;
  }
  inline NftTransfer& operator=(NftTransfer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NftTransfer& default_instance() {
    return *internal_default_instance();
  }
  static inline const NftTransfer* internal_default_instance() {
    return reinterpret_cast<const NftTransfer*>(
               &_NftTransfer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(NftTransfer& a, NftTransfer& b) {
    a.Swap(&b);
  }
  inline void Swap(NftTransfer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NftTransfer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NftTransfer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NftTransfer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NftTransfer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NftTransfer& from) {
    NftTransfer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NftTransfer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.NftTransfer";
  }
  protected:
  explicit NftTransfer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderAccountIDFieldNumber = 1,
    kReceiverAccountIDFieldNumber = 2,
    kSerialNumberFieldNumber = 3,
    kIsApprovalFieldNumber = 4,
  };
  // .proto.AccountID senderAccountID = 1;
  bool has_senderaccountid() const;
  private:
  bool _internal_has_senderaccountid() const;
  public:
  void clear_senderaccountid();
  const ::proto::AccountID& senderaccountid() const;
  PROTOBUF_NODISCARD ::proto::AccountID* release_senderaccountid();
  ::proto::AccountID* mutable_senderaccountid();
  void set_allocated_senderaccountid(::proto::AccountID* senderaccountid);
  private:
  const ::proto::AccountID& _internal_senderaccountid() const;
  ::proto::AccountID* _internal_mutable_senderaccountid();
  public:
  void unsafe_arena_set_allocated_senderaccountid(
      ::proto::AccountID* senderaccountid);
  ::proto::AccountID* unsafe_arena_release_senderaccountid();

  // .proto.AccountID receiverAccountID = 2;
  bool has_receiveraccountid() const;
  private:
  bool _internal_has_receiveraccountid() const;
  public:
  void clear_receiveraccountid();
  const ::proto::AccountID& receiveraccountid() const;
  PROTOBUF_NODISCARD ::proto::AccountID* release_receiveraccountid();
  ::proto::AccountID* mutable_receiveraccountid();
  void set_allocated_receiveraccountid(::proto::AccountID* receiveraccountid);
  private:
  const ::proto::AccountID& _internal_receiveraccountid() const;
  ::proto::AccountID* _internal_mutable_receiveraccountid();
  public:
  void unsafe_arena_set_allocated_receiveraccountid(
      ::proto::AccountID* receiveraccountid);
  ::proto::AccountID* unsafe_arena_release_receiveraccountid();

  // int64 serialNumber = 3;
  void clear_serialnumber();
  int64_t serialnumber() const;
  void set_serialnumber(int64_t value);
  private:
  int64_t _internal_serialnumber() const;
  void _internal_set_serialnumber(int64_t value);
  public:

  // bool is_approval = 4;
  void clear_is_approval();
  bool is_approval() const;
  void set_is_approval(bool value);
  private:
  bool _internal_is_approval() const;
  void _internal_set_is_approval(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.NftTransfer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::AccountID* senderaccountid_;
    ::proto::AccountID* receiveraccountid_;
    int64_t serialnumber_;
    bool is_approval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class TokenTransferList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.TokenTransferList) */ {
 public:
  inline TokenTransferList() : TokenTransferList(nullptr) {}
  ~TokenTransferList() override;
  explicit PROTOBUF_CONSTEXPR TokenTransferList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenTransferList(const TokenTransferList& from);
  TokenTransferList(TokenTransferList&& from) noexcept
    : TokenTransferList() {
    *this = ::std::move(from);
  }

  inline TokenTransferList& operator=(const TokenTransferList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenTransferList& operator=(TokenTransferList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenTransferList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenTransferList* internal_default_instance() {
    return reinterpret_cast<const TokenTransferList*>(
               &_TokenTransferList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TokenTransferList& a, TokenTransferList& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenTransferList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenTransferList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenTransferList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenTransferList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenTransferList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenTransferList& from) {
    TokenTransferList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenTransferList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.TokenTransferList";
  }
  protected:
  explicit TokenTransferList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransfersFieldNumber = 2,
    kNftTransfersFieldNumber = 3,
    kTokenFieldNumber = 1,
    kExpectedDecimalsFieldNumber = 4,
  };
  // repeated .proto.AccountAmount transfers = 2;
  int transfers_size() const;
  private:
  int _internal_transfers_size() const;
  public:
  void clear_transfers();
  ::proto::AccountAmount* mutable_transfers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::AccountAmount >*
      mutable_transfers();
  private:
  const ::proto::AccountAmount& _internal_transfers(int index) const;
  ::proto::AccountAmount* _internal_add_transfers();
  public:
  const ::proto::AccountAmount& transfers(int index) const;
  ::proto::AccountAmount* add_transfers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::AccountAmount >&
      transfers() const;

  // repeated .proto.NftTransfer nftTransfers = 3;
  int nfttransfers_size() const;
  private:
  int _internal_nfttransfers_size() const;
  public:
  void clear_nfttransfers();
  ::proto::NftTransfer* mutable_nfttransfers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::NftTransfer >*
      mutable_nfttransfers();
  private:
  const ::proto::NftTransfer& _internal_nfttransfers(int index) const;
  ::proto::NftTransfer* _internal_add_nfttransfers();
  public:
  const ::proto::NftTransfer& nfttransfers(int index) const;
  ::proto::NftTransfer* add_nfttransfers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::NftTransfer >&
      nfttransfers() const;

  // .proto.TokenID token = 1;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const ::proto::TokenID& token() const;
  PROTOBUF_NODISCARD ::proto::TokenID* release_token();
  ::proto::TokenID* mutable_token();
  void set_allocated_token(::proto::TokenID* token);
  private:
  const ::proto::TokenID& _internal_token() const;
  ::proto::TokenID* _internal_mutable_token();
  public:
  void unsafe_arena_set_allocated_token(
      ::proto::TokenID* token);
  ::proto::TokenID* unsafe_arena_release_token();

  // .google.protobuf.UInt32Value expected_decimals = 4;
  bool has_expected_decimals() const;
  private:
  bool _internal_has_expected_decimals() const;
  public:
  void clear_expected_decimals();
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value& expected_decimals() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt32Value* release_expected_decimals();
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* mutable_expected_decimals();
  void set_allocated_expected_decimals(::PROTOBUF_NAMESPACE_ID::UInt32Value* expected_decimals);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value& _internal_expected_decimals() const;
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* _internal_mutable_expected_decimals();
  public:
  void unsafe_arena_set_allocated_expected_decimals(
      ::PROTOBUF_NAMESPACE_ID::UInt32Value* expected_decimals);
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* unsafe_arena_release_expected_decimals();

  // @@protoc_insertion_point(class_scope:proto.TokenTransferList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::AccountAmount > transfers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::NftTransfer > nfttransfers_;
    ::proto::TokenID* token_;
    ::PROTOBUF_NAMESPACE_ID::UInt32Value* expected_decimals_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class Fraction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Fraction) */ {
 public:
  inline Fraction() : Fraction(nullptr) {}
  ~Fraction() override;
  explicit PROTOBUF_CONSTEXPR Fraction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fraction(const Fraction& from);
  Fraction(Fraction&& from) noexcept
    : Fraction() {
    *this = ::std::move(from);
  }

  inline Fraction& operator=(const Fraction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fraction& operator=(Fraction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fraction& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fraction* internal_default_instance() {
    return reinterpret_cast<const Fraction*>(
               &_Fraction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Fraction& a, Fraction& b) {
    a.Swap(&b);
  }
  inline void Swap(Fraction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fraction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fraction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fraction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Fraction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Fraction& from) {
    Fraction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fraction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Fraction";
  }
  protected:
  explicit Fraction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumeratorFieldNumber = 1,
    kDenominatorFieldNumber = 2,
  };
  // int64 numerator = 1;
  void clear_numerator();
  int64_t numerator() const;
  void set_numerator(int64_t value);
  private:
  int64_t _internal_numerator() const;
  void _internal_set_numerator(int64_t value);
  public:

  // int64 denominator = 2;
  void clear_denominator();
  int64_t denominator() const;
  void set_denominator(int64_t value);
  private:
  int64_t _internal_denominator() const;
  void _internal_set_denominator(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.Fraction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t numerator_;
    int64_t denominator_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class TopicID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.TopicID) */ {
 public:
  inline TopicID() : TopicID(nullptr) {}
  ~TopicID() override;
  explicit PROTOBUF_CONSTEXPR TopicID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TopicID(const TopicID& from);
  TopicID(TopicID&& from) noexcept
    : TopicID() {
    *this = ::std::move(from);
  }

  inline TopicID& operator=(const TopicID& from) {
    CopyFrom(from);
    return *this;
  }
  inline TopicID& operator=(TopicID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TopicID& default_instance() {
    return *internal_default_instance();
  }
  static inline const TopicID* internal_default_instance() {
    return reinterpret_cast<const TopicID*>(
               &_TopicID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TopicID& a, TopicID& b) {
    a.Swap(&b);
  }
  inline void Swap(TopicID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TopicID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TopicID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TopicID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TopicID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TopicID& from) {
    TopicID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TopicID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.TopicID";
  }
  protected:
  explicit TopicID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShardNumFieldNumber = 1,
    kRealmNumFieldNumber = 2,
    kTopicNumFieldNumber = 3,
  };
  // int64 shardNum = 1;
  void clear_shardnum();
  int64_t shardnum() const;
  void set_shardnum(int64_t value);
  private:
  int64_t _internal_shardnum() const;
  void _internal_set_shardnum(int64_t value);
  public:

  // int64 realmNum = 2;
  void clear_realmnum();
  int64_t realmnum() const;
  void set_realmnum(int64_t value);
  private:
  int64_t _internal_realmnum() const;
  void _internal_set_realmnum(int64_t value);
  public:

  // int64 topicNum = 3;
  void clear_topicnum();
  int64_t topicnum() const;
  void set_topicnum(int64_t value);
  private:
  int64_t _internal_topicnum() const;
  void _internal_set_topicnum(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.TopicID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t shardnum_;
    int64_t realmnum_;
    int64_t topicnum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class TokenID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.TokenID) */ {
 public:
  inline TokenID() : TokenID(nullptr) {}
  ~TokenID() override;
  explicit PROTOBUF_CONSTEXPR TokenID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenID(const TokenID& from);
  TokenID(TokenID&& from) noexcept
    : TokenID() {
    *this = ::std::move(from);
  }

  inline TokenID& operator=(const TokenID& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenID& operator=(TokenID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenID& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenID* internal_default_instance() {
    return reinterpret_cast<const TokenID*>(
               &_TokenID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TokenID& a, TokenID& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenID& from) {
    TokenID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.TokenID";
  }
  protected:
  explicit TokenID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShardNumFieldNumber = 1,
    kRealmNumFieldNumber = 2,
    kTokenNumFieldNumber = 3,
  };
  // int64 shardNum = 1;
  void clear_shardnum();
  int64_t shardnum() const;
  void set_shardnum(int64_t value);
  private:
  int64_t _internal_shardnum() const;
  void _internal_set_shardnum(int64_t value);
  public:

  // int64 realmNum = 2;
  void clear_realmnum();
  int64_t realmnum() const;
  void set_realmnum(int64_t value);
  private:
  int64_t _internal_realmnum() const;
  void _internal_set_realmnum(int64_t value);
  public:

  // int64 tokenNum = 3;
  void clear_tokennum();
  int64_t tokennum() const;
  void set_tokennum(int64_t value);
  private:
  int64_t _internal_tokennum() const;
  void _internal_set_tokennum(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.TokenID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t shardnum_;
    int64_t realmnum_;
    int64_t tokennum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class ScheduleID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ScheduleID) */ {
 public:
  inline ScheduleID() : ScheduleID(nullptr) {}
  ~ScheduleID() override;
  explicit PROTOBUF_CONSTEXPR ScheduleID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScheduleID(const ScheduleID& from);
  ScheduleID(ScheduleID&& from) noexcept
    : ScheduleID() {
    *this = ::std::move(from);
  }

  inline ScheduleID& operator=(const ScheduleID& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScheduleID& operator=(ScheduleID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScheduleID& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScheduleID* internal_default_instance() {
    return reinterpret_cast<const ScheduleID*>(
               &_ScheduleID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ScheduleID& a, ScheduleID& b) {
    a.Swap(&b);
  }
  inline void Swap(ScheduleID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScheduleID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScheduleID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScheduleID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScheduleID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ScheduleID& from) {
    ScheduleID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScheduleID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ScheduleID";
  }
  protected:
  explicit ScheduleID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShardNumFieldNumber = 1,
    kRealmNumFieldNumber = 2,
    kScheduleNumFieldNumber = 3,
  };
  // int64 shardNum = 1;
  void clear_shardnum();
  int64_t shardnum() const;
  void set_shardnum(int64_t value);
  private:
  int64_t _internal_shardnum() const;
  void _internal_set_shardnum(int64_t value);
  public:

  // int64 realmNum = 2;
  void clear_realmnum();
  int64_t realmnum() const;
  void set_realmnum(int64_t value);
  private:
  int64_t _internal_realmnum() const;
  void _internal_set_realmnum(int64_t value);
  public:

  // int64 scheduleNum = 3;
  void clear_schedulenum();
  int64_t schedulenum() const;
  void set_schedulenum(int64_t value);
  private:
  int64_t _internal_schedulenum() const;
  void _internal_set_schedulenum(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ScheduleID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t shardnum_;
    int64_t realmnum_;
    int64_t schedulenum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class Key final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Key) */ {
 public:
  inline Key() : Key(nullptr) {}
  ~Key() override;
  explicit PROTOBUF_CONSTEXPR Key(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Key(const Key& from);
  Key(Key&& from) noexcept
    : Key() {
    *this = ::std::move(from);
  }

  inline Key& operator=(const Key& from) {
    CopyFrom(from);
    return *this;
  }
  inline Key& operator=(Key&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Key& default_instance() {
    return *internal_default_instance();
  }
  enum KeyCase {
    kContractID = 1,
    kEd25519 = 2,
    kRSA3072 = 3,
    kECDSA384 = 4,
    kThresholdKey = 5,
    kKeyList = 6,
    kECDSASecp256K1 = 7,
    kDelegatableContractId = 8,
    KEY_NOT_SET = 0,
  };

  static inline const Key* internal_default_instance() {
    return reinterpret_cast<const Key*>(
               &_Key_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Key& a, Key& b) {
    a.Swap(&b);
  }
  inline void Swap(Key* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Key* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Key* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Key>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Key& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Key& from) {
    Key::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Key* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Key";
  }
  protected:
  explicit Key(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIDFieldNumber = 1,
    kEd25519FieldNumber = 2,
    kRSA3072FieldNumber = 3,
    kECDSA384FieldNumber = 4,
    kThresholdKeyFieldNumber = 5,
    kKeyListFieldNumber = 6,
    kECDSASecp256K1FieldNumber = 7,
    kDelegatableContractIdFieldNumber = 8,
  };
  // .proto.ContractID contractID = 1;
  bool has_contractid() const;
  private:
  bool _internal_has_contractid() const;
  public:
  void clear_contractid();
  const ::proto::ContractID& contractid() const;
  PROTOBUF_NODISCARD ::proto::ContractID* release_contractid();
  ::proto::ContractID* mutable_contractid();
  void set_allocated_contractid(::proto::ContractID* contractid);
  private:
  const ::proto::ContractID& _internal_contractid() const;
  ::proto::ContractID* _internal_mutable_contractid();
  public:
  void unsafe_arena_set_allocated_contractid(
      ::proto::ContractID* contractid);
  ::proto::ContractID* unsafe_arena_release_contractid();

  // bytes ed25519 = 2;
  bool has_ed25519() const;
  private:
  bool _internal_has_ed25519() const;
  public:
  void clear_ed25519();
  const std::string& ed25519() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ed25519(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ed25519();
  PROTOBUF_NODISCARD std::string* release_ed25519();
  void set_allocated_ed25519(std::string* ed25519);
  private:
  const std::string& _internal_ed25519() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ed25519(const std::string& value);
  std::string* _internal_mutable_ed25519();
  public:

  // bytes RSA_3072 = 3;
  bool has_rsa_3072() const;
  private:
  bool _internal_has_rsa_3072() const;
  public:
  void clear_rsa_3072();
  const std::string& rsa_3072() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rsa_3072(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rsa_3072();
  PROTOBUF_NODISCARD std::string* release_rsa_3072();
  void set_allocated_rsa_3072(std::string* rsa_3072);
  private:
  const std::string& _internal_rsa_3072() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rsa_3072(const std::string& value);
  std::string* _internal_mutable_rsa_3072();
  public:

  // bytes ECDSA_384 = 4;
  bool has_ecdsa_384() const;
  private:
  bool _internal_has_ecdsa_384() const;
  public:
  void clear_ecdsa_384();
  const std::string& ecdsa_384() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ecdsa_384(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ecdsa_384();
  PROTOBUF_NODISCARD std::string* release_ecdsa_384();
  void set_allocated_ecdsa_384(std::string* ecdsa_384);
  private:
  const std::string& _internal_ecdsa_384() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ecdsa_384(const std::string& value);
  std::string* _internal_mutable_ecdsa_384();
  public:

  // .proto.ThresholdKey thresholdKey = 5;
  bool has_thresholdkey() const;
  private:
  bool _internal_has_thresholdkey() const;
  public:
  void clear_thresholdkey();
  const ::proto::ThresholdKey& thresholdkey() const;
  PROTOBUF_NODISCARD ::proto::ThresholdKey* release_thresholdkey();
  ::proto::ThresholdKey* mutable_thresholdkey();
  void set_allocated_thresholdkey(::proto::ThresholdKey* thresholdkey);
  private:
  const ::proto::ThresholdKey& _internal_thresholdkey() const;
  ::proto::ThresholdKey* _internal_mutable_thresholdkey();
  public:
  void unsafe_arena_set_allocated_thresholdkey(
      ::proto::ThresholdKey* thresholdkey);
  ::proto::ThresholdKey* unsafe_arena_release_thresholdkey();

  // .proto.KeyList keyList = 6;
  bool has_keylist() const;
  private:
  bool _internal_has_keylist() const;
  public:
  void clear_keylist();
  const ::proto::KeyList& keylist() const;
  PROTOBUF_NODISCARD ::proto::KeyList* release_keylist();
  ::proto::KeyList* mutable_keylist();
  void set_allocated_keylist(::proto::KeyList* keylist);
  private:
  const ::proto::KeyList& _internal_keylist() const;
  ::proto::KeyList* _internal_mutable_keylist();
  public:
  void unsafe_arena_set_allocated_keylist(
      ::proto::KeyList* keylist);
  ::proto::KeyList* unsafe_arena_release_keylist();

  // bytes ECDSA_secp256k1 = 7;
  bool has_ecdsa_secp256k1() const;
  private:
  bool _internal_has_ecdsa_secp256k1() const;
  public:
  void clear_ecdsa_secp256k1();
  const std::string& ecdsa_secp256k1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ecdsa_secp256k1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ecdsa_secp256k1();
  PROTOBUF_NODISCARD std::string* release_ecdsa_secp256k1();
  void set_allocated_ecdsa_secp256k1(std::string* ecdsa_secp256k1);
  private:
  const std::string& _internal_ecdsa_secp256k1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ecdsa_secp256k1(const std::string& value);
  std::string* _internal_mutable_ecdsa_secp256k1();
  public:

  // .proto.ContractID delegatable_contract_id = 8;
  bool has_delegatable_contract_id() const;
  private:
  bool _internal_has_delegatable_contract_id() const;
  public:
  void clear_delegatable_contract_id();
  const ::proto::ContractID& delegatable_contract_id() const;
  PROTOBUF_NODISCARD ::proto::ContractID* release_delegatable_contract_id();
  ::proto::ContractID* mutable_delegatable_contract_id();
  void set_allocated_delegatable_contract_id(::proto::ContractID* delegatable_contract_id);
  private:
  const ::proto::ContractID& _internal_delegatable_contract_id() const;
  ::proto::ContractID* _internal_mutable_delegatable_contract_id();
  public:
  void unsafe_arena_set_allocated_delegatable_contract_id(
      ::proto::ContractID* delegatable_contract_id);
  ::proto::ContractID* unsafe_arena_release_delegatable_contract_id();

  void clear_key();
  KeyCase key_case() const;
  // @@protoc_insertion_point(class_scope:proto.Key)
 private:
  class _Internal;
  void set_has_contractid();
  void set_has_ed25519();
  void set_has_rsa_3072();
  void set_has_ecdsa_384();
  void set_has_thresholdkey();
  void set_has_keylist();
  void set_has_ecdsa_secp256k1();
  void set_has_delegatable_contract_id();

  inline bool has_key() const;
  inline void clear_has_key();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union KeyUnion {
      constexpr KeyUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::proto::ContractID* contractid_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ed25519_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rsa_3072_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ecdsa_384_;
      ::proto::ThresholdKey* thresholdkey_;
      ::proto::KeyList* keylist_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ecdsa_secp256k1_;
      ::proto::ContractID* delegatable_contract_id_;
    } key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class ThresholdKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ThresholdKey) */ {
 public:
  inline ThresholdKey() : ThresholdKey(nullptr) {}
  ~ThresholdKey() override;
  explicit PROTOBUF_CONSTEXPR ThresholdKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThresholdKey(const ThresholdKey& from);
  ThresholdKey(ThresholdKey&& from) noexcept
    : ThresholdKey() {
    *this = ::std::move(from);
  }

  inline ThresholdKey& operator=(const ThresholdKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThresholdKey& operator=(ThresholdKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThresholdKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThresholdKey* internal_default_instance() {
    return reinterpret_cast<const ThresholdKey*>(
               &_ThresholdKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ThresholdKey& a, ThresholdKey& b) {
    a.Swap(&b);
  }
  inline void Swap(ThresholdKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThresholdKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThresholdKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThresholdKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ThresholdKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ThresholdKey& from) {
    ThresholdKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThresholdKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ThresholdKey";
  }
  protected:
  explicit ThresholdKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 2,
    kThresholdFieldNumber = 1,
  };
  // .proto.KeyList keys = 2;
  bool has_keys() const;
  private:
  bool _internal_has_keys() const;
  public:
  void clear_keys();
  const ::proto::KeyList& keys() const;
  PROTOBUF_NODISCARD ::proto::KeyList* release_keys();
  ::proto::KeyList* mutable_keys();
  void set_allocated_keys(::proto::KeyList* keys);
  private:
  const ::proto::KeyList& _internal_keys() const;
  ::proto::KeyList* _internal_mutable_keys();
  public:
  void unsafe_arena_set_allocated_keys(
      ::proto::KeyList* keys);
  ::proto::KeyList* unsafe_arena_release_keys();

  // uint32 threshold = 1;
  void clear_threshold();
  uint32_t threshold() const;
  void set_threshold(uint32_t value);
  private:
  uint32_t _internal_threshold() const;
  void _internal_set_threshold(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ThresholdKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::KeyList* keys_;
    uint32_t threshold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KeyList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.KeyList) */ {
 public:
  inline KeyList() : KeyList(nullptr) {}
  ~KeyList() override;
  explicit PROTOBUF_CONSTEXPR KeyList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyList(const KeyList& from);
  KeyList(KeyList&& from) noexcept
    : KeyList() {
    *this = ::std::move(from);
  }

  inline KeyList& operator=(const KeyList& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyList& operator=(KeyList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyList& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyList* internal_default_instance() {
    return reinterpret_cast<const KeyList*>(
               &_KeyList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(KeyList& a, KeyList& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyList& from) {
    KeyList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.KeyList";
  }
  protected:
  explicit KeyList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 1,
  };
  // repeated .proto.Key keys = 1;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  ::proto::Key* mutable_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Key >*
      mutable_keys();
  private:
  const ::proto::Key& _internal_keys(int index) const;
  ::proto::Key* _internal_add_keys();
  public:
  const ::proto::Key& keys(int index) const;
  ::proto::Key* add_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Key >&
      keys() const;

  // @@protoc_insertion_point(class_scope:proto.KeyList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Key > keys_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class Signature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Signature) */ {
 public:
  inline Signature() : Signature(nullptr) {}
  ~Signature() override;
  explicit PROTOBUF_CONSTEXPR Signature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Signature(const Signature& from);
  Signature(Signature&& from) noexcept
    : Signature() {
    *this = ::std::move(from);
  }

  inline Signature& operator=(const Signature& from) {
    CopyFrom(from);
    return *this;
  }
  inline Signature& operator=(Signature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Signature& default_instance() {
    return *internal_default_instance();
  }
  enum SignatureCase {
    kContract = 1,
    kEd25519 = 2,
    kRSA3072 = 3,
    kECDSA384 = 4,
    kThresholdSignature = 5,
    kSignatureList = 6,
    SIGNATURE_NOT_SET = 0,
  };

  static inline const Signature* internal_default_instance() {
    return reinterpret_cast<const Signature*>(
               &_Signature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Signature& a, Signature& b) {
    a.Swap(&b);
  }
  inline void Swap(Signature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Signature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Signature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Signature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Signature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Signature& from) {
    Signature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Signature";
  }
  protected:
  explicit Signature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractFieldNumber = 1,
    kEd25519FieldNumber = 2,
    kRSA3072FieldNumber = 3,
    kECDSA384FieldNumber = 4,
    kThresholdSignatureFieldNumber = 5,
    kSignatureListFieldNumber = 6,
  };
  // bytes contract = 1;
  bool has_contract() const;
  private:
  bool _internal_has_contract() const;
  public:
  void clear_contract();
  const std::string& contract() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract();
  PROTOBUF_NODISCARD std::string* release_contract();
  void set_allocated_contract(std::string* contract);
  private:
  const std::string& _internal_contract() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract(const std::string& value);
  std::string* _internal_mutable_contract();
  public:

  // bytes ed25519 = 2;
  bool has_ed25519() const;
  private:
  bool _internal_has_ed25519() const;
  public:
  void clear_ed25519();
  const std::string& ed25519() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ed25519(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ed25519();
  PROTOBUF_NODISCARD std::string* release_ed25519();
  void set_allocated_ed25519(std::string* ed25519);
  private:
  const std::string& _internal_ed25519() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ed25519(const std::string& value);
  std::string* _internal_mutable_ed25519();
  public:

  // bytes RSA_3072 = 3;
  bool has_rsa_3072() const;
  private:
  bool _internal_has_rsa_3072() const;
  public:
  void clear_rsa_3072();
  const std::string& rsa_3072() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rsa_3072(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rsa_3072();
  PROTOBUF_NODISCARD std::string* release_rsa_3072();
  void set_allocated_rsa_3072(std::string* rsa_3072);
  private:
  const std::string& _internal_rsa_3072() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rsa_3072(const std::string& value);
  std::string* _internal_mutable_rsa_3072();
  public:

  // bytes ECDSA_384 = 4;
  bool has_ecdsa_384() const;
  private:
  bool _internal_has_ecdsa_384() const;
  public:
  void clear_ecdsa_384();
  const std::string& ecdsa_384() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ecdsa_384(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ecdsa_384();
  PROTOBUF_NODISCARD std::string* release_ecdsa_384();
  void set_allocated_ecdsa_384(std::string* ecdsa_384);
  private:
  const std::string& _internal_ecdsa_384() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ecdsa_384(const std::string& value);
  std::string* _internal_mutable_ecdsa_384();
  public:

  // .proto.ThresholdSignature thresholdSignature = 5;
  bool has_thresholdsignature() const;
  private:
  bool _internal_has_thresholdsignature() const;
  public:
  void clear_thresholdsignature();
  const ::proto::ThresholdSignature& thresholdsignature() const;
  PROTOBUF_NODISCARD ::proto::ThresholdSignature* release_thresholdsignature();
  ::proto::ThresholdSignature* mutable_thresholdsignature();
  void set_allocated_thresholdsignature(::proto::ThresholdSignature* thresholdsignature);
  private:
  const ::proto::ThresholdSignature& _internal_thresholdsignature() const;
  ::proto::ThresholdSignature* _internal_mutable_thresholdsignature();
  public:
  void unsafe_arena_set_allocated_thresholdsignature(
      ::proto::ThresholdSignature* thresholdsignature);
  ::proto::ThresholdSignature* unsafe_arena_release_thresholdsignature();

  // .proto.SignatureList signatureList = 6;
  bool has_signaturelist() const;
  private:
  bool _internal_has_signaturelist() const;
  public:
  void clear_signaturelist();
  const ::proto::SignatureList& signaturelist() const;
  PROTOBUF_NODISCARD ::proto::SignatureList* release_signaturelist();
  ::proto::SignatureList* mutable_signaturelist();
  void set_allocated_signaturelist(::proto::SignatureList* signaturelist);
  private:
  const ::proto::SignatureList& _internal_signaturelist() const;
  ::proto::SignatureList* _internal_mutable_signaturelist();
  public:
  void unsafe_arena_set_allocated_signaturelist(
      ::proto::SignatureList* signaturelist);
  ::proto::SignatureList* unsafe_arena_release_signaturelist();

  void clear_signature();
  SignatureCase signature_case() const;
  // @@protoc_insertion_point(class_scope:proto.Signature)
 private:
  class _Internal;
  void set_has_contract();
  void set_has_ed25519();
  void set_has_rsa_3072();
  void set_has_ecdsa_384();
  void set_has_thresholdsignature();
  void set_has_signaturelist();

  inline bool has_signature() const;
  inline void clear_has_signature();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union SignatureUnion {
      constexpr SignatureUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ed25519_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rsa_3072_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ecdsa_384_;
      ::proto::ThresholdSignature* thresholdsignature_;
      ::proto::SignatureList* signaturelist_;
    } signature_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class ThresholdSignature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ThresholdSignature) */ {
 public:
  inline ThresholdSignature() : ThresholdSignature(nullptr) {}
  ~ThresholdSignature() override;
  explicit PROTOBUF_CONSTEXPR ThresholdSignature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThresholdSignature(const ThresholdSignature& from);
  ThresholdSignature(ThresholdSignature&& from) noexcept
    : ThresholdSignature() {
    *this = ::std::move(from);
  }

  inline ThresholdSignature& operator=(const ThresholdSignature& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThresholdSignature& operator=(ThresholdSignature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThresholdSignature& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThresholdSignature* internal_default_instance() {
    return reinterpret_cast<const ThresholdSignature*>(
               &_ThresholdSignature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ThresholdSignature& a, ThresholdSignature& b) {
    a.Swap(&b);
  }
  inline void Swap(ThresholdSignature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThresholdSignature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThresholdSignature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThresholdSignature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ThresholdSignature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ThresholdSignature& from) {
    ThresholdSignature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThresholdSignature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ThresholdSignature";
  }
  protected:
  explicit ThresholdSignature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSigsFieldNumber = 2,
  };
  // .proto.SignatureList sigs = 2;
  bool has_sigs() const;
  private:
  bool _internal_has_sigs() const;
  public:
  void clear_sigs();
  const ::proto::SignatureList& sigs() const;
  PROTOBUF_NODISCARD ::proto::SignatureList* release_sigs();
  ::proto::SignatureList* mutable_sigs();
  void set_allocated_sigs(::proto::SignatureList* sigs);
  private:
  const ::proto::SignatureList& _internal_sigs() const;
  ::proto::SignatureList* _internal_mutable_sigs();
  public:
  void unsafe_arena_set_allocated_sigs(
      ::proto::SignatureList* sigs);
  ::proto::SignatureList* unsafe_arena_release_sigs();

  // @@protoc_insertion_point(class_scope:proto.ThresholdSignature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::SignatureList* sigs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class SignatureList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.SignatureList) */ {
 public:
  inline SignatureList() : SignatureList(nullptr) {}
  ~SignatureList() override;
  explicit PROTOBUF_CONSTEXPR SignatureList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignatureList(const SignatureList& from);
  SignatureList(SignatureList&& from) noexcept
    : SignatureList() {
    *this = ::std::move(from);
  }

  inline SignatureList& operator=(const SignatureList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignatureList& operator=(SignatureList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignatureList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignatureList* internal_default_instance() {
    return reinterpret_cast<const SignatureList*>(
               &_SignatureList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SignatureList& a, SignatureList& b) {
    a.Swap(&b);
  }
  inline void Swap(SignatureList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignatureList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignatureList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignatureList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignatureList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignatureList& from) {
    SignatureList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignatureList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.SignatureList";
  }
  protected:
  explicit SignatureList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSigsFieldNumber = 2,
  };
  // repeated .proto.Signature sigs = 2;
  int sigs_size() const;
  private:
  int _internal_sigs_size() const;
  public:
  void clear_sigs();
  ::proto::Signature* mutable_sigs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Signature >*
      mutable_sigs();
  private:
  const ::proto::Signature& _internal_sigs(int index) const;
  ::proto::Signature* _internal_add_sigs();
  public:
  const ::proto::Signature& sigs(int index) const;
  ::proto::Signature* add_sigs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Signature >&
      sigs() const;

  // @@protoc_insertion_point(class_scope:proto.SignatureList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Signature > sigs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class SignaturePair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.SignaturePair) */ {
 public:
  inline SignaturePair() : SignaturePair(nullptr) {}
  ~SignaturePair() override;
  explicit PROTOBUF_CONSTEXPR SignaturePair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignaturePair(const SignaturePair& from);
  SignaturePair(SignaturePair&& from) noexcept
    : SignaturePair() {
    *this = ::std::move(from);
  }

  inline SignaturePair& operator=(const SignaturePair& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignaturePair& operator=(SignaturePair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignaturePair& default_instance() {
    return *internal_default_instance();
  }
  enum SignatureCase {
    kContract = 2,
    kEd25519 = 3,
    kRSA3072 = 4,
    kECDSA384 = 5,
    kECDSASecp256K1 = 6,
    SIGNATURE_NOT_SET = 0,
  };

  static inline const SignaturePair* internal_default_instance() {
    return reinterpret_cast<const SignaturePair*>(
               &_SignaturePair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SignaturePair& a, SignaturePair& b) {
    a.Swap(&b);
  }
  inline void Swap(SignaturePair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignaturePair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignaturePair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignaturePair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignaturePair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignaturePair& from) {
    SignaturePair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignaturePair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.SignaturePair";
  }
  protected:
  explicit SignaturePair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubKeyPrefixFieldNumber = 1,
    kContractFieldNumber = 2,
    kEd25519FieldNumber = 3,
    kRSA3072FieldNumber = 4,
    kECDSA384FieldNumber = 5,
    kECDSASecp256K1FieldNumber = 6,
  };
  // bytes pubKeyPrefix = 1;
  void clear_pubkeyprefix();
  const std::string& pubkeyprefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pubkeyprefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pubkeyprefix();
  PROTOBUF_NODISCARD std::string* release_pubkeyprefix();
  void set_allocated_pubkeyprefix(std::string* pubkeyprefix);
  private:
  const std::string& _internal_pubkeyprefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pubkeyprefix(const std::string& value);
  std::string* _internal_mutable_pubkeyprefix();
  public:

  // bytes contract = 2;
  bool has_contract() const;
  private:
  bool _internal_has_contract() const;
  public:
  void clear_contract();
  const std::string& contract() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract();
  PROTOBUF_NODISCARD std::string* release_contract();
  void set_allocated_contract(std::string* contract);
  private:
  const std::string& _internal_contract() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract(const std::string& value);
  std::string* _internal_mutable_contract();
  public:

  // bytes ed25519 = 3;
  bool has_ed25519() const;
  private:
  bool _internal_has_ed25519() const;
  public:
  void clear_ed25519();
  const std::string& ed25519() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ed25519(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ed25519();
  PROTOBUF_NODISCARD std::string* release_ed25519();
  void set_allocated_ed25519(std::string* ed25519);
  private:
  const std::string& _internal_ed25519() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ed25519(const std::string& value);
  std::string* _internal_mutable_ed25519();
  public:

  // bytes RSA_3072 = 4;
  bool has_rsa_3072() const;
  private:
  bool _internal_has_rsa_3072() const;
  public:
  void clear_rsa_3072();
  const std::string& rsa_3072() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rsa_3072(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rsa_3072();
  PROTOBUF_NODISCARD std::string* release_rsa_3072();
  void set_allocated_rsa_3072(std::string* rsa_3072);
  private:
  const std::string& _internal_rsa_3072() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rsa_3072(const std::string& value);
  std::string* _internal_mutable_rsa_3072();
  public:

  // bytes ECDSA_384 = 5;
  bool has_ecdsa_384() const;
  private:
  bool _internal_has_ecdsa_384() const;
  public:
  void clear_ecdsa_384();
  const std::string& ecdsa_384() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ecdsa_384(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ecdsa_384();
  PROTOBUF_NODISCARD std::string* release_ecdsa_384();
  void set_allocated_ecdsa_384(std::string* ecdsa_384);
  private:
  const std::string& _internal_ecdsa_384() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ecdsa_384(const std::string& value);
  std::string* _internal_mutable_ecdsa_384();
  public:

  // bytes ECDSA_secp256k1 = 6;
  bool has_ecdsa_secp256k1() const;
  private:
  bool _internal_has_ecdsa_secp256k1() const;
  public:
  void clear_ecdsa_secp256k1();
  const std::string& ecdsa_secp256k1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ecdsa_secp256k1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ecdsa_secp256k1();
  PROTOBUF_NODISCARD std::string* release_ecdsa_secp256k1();
  void set_allocated_ecdsa_secp256k1(std::string* ecdsa_secp256k1);
  private:
  const std::string& _internal_ecdsa_secp256k1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ecdsa_secp256k1(const std::string& value);
  std::string* _internal_mutable_ecdsa_secp256k1();
  public:

  void clear_signature();
  SignatureCase signature_case() const;
  // @@protoc_insertion_point(class_scope:proto.SignaturePair)
 private:
  class _Internal;
  void set_has_contract();
  void set_has_ed25519();
  void set_has_rsa_3072();
  void set_has_ecdsa_384();
  void set_has_ecdsa_secp256k1();

  inline bool has_signature() const;
  inline void clear_has_signature();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pubkeyprefix_;
    union SignatureUnion {
      constexpr SignatureUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ed25519_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rsa_3072_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ecdsa_384_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ecdsa_secp256k1_;
    } signature_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class SignatureMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.SignatureMap) */ {
 public:
  inline SignatureMap() : SignatureMap(nullptr) {}
  ~SignatureMap() override;
  explicit PROTOBUF_CONSTEXPR SignatureMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignatureMap(const SignatureMap& from);
  SignatureMap(SignatureMap&& from) noexcept
    : SignatureMap() {
    *this = ::std::move(from);
  }

  inline SignatureMap& operator=(const SignatureMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignatureMap& operator=(SignatureMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignatureMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignatureMap* internal_default_instance() {
    return reinterpret_cast<const SignatureMap*>(
               &_SignatureMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SignatureMap& a, SignatureMap& b) {
    a.Swap(&b);
  }
  inline void Swap(SignatureMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignatureMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignatureMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignatureMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignatureMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignatureMap& from) {
    SignatureMap::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignatureMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.SignatureMap";
  }
  protected:
  explicit SignatureMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSigPairFieldNumber = 1,
  };
  // repeated .proto.SignaturePair sigPair = 1;
  int sigpair_size() const;
  private:
  int _internal_sigpair_size() const;
  public:
  void clear_sigpair();
  ::proto::SignaturePair* mutable_sigpair(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::SignaturePair >*
      mutable_sigpair();
  private:
  const ::proto::SignaturePair& _internal_sigpair(int index) const;
  ::proto::SignaturePair* _internal_add_sigpair();
  public:
  const ::proto::SignaturePair& sigpair(int index) const;
  ::proto::SignaturePair* add_sigpair();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::SignaturePair >&
      sigpair() const;

  // @@protoc_insertion_point(class_scope:proto.SignatureMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::SignaturePair > sigpair_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class FeeComponents final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.FeeComponents) */ {
 public:
  inline FeeComponents() : FeeComponents(nullptr) {}
  ~FeeComponents() override;
  explicit PROTOBUF_CONSTEXPR FeeComponents(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeeComponents(const FeeComponents& from);
  FeeComponents(FeeComponents&& from) noexcept
    : FeeComponents() {
    *this = ::std::move(from);
  }

  inline FeeComponents& operator=(const FeeComponents& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeeComponents& operator=(FeeComponents&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeeComponents& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeeComponents* internal_default_instance() {
    return reinterpret_cast<const FeeComponents*>(
               &_FeeComponents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(FeeComponents& a, FeeComponents& b) {
    a.Swap(&b);
  }
  inline void Swap(FeeComponents* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeeComponents* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeeComponents* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeeComponents>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeeComponents& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeeComponents& from) {
    FeeComponents::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeeComponents* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.FeeComponents";
  }
  protected:
  explicit FeeComponents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinFieldNumber = 1,
    kMaxFieldNumber = 2,
    kConstantFieldNumber = 3,
    kBptFieldNumber = 4,
    kVptFieldNumber = 5,
    kRbhFieldNumber = 6,
    kSbhFieldNumber = 7,
    kGasFieldNumber = 8,
    kTvFieldNumber = 9,
    kBprFieldNumber = 10,
    kSbprFieldNumber = 11,
  };
  // int64 min = 1;
  void clear_min();
  int64_t min() const;
  void set_min(int64_t value);
  private:
  int64_t _internal_min() const;
  void _internal_set_min(int64_t value);
  public:

  // int64 max = 2;
  void clear_max();
  int64_t max() const;
  void set_max(int64_t value);
  private:
  int64_t _internal_max() const;
  void _internal_set_max(int64_t value);
  public:

  // int64 constant = 3;
  void clear_constant();
  int64_t constant() const;
  void set_constant(int64_t value);
  private:
  int64_t _internal_constant() const;
  void _internal_set_constant(int64_t value);
  public:

  // int64 bpt = 4;
  void clear_bpt();
  int64_t bpt() const;
  void set_bpt(int64_t value);
  private:
  int64_t _internal_bpt() const;
  void _internal_set_bpt(int64_t value);
  public:

  // int64 vpt = 5;
  void clear_vpt();
  int64_t vpt() const;
  void set_vpt(int64_t value);
  private:
  int64_t _internal_vpt() const;
  void _internal_set_vpt(int64_t value);
  public:

  // int64 rbh = 6;
  void clear_rbh();
  int64_t rbh() const;
  void set_rbh(int64_t value);
  private:
  int64_t _internal_rbh() const;
  void _internal_set_rbh(int64_t value);
  public:

  // int64 sbh = 7;
  void clear_sbh();
  int64_t sbh() const;
  void set_sbh(int64_t value);
  private:
  int64_t _internal_sbh() const;
  void _internal_set_sbh(int64_t value);
  public:

  // int64 gas = 8;
  void clear_gas();
  int64_t gas() const;
  void set_gas(int64_t value);
  private:
  int64_t _internal_gas() const;
  void _internal_set_gas(int64_t value);
  public:

  // int64 tv = 9;
  void clear_tv();
  int64_t tv() const;
  void set_tv(int64_t value);
  private:
  int64_t _internal_tv() const;
  void _internal_set_tv(int64_t value);
  public:

  // int64 bpr = 10;
  void clear_bpr();
  int64_t bpr() const;
  void set_bpr(int64_t value);
  private:
  int64_t _internal_bpr() const;
  void _internal_set_bpr(int64_t value);
  public:

  // int64 sbpr = 11;
  void clear_sbpr();
  int64_t sbpr() const;
  void set_sbpr(int64_t value);
  private:
  int64_t _internal_sbpr() const;
  void _internal_set_sbpr(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.FeeComponents)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t min_;
    int64_t max_;
    int64_t constant_;
    int64_t bpt_;
    int64_t vpt_;
    int64_t rbh_;
    int64_t sbh_;
    int64_t gas_;
    int64_t tv_;
    int64_t bpr_;
    int64_t sbpr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class TransactionFeeSchedule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.TransactionFeeSchedule) */ {
 public:
  inline TransactionFeeSchedule() : TransactionFeeSchedule(nullptr) {}
  ~TransactionFeeSchedule() override;
  explicit PROTOBUF_CONSTEXPR TransactionFeeSchedule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionFeeSchedule(const TransactionFeeSchedule& from);
  TransactionFeeSchedule(TransactionFeeSchedule&& from) noexcept
    : TransactionFeeSchedule() {
    *this = ::std::move(from);
  }

  inline TransactionFeeSchedule& operator=(const TransactionFeeSchedule& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionFeeSchedule& operator=(TransactionFeeSchedule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionFeeSchedule& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionFeeSchedule* internal_default_instance() {
    return reinterpret_cast<const TransactionFeeSchedule*>(
               &_TransactionFeeSchedule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(TransactionFeeSchedule& a, TransactionFeeSchedule& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionFeeSchedule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionFeeSchedule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionFeeSchedule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionFeeSchedule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionFeeSchedule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransactionFeeSchedule& from) {
    TransactionFeeSchedule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionFeeSchedule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.TransactionFeeSchedule";
  }
  protected:
  explicit TransactionFeeSchedule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeesFieldNumber = 3,
    kFeeDataFieldNumber = 2,
    kHederaFunctionalityFieldNumber = 1,
  };
  // repeated .proto.FeeData fees = 3;
  int fees_size() const;
  private:
  int _internal_fees_size() const;
  public:
  void clear_fees();
  ::proto::FeeData* mutable_fees(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::FeeData >*
      mutable_fees();
  private:
  const ::proto::FeeData& _internal_fees(int index) const;
  ::proto::FeeData* _internal_add_fees();
  public:
  const ::proto::FeeData& fees(int index) const;
  ::proto::FeeData* add_fees();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::FeeData >&
      fees() const;

  // .proto.FeeData feeData = 2 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_feedata() const;
  private:
  bool _internal_has_feedata() const;
  public:
  PROTOBUF_DEPRECATED void clear_feedata();
  PROTOBUF_DEPRECATED const ::proto::FeeData& feedata() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::proto::FeeData* release_feedata();
  PROTOBUF_DEPRECATED ::proto::FeeData* mutable_feedata();
  PROTOBUF_DEPRECATED void set_allocated_feedata(::proto::FeeData* feedata);
  private:
  const ::proto::FeeData& _internal_feedata() const;
  ::proto::FeeData* _internal_mutable_feedata();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_feedata(
      ::proto::FeeData* feedata);
  PROTOBUF_DEPRECATED ::proto::FeeData* unsafe_arena_release_feedata();

  // .proto.HederaFunctionality hederaFunctionality = 1;
  void clear_hederafunctionality();
  ::proto::HederaFunctionality hederafunctionality() const;
  void set_hederafunctionality(::proto::HederaFunctionality value);
  private:
  ::proto::HederaFunctionality _internal_hederafunctionality() const;
  void _internal_set_hederafunctionality(::proto::HederaFunctionality value);
  public:

  // @@protoc_insertion_point(class_scope:proto.TransactionFeeSchedule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::FeeData > fees_;
    ::proto::FeeData* feedata_;
    int hederafunctionality_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class FeeData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.FeeData) */ {
 public:
  inline FeeData() : FeeData(nullptr) {}
  ~FeeData() override;
  explicit PROTOBUF_CONSTEXPR FeeData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeeData(const FeeData& from);
  FeeData(FeeData&& from) noexcept
    : FeeData() {
    *this = ::std::move(from);
  }

  inline FeeData& operator=(const FeeData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeeData& operator=(FeeData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeeData& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeeData* internal_default_instance() {
    return reinterpret_cast<const FeeData*>(
               &_FeeData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(FeeData& a, FeeData& b) {
    a.Swap(&b);
  }
  inline void Swap(FeeData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeeData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeeData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeeData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeeData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeeData& from) {
    FeeData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeeData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.FeeData";
  }
  protected:
  explicit FeeData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodedataFieldNumber = 1,
    kNetworkdataFieldNumber = 2,
    kServicedataFieldNumber = 3,
    kSubTypeFieldNumber = 4,
  };
  // .proto.FeeComponents nodedata = 1;
  bool has_nodedata() const;
  private:
  bool _internal_has_nodedata() const;
  public:
  void clear_nodedata();
  const ::proto::FeeComponents& nodedata() const;
  PROTOBUF_NODISCARD ::proto::FeeComponents* release_nodedata();
  ::proto::FeeComponents* mutable_nodedata();
  void set_allocated_nodedata(::proto::FeeComponents* nodedata);
  private:
  const ::proto::FeeComponents& _internal_nodedata() const;
  ::proto::FeeComponents* _internal_mutable_nodedata();
  public:
  void unsafe_arena_set_allocated_nodedata(
      ::proto::FeeComponents* nodedata);
  ::proto::FeeComponents* unsafe_arena_release_nodedata();

  // .proto.FeeComponents networkdata = 2;
  bool has_networkdata() const;
  private:
  bool _internal_has_networkdata() const;
  public:
  void clear_networkdata();
  const ::proto::FeeComponents& networkdata() const;
  PROTOBUF_NODISCARD ::proto::FeeComponents* release_networkdata();
  ::proto::FeeComponents* mutable_networkdata();
  void set_allocated_networkdata(::proto::FeeComponents* networkdata);
  private:
  const ::proto::FeeComponents& _internal_networkdata() const;
  ::proto::FeeComponents* _internal_mutable_networkdata();
  public:
  void unsafe_arena_set_allocated_networkdata(
      ::proto::FeeComponents* networkdata);
  ::proto::FeeComponents* unsafe_arena_release_networkdata();

  // .proto.FeeComponents servicedata = 3;
  bool has_servicedata() const;
  private:
  bool _internal_has_servicedata() const;
  public:
  void clear_servicedata();
  const ::proto::FeeComponents& servicedata() const;
  PROTOBUF_NODISCARD ::proto::FeeComponents* release_servicedata();
  ::proto::FeeComponents* mutable_servicedata();
  void set_allocated_servicedata(::proto::FeeComponents* servicedata);
  private:
  const ::proto::FeeComponents& _internal_servicedata() const;
  ::proto::FeeComponents* _internal_mutable_servicedata();
  public:
  void unsafe_arena_set_allocated_servicedata(
      ::proto::FeeComponents* servicedata);
  ::proto::FeeComponents* unsafe_arena_release_servicedata();

  // .proto.SubType subType = 4;
  void clear_subtype();
  ::proto::SubType subtype() const;
  void set_subtype(::proto::SubType value);
  private:
  ::proto::SubType _internal_subtype() const;
  void _internal_set_subtype(::proto::SubType value);
  public:

  // @@protoc_insertion_point(class_scope:proto.FeeData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::FeeComponents* nodedata_;
    ::proto::FeeComponents* networkdata_;
    ::proto::FeeComponents* servicedata_;
    int subtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class FeeSchedule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.FeeSchedule) */ {
 public:
  inline FeeSchedule() : FeeSchedule(nullptr) {}
  ~FeeSchedule() override;
  explicit PROTOBUF_CONSTEXPR FeeSchedule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeeSchedule(const FeeSchedule& from);
  FeeSchedule(FeeSchedule&& from) noexcept
    : FeeSchedule() {
    *this = ::std::move(from);
  }

  inline FeeSchedule& operator=(const FeeSchedule& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeeSchedule& operator=(FeeSchedule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeeSchedule& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeeSchedule* internal_default_instance() {
    return reinterpret_cast<const FeeSchedule*>(
               &_FeeSchedule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(FeeSchedule& a, FeeSchedule& b) {
    a.Swap(&b);
  }
  inline void Swap(FeeSchedule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeeSchedule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeeSchedule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeeSchedule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeeSchedule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeeSchedule& from) {
    FeeSchedule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeeSchedule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.FeeSchedule";
  }
  protected:
  explicit FeeSchedule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionFeeScheduleFieldNumber = 1,
    kExpiryTimeFieldNumber = 2,
  };
  // repeated .proto.TransactionFeeSchedule transactionFeeSchedule = 1;
  int transactionfeeschedule_size() const;
  private:
  int _internal_transactionfeeschedule_size() const;
  public:
  void clear_transactionfeeschedule();
  ::proto::TransactionFeeSchedule* mutable_transactionfeeschedule(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TransactionFeeSchedule >*
      mutable_transactionfeeschedule();
  private:
  const ::proto::TransactionFeeSchedule& _internal_transactionfeeschedule(int index) const;
  ::proto::TransactionFeeSchedule* _internal_add_transactionfeeschedule();
  public:
  const ::proto::TransactionFeeSchedule& transactionfeeschedule(int index) const;
  ::proto::TransactionFeeSchedule* add_transactionfeeschedule();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TransactionFeeSchedule >&
      transactionfeeschedule() const;

  // .proto.TimestampSeconds expiryTime = 2;
  bool has_expirytime() const;
  private:
  bool _internal_has_expirytime() const;
  public:
  void clear_expirytime();
  const ::proto::TimestampSeconds& expirytime() const;
  PROTOBUF_NODISCARD ::proto::TimestampSeconds* release_expirytime();
  ::proto::TimestampSeconds* mutable_expirytime();
  void set_allocated_expirytime(::proto::TimestampSeconds* expirytime);
  private:
  const ::proto::TimestampSeconds& _internal_expirytime() const;
  ::proto::TimestampSeconds* _internal_mutable_expirytime();
  public:
  void unsafe_arena_set_allocated_expirytime(
      ::proto::TimestampSeconds* expirytime);
  ::proto::TimestampSeconds* unsafe_arena_release_expirytime();

  // @@protoc_insertion_point(class_scope:proto.FeeSchedule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TransactionFeeSchedule > transactionfeeschedule_;
    ::proto::TimestampSeconds* expirytime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class CurrentAndNextFeeSchedule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.CurrentAndNextFeeSchedule) */ {
 public:
  inline CurrentAndNextFeeSchedule() : CurrentAndNextFeeSchedule(nullptr) {}
  ~CurrentAndNextFeeSchedule() override;
  explicit PROTOBUF_CONSTEXPR CurrentAndNextFeeSchedule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CurrentAndNextFeeSchedule(const CurrentAndNextFeeSchedule& from);
  CurrentAndNextFeeSchedule(CurrentAndNextFeeSchedule&& from) noexcept
    : CurrentAndNextFeeSchedule() {
    *this = ::std::move(from);
  }

  inline CurrentAndNextFeeSchedule& operator=(const CurrentAndNextFeeSchedule& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrentAndNextFeeSchedule& operator=(CurrentAndNextFeeSchedule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurrentAndNextFeeSchedule& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurrentAndNextFeeSchedule* internal_default_instance() {
    return reinterpret_cast<const CurrentAndNextFeeSchedule*>(
               &_CurrentAndNextFeeSchedule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CurrentAndNextFeeSchedule& a, CurrentAndNextFeeSchedule& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrentAndNextFeeSchedule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrentAndNextFeeSchedule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurrentAndNextFeeSchedule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CurrentAndNextFeeSchedule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CurrentAndNextFeeSchedule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CurrentAndNextFeeSchedule& from) {
    CurrentAndNextFeeSchedule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrentAndNextFeeSchedule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.CurrentAndNextFeeSchedule";
  }
  protected:
  explicit CurrentAndNextFeeSchedule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentFeeScheduleFieldNumber = 1,
    kNextFeeScheduleFieldNumber = 2,
  };
  // .proto.FeeSchedule currentFeeSchedule = 1;
  bool has_currentfeeschedule() const;
  private:
  bool _internal_has_currentfeeschedule() const;
  public:
  void clear_currentfeeschedule();
  const ::proto::FeeSchedule& currentfeeschedule() const;
  PROTOBUF_NODISCARD ::proto::FeeSchedule* release_currentfeeschedule();
  ::proto::FeeSchedule* mutable_currentfeeschedule();
  void set_allocated_currentfeeschedule(::proto::FeeSchedule* currentfeeschedule);
  private:
  const ::proto::FeeSchedule& _internal_currentfeeschedule() const;
  ::proto::FeeSchedule* _internal_mutable_currentfeeschedule();
  public:
  void unsafe_arena_set_allocated_currentfeeschedule(
      ::proto::FeeSchedule* currentfeeschedule);
  ::proto::FeeSchedule* unsafe_arena_release_currentfeeschedule();

  // .proto.FeeSchedule nextFeeSchedule = 2;
  bool has_nextfeeschedule() const;
  private:
  bool _internal_has_nextfeeschedule() const;
  public:
  void clear_nextfeeschedule();
  const ::proto::FeeSchedule& nextfeeschedule() const;
  PROTOBUF_NODISCARD ::proto::FeeSchedule* release_nextfeeschedule();
  ::proto::FeeSchedule* mutable_nextfeeschedule();
  void set_allocated_nextfeeschedule(::proto::FeeSchedule* nextfeeschedule);
  private:
  const ::proto::FeeSchedule& _internal_nextfeeschedule() const;
  ::proto::FeeSchedule* _internal_mutable_nextfeeschedule();
  public:
  void unsafe_arena_set_allocated_nextfeeschedule(
      ::proto::FeeSchedule* nextfeeschedule);
  ::proto::FeeSchedule* unsafe_arena_release_nextfeeschedule();

  // @@protoc_insertion_point(class_scope:proto.CurrentAndNextFeeSchedule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::FeeSchedule* currentfeeschedule_;
    ::proto::FeeSchedule* nextfeeschedule_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class ServiceEndpoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ServiceEndpoint) */ {
 public:
  inline ServiceEndpoint() : ServiceEndpoint(nullptr) {}
  ~ServiceEndpoint() override;
  explicit PROTOBUF_CONSTEXPR ServiceEndpoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceEndpoint(const ServiceEndpoint& from);
  ServiceEndpoint(ServiceEndpoint&& from) noexcept
    : ServiceEndpoint() {
    *this = ::std::move(from);
  }

  inline ServiceEndpoint& operator=(const ServiceEndpoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceEndpoint& operator=(ServiceEndpoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceEndpoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceEndpoint* internal_default_instance() {
    return reinterpret_cast<const ServiceEndpoint*>(
               &_ServiceEndpoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ServiceEndpoint& a, ServiceEndpoint& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceEndpoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceEndpoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceEndpoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceEndpoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceEndpoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServiceEndpoint& from) {
    ServiceEndpoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceEndpoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ServiceEndpoint";
  }
  protected:
  explicit ServiceEndpoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpAddressV4FieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // bytes ipAddressV4 = 1;
  void clear_ipaddressv4();
  const std::string& ipaddressv4() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ipaddressv4(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ipaddressv4();
  PROTOBUF_NODISCARD std::string* release_ipaddressv4();
  void set_allocated_ipaddressv4(std::string* ipaddressv4);
  private:
  const std::string& _internal_ipaddressv4() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ipaddressv4(const std::string& value);
  std::string* _internal_mutable_ipaddressv4();
  public:

  // int32 port = 2;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ServiceEndpoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipaddressv4_;
    int32_t port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class NodeAddress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.NodeAddress) */ {
 public:
  inline NodeAddress() : NodeAddress(nullptr) {}
  ~NodeAddress() override;
  explicit PROTOBUF_CONSTEXPR NodeAddress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeAddress(const NodeAddress& from);
  NodeAddress(NodeAddress&& from) noexcept
    : NodeAddress() {
    *this = ::std::move(from);
  }

  inline NodeAddress& operator=(const NodeAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeAddress& operator=(NodeAddress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeAddress& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeAddress* internal_default_instance() {
    return reinterpret_cast<const NodeAddress*>(
               &_NodeAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(NodeAddress& a, NodeAddress& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeAddress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeAddress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeAddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeAddress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeAddress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeAddress& from) {
    NodeAddress::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeAddress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.NodeAddress";
  }
  protected:
  explicit NodeAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceEndpointFieldNumber = 8,
    kIpAddressFieldNumber = 1,
    kMemoFieldNumber = 3,
    kRSAPubKeyFieldNumber = 4,
    kNodeCertHashFieldNumber = 7,
    kDescriptionFieldNumber = 9,
    kNodeAccountIdFieldNumber = 6,
    kNodeIdFieldNumber = 5,
    kStakeFieldNumber = 10,
    kPortnoFieldNumber = 2,
  };
  // repeated .proto.ServiceEndpoint serviceEndpoint = 8;
  int serviceendpoint_size() const;
  private:
  int _internal_serviceendpoint_size() const;
  public:
  void clear_serviceendpoint();
  ::proto::ServiceEndpoint* mutable_serviceendpoint(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ServiceEndpoint >*
      mutable_serviceendpoint();
  private:
  const ::proto::ServiceEndpoint& _internal_serviceendpoint(int index) const;
  ::proto::ServiceEndpoint* _internal_add_serviceendpoint();
  public:
  const ::proto::ServiceEndpoint& serviceendpoint(int index) const;
  ::proto::ServiceEndpoint* add_serviceendpoint();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ServiceEndpoint >&
      serviceendpoint() const;

  // bytes ipAddress = 1 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_ipaddress();
  PROTOBUF_DEPRECATED const std::string& ipaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_ipaddress(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_ipaddress();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_ipaddress();
  PROTOBUF_DEPRECATED void set_allocated_ipaddress(std::string* ipaddress);
  private:
  const std::string& _internal_ipaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ipaddress(const std::string& value);
  std::string* _internal_mutable_ipaddress();
  public:

  // bytes memo = 3 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_memo();
  PROTOBUF_DEPRECATED const std::string& memo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_memo(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_memo();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_memo();
  PROTOBUF_DEPRECATED void set_allocated_memo(std::string* memo);
  private:
  const std::string& _internal_memo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memo(const std::string& value);
  std::string* _internal_mutable_memo();
  public:

  // string RSA_PubKey = 4;
  void clear_rsa_pubkey();
  const std::string& rsa_pubkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rsa_pubkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rsa_pubkey();
  PROTOBUF_NODISCARD std::string* release_rsa_pubkey();
  void set_allocated_rsa_pubkey(std::string* rsa_pubkey);
  private:
  const std::string& _internal_rsa_pubkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rsa_pubkey(const std::string& value);
  std::string* _internal_mutable_rsa_pubkey();
  public:

  // bytes nodeCertHash = 7;
  void clear_nodecerthash();
  const std::string& nodecerthash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nodecerthash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nodecerthash();
  PROTOBUF_NODISCARD std::string* release_nodecerthash();
  void set_allocated_nodecerthash(std::string* nodecerthash);
  private:
  const std::string& _internal_nodecerthash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nodecerthash(const std::string& value);
  std::string* _internal_mutable_nodecerthash();
  public:

  // string description = 9;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .proto.AccountID nodeAccountId = 6;
  bool has_nodeaccountid() const;
  private:
  bool _internal_has_nodeaccountid() const;
  public:
  void clear_nodeaccountid();
  const ::proto::AccountID& nodeaccountid() const;
  PROTOBUF_NODISCARD ::proto::AccountID* release_nodeaccountid();
  ::proto::AccountID* mutable_nodeaccountid();
  void set_allocated_nodeaccountid(::proto::AccountID* nodeaccountid);
  private:
  const ::proto::AccountID& _internal_nodeaccountid() const;
  ::proto::AccountID* _internal_mutable_nodeaccountid();
  public:
  void unsafe_arena_set_allocated_nodeaccountid(
      ::proto::AccountID* nodeaccountid);
  ::proto::AccountID* unsafe_arena_release_nodeaccountid();

  // int64 nodeId = 5;
  void clear_nodeid();
  int64_t nodeid() const;
  void set_nodeid(int64_t value);
  private:
  int64_t _internal_nodeid() const;
  void _internal_set_nodeid(int64_t value);
  public:

  // int64 stake = 10 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_stake();
  PROTOBUF_DEPRECATED int64_t stake() const;
  PROTOBUF_DEPRECATED void set_stake(int64_t value);
  private:
  int64_t _internal_stake() const;
  void _internal_set_stake(int64_t value);
  public:

  // int32 portno = 2 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_portno();
  PROTOBUF_DEPRECATED int32_t portno() const;
  PROTOBUF_DEPRECATED void set_portno(int32_t value);
  private:
  int32_t _internal_portno() const;
  void _internal_set_portno(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.NodeAddress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ServiceEndpoint > serviceendpoint_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipaddress_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rsa_pubkey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodecerthash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::proto::AccountID* nodeaccountid_;
    int64_t nodeid_;
    int64_t stake_;
    int32_t portno_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class NodeAddressBook final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.NodeAddressBook) */ {
 public:
  inline NodeAddressBook() : NodeAddressBook(nullptr) {}
  ~NodeAddressBook() override;
  explicit PROTOBUF_CONSTEXPR NodeAddressBook(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeAddressBook(const NodeAddressBook& from);
  NodeAddressBook(NodeAddressBook&& from) noexcept
    : NodeAddressBook() {
    *this = ::std::move(from);
  }

  inline NodeAddressBook& operator=(const NodeAddressBook& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeAddressBook& operator=(NodeAddressBook&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeAddressBook& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeAddressBook* internal_default_instance() {
    return reinterpret_cast<const NodeAddressBook*>(
               &_NodeAddressBook_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(NodeAddressBook& a, NodeAddressBook& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeAddressBook* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeAddressBook* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeAddressBook* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeAddressBook>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeAddressBook& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeAddressBook& from) {
    NodeAddressBook::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeAddressBook* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.NodeAddressBook";
  }
  protected:
  explicit NodeAddressBook(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeAddressFieldNumber = 1,
  };
  // repeated .proto.NodeAddress nodeAddress = 1;
  int nodeaddress_size() const;
  private:
  int _internal_nodeaddress_size() const;
  public:
  void clear_nodeaddress();
  ::proto::NodeAddress* mutable_nodeaddress(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::NodeAddress >*
      mutable_nodeaddress();
  private:
  const ::proto::NodeAddress& _internal_nodeaddress(int index) const;
  ::proto::NodeAddress* _internal_add_nodeaddress();
  public:
  const ::proto::NodeAddress& nodeaddress(int index) const;
  ::proto::NodeAddress* add_nodeaddress();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::NodeAddress >&
      nodeaddress() const;

  // @@protoc_insertion_point(class_scope:proto.NodeAddressBook)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::NodeAddress > nodeaddress_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class SemanticVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.SemanticVersion) */ {
 public:
  inline SemanticVersion() : SemanticVersion(nullptr) {}
  ~SemanticVersion() override;
  explicit PROTOBUF_CONSTEXPR SemanticVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SemanticVersion(const SemanticVersion& from);
  SemanticVersion(SemanticVersion&& from) noexcept
    : SemanticVersion() {
    *this = ::std::move(from);
  }

  inline SemanticVersion& operator=(const SemanticVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline SemanticVersion& operator=(SemanticVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SemanticVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const SemanticVersion* internal_default_instance() {
    return reinterpret_cast<const SemanticVersion*>(
               &_SemanticVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(SemanticVersion& a, SemanticVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(SemanticVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SemanticVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SemanticVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SemanticVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SemanticVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SemanticVersion& from) {
    SemanticVersion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SemanticVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.SemanticVersion";
  }
  protected:
  explicit SemanticVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPreFieldNumber = 4,
    kBuildFieldNumber = 5,
    kMajorFieldNumber = 1,
    kMinorFieldNumber = 2,
    kPatchFieldNumber = 3,
  };
  // string pre = 4;
  void clear_pre();
  const std::string& pre() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pre(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pre();
  PROTOBUF_NODISCARD std::string* release_pre();
  void set_allocated_pre(std::string* pre);
  private:
  const std::string& _internal_pre() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pre(const std::string& value);
  std::string* _internal_mutable_pre();
  public:

  // string build = 5;
  void clear_build();
  const std::string& build() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_build(ArgT0&& arg0, ArgT... args);
  std::string* mutable_build();
  PROTOBUF_NODISCARD std::string* release_build();
  void set_allocated_build(std::string* build);
  private:
  const std::string& _internal_build() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_build(const std::string& value);
  std::string* _internal_mutable_build();
  public:

  // int32 major = 1;
  void clear_major();
  int32_t major() const;
  void set_major(int32_t value);
  private:
  int32_t _internal_major() const;
  void _internal_set_major(int32_t value);
  public:

  // int32 minor = 2;
  void clear_minor();
  int32_t minor() const;
  void set_minor(int32_t value);
  private:
  int32_t _internal_minor() const;
  void _internal_set_minor(int32_t value);
  public:

  // int32 patch = 3;
  void clear_patch();
  int32_t patch() const;
  void set_patch(int32_t value);
  private:
  int32_t _internal_patch() const;
  void _internal_set_patch(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.SemanticVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pre_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr build_;
    int32_t major_;
    int32_t minor_;
    int32_t patch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class Setting final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Setting) */ {
 public:
  inline Setting() : Setting(nullptr) {}
  ~Setting() override;
  explicit PROTOBUF_CONSTEXPR Setting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Setting(const Setting& from);
  Setting(Setting&& from) noexcept
    : Setting() {
    *this = ::std::move(from);
  }

  inline Setting& operator=(const Setting& from) {
    CopyFrom(from);
    return *this;
  }
  inline Setting& operator=(Setting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Setting& default_instance() {
    return *internal_default_instance();
  }
  static inline const Setting* internal_default_instance() {
    return reinterpret_cast<const Setting*>(
               &_Setting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(Setting& a, Setting& b) {
    a.Swap(&b);
  }
  inline void Swap(Setting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Setting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Setting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Setting>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Setting& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Setting& from) {
    Setting::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Setting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Setting";
  }
  protected:
  explicit Setting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
    kDataFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:proto.Setting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class ServicesConfigurationList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ServicesConfigurationList) */ {
 public:
  inline ServicesConfigurationList() : ServicesConfigurationList(nullptr) {}
  ~ServicesConfigurationList() override;
  explicit PROTOBUF_CONSTEXPR ServicesConfigurationList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServicesConfigurationList(const ServicesConfigurationList& from);
  ServicesConfigurationList(ServicesConfigurationList&& from) noexcept
    : ServicesConfigurationList() {
    *this = ::std::move(from);
  }

  inline ServicesConfigurationList& operator=(const ServicesConfigurationList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServicesConfigurationList& operator=(ServicesConfigurationList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServicesConfigurationList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServicesConfigurationList* internal_default_instance() {
    return reinterpret_cast<const ServicesConfigurationList*>(
               &_ServicesConfigurationList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ServicesConfigurationList& a, ServicesConfigurationList& b) {
    a.Swap(&b);
  }
  inline void Swap(ServicesConfigurationList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServicesConfigurationList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServicesConfigurationList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServicesConfigurationList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServicesConfigurationList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServicesConfigurationList& from) {
    ServicesConfigurationList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServicesConfigurationList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ServicesConfigurationList";
  }
  protected:
  explicit ServicesConfigurationList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameValueFieldNumber = 1,
  };
  // repeated .proto.Setting nameValue = 1;
  int namevalue_size() const;
  private:
  int _internal_namevalue_size() const;
  public:
  void clear_namevalue();
  ::proto::Setting* mutable_namevalue(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Setting >*
      mutable_namevalue();
  private:
  const ::proto::Setting& _internal_namevalue(int index) const;
  ::proto::Setting* _internal_add_namevalue();
  public:
  const ::proto::Setting& namevalue(int index) const;
  ::proto::Setting* add_namevalue();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Setting >&
      namevalue() const;

  // @@protoc_insertion_point(class_scope:proto.ServicesConfigurationList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Setting > namevalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class TokenRelationship final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.TokenRelationship) */ {
 public:
  inline TokenRelationship() : TokenRelationship(nullptr) {}
  ~TokenRelationship() override;
  explicit PROTOBUF_CONSTEXPR TokenRelationship(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenRelationship(const TokenRelationship& from);
  TokenRelationship(TokenRelationship&& from) noexcept
    : TokenRelationship() {
    *this = ::std::move(from);
  }

  inline TokenRelationship& operator=(const TokenRelationship& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenRelationship& operator=(TokenRelationship&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenRelationship& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenRelationship* internal_default_instance() {
    return reinterpret_cast<const TokenRelationship*>(
               &_TokenRelationship_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(TokenRelationship& a, TokenRelationship& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenRelationship* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenRelationship* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenRelationship* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenRelationship>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenRelationship& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenRelationship& from) {
    TokenRelationship::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenRelationship* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.TokenRelationship";
  }
  protected:
  explicit TokenRelationship(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolFieldNumber = 2,
    kTokenIdFieldNumber = 1,
    kBalanceFieldNumber = 3,
    kKycStatusFieldNumber = 4,
    kFreezeStatusFieldNumber = 5,
    kDecimalsFieldNumber = 6,
    kAutomaticAssociationFieldNumber = 7,
  };
  // string symbol = 2;
  void clear_symbol();
  const std::string& symbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_symbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // .proto.TokenID tokenId = 1;
  bool has_tokenid() const;
  private:
  bool _internal_has_tokenid() const;
  public:
  void clear_tokenid();
  const ::proto::TokenID& tokenid() const;
  PROTOBUF_NODISCARD ::proto::TokenID* release_tokenid();
  ::proto::TokenID* mutable_tokenid();
  void set_allocated_tokenid(::proto::TokenID* tokenid);
  private:
  const ::proto::TokenID& _internal_tokenid() const;
  ::proto::TokenID* _internal_mutable_tokenid();
  public:
  void unsafe_arena_set_allocated_tokenid(
      ::proto::TokenID* tokenid);
  ::proto::TokenID* unsafe_arena_release_tokenid();

  // uint64 balance = 3;
  void clear_balance();
  uint64_t balance() const;
  void set_balance(uint64_t value);
  private:
  uint64_t _internal_balance() const;
  void _internal_set_balance(uint64_t value);
  public:

  // .proto.TokenKycStatus kycStatus = 4;
  void clear_kycstatus();
  ::proto::TokenKycStatus kycstatus() const;
  void set_kycstatus(::proto::TokenKycStatus value);
  private:
  ::proto::TokenKycStatus _internal_kycstatus() const;
  void _internal_set_kycstatus(::proto::TokenKycStatus value);
  public:

  // .proto.TokenFreezeStatus freezeStatus = 5;
  void clear_freezestatus();
  ::proto::TokenFreezeStatus freezestatus() const;
  void set_freezestatus(::proto::TokenFreezeStatus value);
  private:
  ::proto::TokenFreezeStatus _internal_freezestatus() const;
  void _internal_set_freezestatus(::proto::TokenFreezeStatus value);
  public:

  // uint32 decimals = 6;
  void clear_decimals();
  uint32_t decimals() const;
  void set_decimals(uint32_t value);
  private:
  uint32_t _internal_decimals() const;
  void _internal_set_decimals(uint32_t value);
  public:

  // bool automatic_association = 7;
  void clear_automatic_association();
  bool automatic_association() const;
  void set_automatic_association(bool value);
  private:
  bool _internal_automatic_association() const;
  void _internal_set_automatic_association(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.TokenRelationship)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
    ::proto::TokenID* tokenid_;
    uint64_t balance_;
    int kycstatus_;
    int freezestatus_;
    uint32_t decimals_;
    bool automatic_association_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class TokenBalance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.TokenBalance) */ {
 public:
  inline TokenBalance() : TokenBalance(nullptr) {}
  ~TokenBalance() override;
  explicit PROTOBUF_CONSTEXPR TokenBalance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenBalance(const TokenBalance& from);
  TokenBalance(TokenBalance&& from) noexcept
    : TokenBalance() {
    *this = ::std::move(from);
  }

  inline TokenBalance& operator=(const TokenBalance& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenBalance& operator=(TokenBalance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenBalance& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenBalance* internal_default_instance() {
    return reinterpret_cast<const TokenBalance*>(
               &_TokenBalance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(TokenBalance& a, TokenBalance& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenBalance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenBalance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenBalance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenBalance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenBalance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenBalance& from) {
    TokenBalance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenBalance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.TokenBalance";
  }
  protected:
  explicit TokenBalance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenIdFieldNumber = 1,
    kBalanceFieldNumber = 2,
    kDecimalsFieldNumber = 3,
  };
  // .proto.TokenID tokenId = 1;
  bool has_tokenid() const;
  private:
  bool _internal_has_tokenid() const;
  public:
  void clear_tokenid();
  const ::proto::TokenID& tokenid() const;
  PROTOBUF_NODISCARD ::proto::TokenID* release_tokenid();
  ::proto::TokenID* mutable_tokenid();
  void set_allocated_tokenid(::proto::TokenID* tokenid);
  private:
  const ::proto::TokenID& _internal_tokenid() const;
  ::proto::TokenID* _internal_mutable_tokenid();
  public:
  void unsafe_arena_set_allocated_tokenid(
      ::proto::TokenID* tokenid);
  ::proto::TokenID* unsafe_arena_release_tokenid();

  // uint64 balance = 2;
  void clear_balance();
  uint64_t balance() const;
  void set_balance(uint64_t value);
  private:
  uint64_t _internal_balance() const;
  void _internal_set_balance(uint64_t value);
  public:

  // uint32 decimals = 3;
  void clear_decimals();
  uint32_t decimals() const;
  void set_decimals(uint32_t value);
  private:
  uint32_t _internal_decimals() const;
  void _internal_set_decimals(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.TokenBalance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::TokenID* tokenid_;
    uint64_t balance_;
    uint32_t decimals_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class TokenBalances final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.TokenBalances) */ {
 public:
  inline TokenBalances() : TokenBalances(nullptr) {}
  ~TokenBalances() override;
  explicit PROTOBUF_CONSTEXPR TokenBalances(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenBalances(const TokenBalances& from);
  TokenBalances(TokenBalances&& from) noexcept
    : TokenBalances() {
    *this = ::std::move(from);
  }

  inline TokenBalances& operator=(const TokenBalances& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenBalances& operator=(TokenBalances&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenBalances& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenBalances* internal_default_instance() {
    return reinterpret_cast<const TokenBalances*>(
               &_TokenBalances_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(TokenBalances& a, TokenBalances& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenBalances* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenBalances* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenBalances* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenBalances>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenBalances& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenBalances& from) {
    TokenBalances::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenBalances* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.TokenBalances";
  }
  protected:
  explicit TokenBalances(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenBalancesFieldNumber = 1,
  };
  // repeated .proto.TokenBalance tokenBalances = 1;
  int tokenbalances_size() const;
  private:
  int _internal_tokenbalances_size() const;
  public:
  void clear_tokenbalances();
  ::proto::TokenBalance* mutable_tokenbalances(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TokenBalance >*
      mutable_tokenbalances();
  private:
  const ::proto::TokenBalance& _internal_tokenbalances(int index) const;
  ::proto::TokenBalance* _internal_add_tokenbalances();
  public:
  const ::proto::TokenBalance& tokenbalances(int index) const;
  ::proto::TokenBalance* add_tokenbalances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TokenBalance >&
      tokenbalances() const;

  // @@protoc_insertion_point(class_scope:proto.TokenBalances)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TokenBalance > tokenbalances_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class TokenAssociation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.TokenAssociation) */ {
 public:
  inline TokenAssociation() : TokenAssociation(nullptr) {}
  ~TokenAssociation() override;
  explicit PROTOBUF_CONSTEXPR TokenAssociation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenAssociation(const TokenAssociation& from);
  TokenAssociation(TokenAssociation&& from) noexcept
    : TokenAssociation() {
    *this = ::std::move(from);
  }

  inline TokenAssociation& operator=(const TokenAssociation& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenAssociation& operator=(TokenAssociation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenAssociation& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenAssociation* internal_default_instance() {
    return reinterpret_cast<const TokenAssociation*>(
               &_TokenAssociation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(TokenAssociation& a, TokenAssociation& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenAssociation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenAssociation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenAssociation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenAssociation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenAssociation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenAssociation& from) {
    TokenAssociation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenAssociation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.TokenAssociation";
  }
  protected:
  explicit TokenAssociation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenIdFieldNumber = 1,
    kAccountIdFieldNumber = 2,
  };
  // .proto.TokenID token_id = 1;
  bool has_token_id() const;
  private:
  bool _internal_has_token_id() const;
  public:
  void clear_token_id();
  const ::proto::TokenID& token_id() const;
  PROTOBUF_NODISCARD ::proto::TokenID* release_token_id();
  ::proto::TokenID* mutable_token_id();
  void set_allocated_token_id(::proto::TokenID* token_id);
  private:
  const ::proto::TokenID& _internal_token_id() const;
  ::proto::TokenID* _internal_mutable_token_id();
  public:
  void unsafe_arena_set_allocated_token_id(
      ::proto::TokenID* token_id);
  ::proto::TokenID* unsafe_arena_release_token_id();

  // .proto.AccountID account_id = 2;
  bool has_account_id() const;
  private:
  bool _internal_has_account_id() const;
  public:
  void clear_account_id();
  const ::proto::AccountID& account_id() const;
  PROTOBUF_NODISCARD ::proto::AccountID* release_account_id();
  ::proto::AccountID* mutable_account_id();
  void set_allocated_account_id(::proto::AccountID* account_id);
  private:
  const ::proto::AccountID& _internal_account_id() const;
  ::proto::AccountID* _internal_mutable_account_id();
  public:
  void unsafe_arena_set_allocated_account_id(
      ::proto::AccountID* account_id);
  ::proto::AccountID* unsafe_arena_release_account_id();

  // @@protoc_insertion_point(class_scope:proto.TokenAssociation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::TokenID* token_id_;
    ::proto::AccountID* account_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class StakingInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.StakingInfo) */ {
 public:
  inline StakingInfo() : StakingInfo(nullptr) {}
  ~StakingInfo() override;
  explicit PROTOBUF_CONSTEXPR StakingInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StakingInfo(const StakingInfo& from);
  StakingInfo(StakingInfo&& from) noexcept
    : StakingInfo() {
    *this = ::std::move(from);
  }

  inline StakingInfo& operator=(const StakingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StakingInfo& operator=(StakingInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StakingInfo& default_instance() {
    return *internal_default_instance();
  }
  enum StakedIdCase {
    kStakedAccountId = 5,
    kStakedNodeId = 6,
    STAKED_ID_NOT_SET = 0,
  };

  static inline const StakingInfo* internal_default_instance() {
    return reinterpret_cast<const StakingInfo*>(
               &_StakingInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(StakingInfo& a, StakingInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StakingInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StakingInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StakingInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StakingInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StakingInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StakingInfo& from) {
    StakingInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StakingInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.StakingInfo";
  }
  protected:
  explicit StakingInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStakePeriodStartFieldNumber = 2,
    kPendingRewardFieldNumber = 3,
    kStakedToMeFieldNumber = 4,
    kDeclineRewardFieldNumber = 1,
    kStakedAccountIdFieldNumber = 5,
    kStakedNodeIdFieldNumber = 6,
  };
  // .proto.Timestamp stake_period_start = 2;
  bool has_stake_period_start() const;
  private:
  bool _internal_has_stake_period_start() const;
  public:
  void clear_stake_period_start();
  const ::proto::Timestamp& stake_period_start() const;
  PROTOBUF_NODISCARD ::proto::Timestamp* release_stake_period_start();
  ::proto::Timestamp* mutable_stake_period_start();
  void set_allocated_stake_period_start(::proto::Timestamp* stake_period_start);
  private:
  const ::proto::Timestamp& _internal_stake_period_start() const;
  ::proto::Timestamp* _internal_mutable_stake_period_start();
  public:
  void unsafe_arena_set_allocated_stake_period_start(
      ::proto::Timestamp* stake_period_start);
  ::proto::Timestamp* unsafe_arena_release_stake_period_start();

  // int64 pending_reward = 3;
  void clear_pending_reward();
  int64_t pending_reward() const;
  void set_pending_reward(int64_t value);
  private:
  int64_t _internal_pending_reward() const;
  void _internal_set_pending_reward(int64_t value);
  public:

  // int64 staked_to_me = 4;
  void clear_staked_to_me();
  int64_t staked_to_me() const;
  void set_staked_to_me(int64_t value);
  private:
  int64_t _internal_staked_to_me() const;
  void _internal_set_staked_to_me(int64_t value);
  public:

  // bool decline_reward = 1;
  void clear_decline_reward();
  bool decline_reward() const;
  void set_decline_reward(bool value);
  private:
  bool _internal_decline_reward() const;
  void _internal_set_decline_reward(bool value);
  public:

  // .proto.AccountID staked_account_id = 5;
  bool has_staked_account_id() const;
  private:
  bool _internal_has_staked_account_id() const;
  public:
  void clear_staked_account_id();
  const ::proto::AccountID& staked_account_id() const;
  PROTOBUF_NODISCARD ::proto::AccountID* release_staked_account_id();
  ::proto::AccountID* mutable_staked_account_id();
  void set_allocated_staked_account_id(::proto::AccountID* staked_account_id);
  private:
  const ::proto::AccountID& _internal_staked_account_id() const;
  ::proto::AccountID* _internal_mutable_staked_account_id();
  public:
  void unsafe_arena_set_allocated_staked_account_id(
      ::proto::AccountID* staked_account_id);
  ::proto::AccountID* unsafe_arena_release_staked_account_id();

  // int64 staked_node_id = 6;
  bool has_staked_node_id() const;
  private:
  bool _internal_has_staked_node_id() const;
  public:
  void clear_staked_node_id();
  int64_t staked_node_id() const;
  void set_staked_node_id(int64_t value);
  private:
  int64_t _internal_staked_node_id() const;
  void _internal_set_staked_node_id(int64_t value);
  public:

  void clear_staked_id();
  StakedIdCase staked_id_case() const;
  // @@protoc_insertion_point(class_scope:proto.StakingInfo)
 private:
  class _Internal;
  void set_has_staked_account_id();
  void set_has_staked_node_id();

  inline bool has_staked_id() const;
  inline void clear_has_staked_id();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::Timestamp* stake_period_start_;
    int64_t pending_reward_;
    int64_t staked_to_me_;
    bool decline_reward_;
    union StakedIdUnion {
      constexpr StakedIdUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::proto::AccountID* staked_account_id_;
      int64_t staked_node_id_;
    } staked_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_basic_5ftypes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ShardID

// int64 shardNum = 1;
inline void ShardID::clear_shardnum() {
  _impl_.shardnum_ = int64_t{0};
}
inline int64_t ShardID::_internal_shardnum() const {
  return _impl_.shardnum_;
}
inline int64_t ShardID::shardnum() const {
  // @@protoc_insertion_point(field_get:proto.ShardID.shardNum)
  return _internal_shardnum();
}
inline void ShardID::_internal_set_shardnum(int64_t value) {
  
  _impl_.shardnum_ = value;
}
inline void ShardID::set_shardnum(int64_t value) {
  _internal_set_shardnum(value);
  // @@protoc_insertion_point(field_set:proto.ShardID.shardNum)
}

// -------------------------------------------------------------------

// RealmID

// int64 shardNum = 1;
inline void RealmID::clear_shardnum() {
  _impl_.shardnum_ = int64_t{0};
}
inline int64_t RealmID::_internal_shardnum() const {
  return _impl_.shardnum_;
}
inline int64_t RealmID::shardnum() const {
  // @@protoc_insertion_point(field_get:proto.RealmID.shardNum)
  return _internal_shardnum();
}
inline void RealmID::_internal_set_shardnum(int64_t value) {
  
  _impl_.shardnum_ = value;
}
inline void RealmID::set_shardnum(int64_t value) {
  _internal_set_shardnum(value);
  // @@protoc_insertion_point(field_set:proto.RealmID.shardNum)
}

// int64 realmNum = 2;
inline void RealmID::clear_realmnum() {
  _impl_.realmnum_ = int64_t{0};
}
inline int64_t RealmID::_internal_realmnum() const {
  return _impl_.realmnum_;
}
inline int64_t RealmID::realmnum() const {
  // @@protoc_insertion_point(field_get:proto.RealmID.realmNum)
  return _internal_realmnum();
}
inline void RealmID::_internal_set_realmnum(int64_t value) {
  
  _impl_.realmnum_ = value;
}
inline void RealmID::set_realmnum(int64_t value) {
  _internal_set_realmnum(value);
  // @@protoc_insertion_point(field_set:proto.RealmID.realmNum)
}

// -------------------------------------------------------------------

// AccountID

// int64 shardNum = 1;
inline void AccountID::clear_shardnum() {
  _impl_.shardnum_ = int64_t{0};
}
inline int64_t AccountID::_internal_shardnum() const {
  return _impl_.shardnum_;
}
inline int64_t AccountID::shardnum() const {
  // @@protoc_insertion_point(field_get:proto.AccountID.shardNum)
  return _internal_shardnum();
}
inline void AccountID::_internal_set_shardnum(int64_t value) {
  
  _impl_.shardnum_ = value;
}
inline void AccountID::set_shardnum(int64_t value) {
  _internal_set_shardnum(value);
  // @@protoc_insertion_point(field_set:proto.AccountID.shardNum)
}

// int64 realmNum = 2;
inline void AccountID::clear_realmnum() {
  _impl_.realmnum_ = int64_t{0};
}
inline int64_t AccountID::_internal_realmnum() const {
  return _impl_.realmnum_;
}
inline int64_t AccountID::realmnum() const {
  // @@protoc_insertion_point(field_get:proto.AccountID.realmNum)
  return _internal_realmnum();
}
inline void AccountID::_internal_set_realmnum(int64_t value) {
  
  _impl_.realmnum_ = value;
}
inline void AccountID::set_realmnum(int64_t value) {
  _internal_set_realmnum(value);
  // @@protoc_insertion_point(field_set:proto.AccountID.realmNum)
}

// int64 accountNum = 3;
inline bool AccountID::_internal_has_accountnum() const {
  return account_case() == kAccountNum;
}
inline bool AccountID::has_accountnum() const {
  return _internal_has_accountnum();
}
inline void AccountID::set_has_accountnum() {
  _impl_._oneof_case_[0] = kAccountNum;
}
inline void AccountID::clear_accountnum() {
  if (_internal_has_accountnum()) {
    _impl_.account_.accountnum_ = int64_t{0};
    clear_has_account();
  }
}
inline int64_t AccountID::_internal_accountnum() const {
  if (_internal_has_accountnum()) {
    return _impl_.account_.accountnum_;
  }
  return int64_t{0};
}
inline void AccountID::_internal_set_accountnum(int64_t value) {
  if (!_internal_has_accountnum()) {
    clear_account();
    set_has_accountnum();
  }
  _impl_.account_.accountnum_ = value;
}
inline int64_t AccountID::accountnum() const {
  // @@protoc_insertion_point(field_get:proto.AccountID.accountNum)
  return _internal_accountnum();
}
inline void AccountID::set_accountnum(int64_t value) {
  _internal_set_accountnum(value);
  // @@protoc_insertion_point(field_set:proto.AccountID.accountNum)
}

// bytes alias = 4;
inline bool AccountID::_internal_has_alias() const {
  return account_case() == kAlias;
}
inline bool AccountID::has_alias() const {
  return _internal_has_alias();
}
inline void AccountID::set_has_alias() {
  _impl_._oneof_case_[0] = kAlias;
}
inline void AccountID::clear_alias() {
  if (_internal_has_alias()) {
    _impl_.account_.alias_.Destroy();
    clear_has_account();
  }
}
inline const std::string& AccountID::alias() const {
  // @@protoc_insertion_point(field_get:proto.AccountID.alias)
  return _internal_alias();
}
template <typename ArgT0, typename... ArgT>
inline void AccountID::set_alias(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_alias()) {
    clear_account();
    set_has_alias();
    _impl_.account_.alias_.InitDefault();
  }
  _impl_.account_.alias_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.AccountID.alias)
}
inline std::string* AccountID::mutable_alias() {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:proto.AccountID.alias)
  return _s;
}
inline const std::string& AccountID::_internal_alias() const {
  if (_internal_has_alias()) {
    return _impl_.account_.alias_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AccountID::_internal_set_alias(const std::string& value) {
  if (!_internal_has_alias()) {
    clear_account();
    set_has_alias();
    _impl_.account_.alias_.InitDefault();
  }
  _impl_.account_.alias_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountID::_internal_mutable_alias() {
  if (!_internal_has_alias()) {
    clear_account();
    set_has_alias();
    _impl_.account_.alias_.InitDefault();
  }
  return _impl_.account_.alias_.Mutable(      GetArenaForAllocation());
}
inline std::string* AccountID::release_alias() {
  // @@protoc_insertion_point(field_release:proto.AccountID.alias)
  if (_internal_has_alias()) {
    clear_has_account();
    return _impl_.account_.alias_.Release();
  } else {
    return nullptr;
  }
}
inline void AccountID::set_allocated_alias(std::string* alias) {
  if (has_account()) {
    clear_account();
  }
  if (alias != nullptr) {
    set_has_alias();
    _impl_.account_.alias_.InitAllocated(alias, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.AccountID.alias)
}

inline bool AccountID::has_account() const {
  return account_case() != ACCOUNT_NOT_SET;
}
inline void AccountID::clear_has_account() {
  _impl_._oneof_case_[0] = ACCOUNT_NOT_SET;
}
inline AccountID::AccountCase AccountID::account_case() const {
  return AccountID::AccountCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FileID

// int64 shardNum = 1;
inline void FileID::clear_shardnum() {
  _impl_.shardnum_ = int64_t{0};
}
inline int64_t FileID::_internal_shardnum() const {
  return _impl_.shardnum_;
}
inline int64_t FileID::shardnum() const {
  // @@protoc_insertion_point(field_get:proto.FileID.shardNum)
  return _internal_shardnum();
}
inline void FileID::_internal_set_shardnum(int64_t value) {
  
  _impl_.shardnum_ = value;
}
inline void FileID::set_shardnum(int64_t value) {
  _internal_set_shardnum(value);
  // @@protoc_insertion_point(field_set:proto.FileID.shardNum)
}

// int64 realmNum = 2;
inline void FileID::clear_realmnum() {
  _impl_.realmnum_ = int64_t{0};
}
inline int64_t FileID::_internal_realmnum() const {
  return _impl_.realmnum_;
}
inline int64_t FileID::realmnum() const {
  // @@protoc_insertion_point(field_get:proto.FileID.realmNum)
  return _internal_realmnum();
}
inline void FileID::_internal_set_realmnum(int64_t value) {
  
  _impl_.realmnum_ = value;
}
inline void FileID::set_realmnum(int64_t value) {
  _internal_set_realmnum(value);
  // @@protoc_insertion_point(field_set:proto.FileID.realmNum)
}

// int64 fileNum = 3;
inline void FileID::clear_filenum() {
  _impl_.filenum_ = int64_t{0};
}
inline int64_t FileID::_internal_filenum() const {
  return _impl_.filenum_;
}
inline int64_t FileID::filenum() const {
  // @@protoc_insertion_point(field_get:proto.FileID.fileNum)
  return _internal_filenum();
}
inline void FileID::_internal_set_filenum(int64_t value) {
  
  _impl_.filenum_ = value;
}
inline void FileID::set_filenum(int64_t value) {
  _internal_set_filenum(value);
  // @@protoc_insertion_point(field_set:proto.FileID.fileNum)
}

// -------------------------------------------------------------------

// ContractID

// int64 shardNum = 1;
inline void ContractID::clear_shardnum() {
  _impl_.shardnum_ = int64_t{0};
}
inline int64_t ContractID::_internal_shardnum() const {
  return _impl_.shardnum_;
}
inline int64_t ContractID::shardnum() const {
  // @@protoc_insertion_point(field_get:proto.ContractID.shardNum)
  return _internal_shardnum();
}
inline void ContractID::_internal_set_shardnum(int64_t value) {
  
  _impl_.shardnum_ = value;
}
inline void ContractID::set_shardnum(int64_t value) {
  _internal_set_shardnum(value);
  // @@protoc_insertion_point(field_set:proto.ContractID.shardNum)
}

// int64 realmNum = 2;
inline void ContractID::clear_realmnum() {
  _impl_.realmnum_ = int64_t{0};
}
inline int64_t ContractID::_internal_realmnum() const {
  return _impl_.realmnum_;
}
inline int64_t ContractID::realmnum() const {
  // @@protoc_insertion_point(field_get:proto.ContractID.realmNum)
  return _internal_realmnum();
}
inline void ContractID::_internal_set_realmnum(int64_t value) {
  
  _impl_.realmnum_ = value;
}
inline void ContractID::set_realmnum(int64_t value) {
  _internal_set_realmnum(value);
  // @@protoc_insertion_point(field_set:proto.ContractID.realmNum)
}

// int64 contractNum = 3;
inline bool ContractID::_internal_has_contractnum() const {
  return contract_case() == kContractNum;
}
inline bool ContractID::has_contractnum() const {
  return _internal_has_contractnum();
}
inline void ContractID::set_has_contractnum() {
  _impl_._oneof_case_[0] = kContractNum;
}
inline void ContractID::clear_contractnum() {
  if (_internal_has_contractnum()) {
    _impl_.contract_.contractnum_ = int64_t{0};
    clear_has_contract();
  }
}
inline int64_t ContractID::_internal_contractnum() const {
  if (_internal_has_contractnum()) {
    return _impl_.contract_.contractnum_;
  }
  return int64_t{0};
}
inline void ContractID::_internal_set_contractnum(int64_t value) {
  if (!_internal_has_contractnum()) {
    clear_contract();
    set_has_contractnum();
  }
  _impl_.contract_.contractnum_ = value;
}
inline int64_t ContractID::contractnum() const {
  // @@protoc_insertion_point(field_get:proto.ContractID.contractNum)
  return _internal_contractnum();
}
inline void ContractID::set_contractnum(int64_t value) {
  _internal_set_contractnum(value);
  // @@protoc_insertion_point(field_set:proto.ContractID.contractNum)
}

// bytes evm_address = 4;
inline bool ContractID::_internal_has_evm_address() const {
  return contract_case() == kEvmAddress;
}
inline bool ContractID::has_evm_address() const {
  return _internal_has_evm_address();
}
inline void ContractID::set_has_evm_address() {
  _impl_._oneof_case_[0] = kEvmAddress;
}
inline void ContractID::clear_evm_address() {
  if (_internal_has_evm_address()) {
    _impl_.contract_.evm_address_.Destroy();
    clear_has_contract();
  }
}
inline const std::string& ContractID::evm_address() const {
  // @@protoc_insertion_point(field_get:proto.ContractID.evm_address)
  return _internal_evm_address();
}
template <typename ArgT0, typename... ArgT>
inline void ContractID::set_evm_address(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_evm_address()) {
    clear_contract();
    set_has_evm_address();
    _impl_.contract_.evm_address_.InitDefault();
  }
  _impl_.contract_.evm_address_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ContractID.evm_address)
}
inline std::string* ContractID::mutable_evm_address() {
  std::string* _s = _internal_mutable_evm_address();
  // @@protoc_insertion_point(field_mutable:proto.ContractID.evm_address)
  return _s;
}
inline const std::string& ContractID::_internal_evm_address() const {
  if (_internal_has_evm_address()) {
    return _impl_.contract_.evm_address_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ContractID::_internal_set_evm_address(const std::string& value) {
  if (!_internal_has_evm_address()) {
    clear_contract();
    set_has_evm_address();
    _impl_.contract_.evm_address_.InitDefault();
  }
  _impl_.contract_.evm_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractID::_internal_mutable_evm_address() {
  if (!_internal_has_evm_address()) {
    clear_contract();
    set_has_evm_address();
    _impl_.contract_.evm_address_.InitDefault();
  }
  return _impl_.contract_.evm_address_.Mutable(      GetArenaForAllocation());
}
inline std::string* ContractID::release_evm_address() {
  // @@protoc_insertion_point(field_release:proto.ContractID.evm_address)
  if (_internal_has_evm_address()) {
    clear_has_contract();
    return _impl_.contract_.evm_address_.Release();
  } else {
    return nullptr;
  }
}
inline void ContractID::set_allocated_evm_address(std::string* evm_address) {
  if (has_contract()) {
    clear_contract();
  }
  if (evm_address != nullptr) {
    set_has_evm_address();
    _impl_.contract_.evm_address_.InitAllocated(evm_address, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ContractID.evm_address)
}

inline bool ContractID::has_contract() const {
  return contract_case() != CONTRACT_NOT_SET;
}
inline void ContractID::clear_has_contract() {
  _impl_._oneof_case_[0] = CONTRACT_NOT_SET;
}
inline ContractID::ContractCase ContractID::contract_case() const {
  return ContractID::ContractCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TransactionID

// .proto.Timestamp transactionValidStart = 1;
inline bool TransactionID::_internal_has_transactionvalidstart() const {
  return this != internal_default_instance() && _impl_.transactionvalidstart_ != nullptr;
}
inline bool TransactionID::has_transactionvalidstart() const {
  return _internal_has_transactionvalidstart();
}
inline const ::proto::Timestamp& TransactionID::_internal_transactionvalidstart() const {
  const ::proto::Timestamp* p = _impl_.transactionvalidstart_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Timestamp&>(
      ::proto::_Timestamp_default_instance_);
}
inline const ::proto::Timestamp& TransactionID::transactionvalidstart() const {
  // @@protoc_insertion_point(field_get:proto.TransactionID.transactionValidStart)
  return _internal_transactionvalidstart();
}
inline void TransactionID::unsafe_arena_set_allocated_transactionvalidstart(
    ::proto::Timestamp* transactionvalidstart) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transactionvalidstart_);
  }
  _impl_.transactionvalidstart_ = transactionvalidstart;
  if (transactionvalidstart) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionID.transactionValidStart)
}
inline ::proto::Timestamp* TransactionID::release_transactionvalidstart() {
  
  ::proto::Timestamp* temp = _impl_.transactionvalidstart_;
  _impl_.transactionvalidstart_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Timestamp* TransactionID::unsafe_arena_release_transactionvalidstart() {
  // @@protoc_insertion_point(field_release:proto.TransactionID.transactionValidStart)
  
  ::proto::Timestamp* temp = _impl_.transactionvalidstart_;
  _impl_.transactionvalidstart_ = nullptr;
  return temp;
}
inline ::proto::Timestamp* TransactionID::_internal_mutable_transactionvalidstart() {
  
  if (_impl_.transactionvalidstart_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Timestamp>(GetArenaForAllocation());
    _impl_.transactionvalidstart_ = p;
  }
  return _impl_.transactionvalidstart_;
}
inline ::proto::Timestamp* TransactionID::mutable_transactionvalidstart() {
  ::proto::Timestamp* _msg = _internal_mutable_transactionvalidstart();
  // @@protoc_insertion_point(field_mutable:proto.TransactionID.transactionValidStart)
  return _msg;
}
inline void TransactionID::set_allocated_transactionvalidstart(::proto::Timestamp* transactionvalidstart) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transactionvalidstart_);
  }
  if (transactionvalidstart) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transactionvalidstart));
    if (message_arena != submessage_arena) {
      transactionvalidstart = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transactionvalidstart, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transactionvalidstart_ = transactionvalidstart;
  // @@protoc_insertion_point(field_set_allocated:proto.TransactionID.transactionValidStart)
}

// .proto.AccountID accountID = 2;
inline bool TransactionID::_internal_has_accountid() const {
  return this != internal_default_instance() && _impl_.accountid_ != nullptr;
}
inline bool TransactionID::has_accountid() const {
  return _internal_has_accountid();
}
inline void TransactionID::clear_accountid() {
  if (GetArenaForAllocation() == nullptr && _impl_.accountid_ != nullptr) {
    delete _impl_.accountid_;
  }
  _impl_.accountid_ = nullptr;
}
inline const ::proto::AccountID& TransactionID::_internal_accountid() const {
  const ::proto::AccountID* p = _impl_.accountid_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AccountID&>(
      ::proto::_AccountID_default_instance_);
}
inline const ::proto::AccountID& TransactionID::accountid() const {
  // @@protoc_insertion_point(field_get:proto.TransactionID.accountID)
  return _internal_accountid();
}
inline void TransactionID::unsafe_arena_set_allocated_accountid(
    ::proto::AccountID* accountid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.accountid_);
  }
  _impl_.accountid_ = accountid;
  if (accountid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionID.accountID)
}
inline ::proto::AccountID* TransactionID::release_accountid() {
  
  ::proto::AccountID* temp = _impl_.accountid_;
  _impl_.accountid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AccountID* TransactionID::unsafe_arena_release_accountid() {
  // @@protoc_insertion_point(field_release:proto.TransactionID.accountID)
  
  ::proto::AccountID* temp = _impl_.accountid_;
  _impl_.accountid_ = nullptr;
  return temp;
}
inline ::proto::AccountID* TransactionID::_internal_mutable_accountid() {
  
  if (_impl_.accountid_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AccountID>(GetArenaForAllocation());
    _impl_.accountid_ = p;
  }
  return _impl_.accountid_;
}
inline ::proto::AccountID* TransactionID::mutable_accountid() {
  ::proto::AccountID* _msg = _internal_mutable_accountid();
  // @@protoc_insertion_point(field_mutable:proto.TransactionID.accountID)
  return _msg;
}
inline void TransactionID::set_allocated_accountid(::proto::AccountID* accountid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.accountid_;
  }
  if (accountid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(accountid);
    if (message_arena != submessage_arena) {
      accountid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, accountid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.accountid_ = accountid;
  // @@protoc_insertion_point(field_set_allocated:proto.TransactionID.accountID)
}

// bool scheduled = 3;
inline void TransactionID::clear_scheduled() {
  _impl_.scheduled_ = false;
}
inline bool TransactionID::_internal_scheduled() const {
  return _impl_.scheduled_;
}
inline bool TransactionID::scheduled() const {
  // @@protoc_insertion_point(field_get:proto.TransactionID.scheduled)
  return _internal_scheduled();
}
inline void TransactionID::_internal_set_scheduled(bool value) {
  
  _impl_.scheduled_ = value;
}
inline void TransactionID::set_scheduled(bool value) {
  _internal_set_scheduled(value);
  // @@protoc_insertion_point(field_set:proto.TransactionID.scheduled)
}

// int32 nonce = 4;
inline void TransactionID::clear_nonce() {
  _impl_.nonce_ = 0;
}
inline int32_t TransactionID::_internal_nonce() const {
  return _impl_.nonce_;
}
inline int32_t TransactionID::nonce() const {
  // @@protoc_insertion_point(field_get:proto.TransactionID.nonce)
  return _internal_nonce();
}
inline void TransactionID::_internal_set_nonce(int32_t value) {
  
  _impl_.nonce_ = value;
}
inline void TransactionID::set_nonce(int32_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:proto.TransactionID.nonce)
}

// -------------------------------------------------------------------

// AccountAmount

// .proto.AccountID accountID = 1;
inline bool AccountAmount::_internal_has_accountid() const {
  return this != internal_default_instance() && _impl_.accountid_ != nullptr;
}
inline bool AccountAmount::has_accountid() const {
  return _internal_has_accountid();
}
inline void AccountAmount::clear_accountid() {
  if (GetArenaForAllocation() == nullptr && _impl_.accountid_ != nullptr) {
    delete _impl_.accountid_;
  }
  _impl_.accountid_ = nullptr;
}
inline const ::proto::AccountID& AccountAmount::_internal_accountid() const {
  const ::proto::AccountID* p = _impl_.accountid_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AccountID&>(
      ::proto::_AccountID_default_instance_);
}
inline const ::proto::AccountID& AccountAmount::accountid() const {
  // @@protoc_insertion_point(field_get:proto.AccountAmount.accountID)
  return _internal_accountid();
}
inline void AccountAmount::unsafe_arena_set_allocated_accountid(
    ::proto::AccountID* accountid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.accountid_);
  }
  _impl_.accountid_ = accountid;
  if (accountid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.AccountAmount.accountID)
}
inline ::proto::AccountID* AccountAmount::release_accountid() {
  
  ::proto::AccountID* temp = _impl_.accountid_;
  _impl_.accountid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AccountID* AccountAmount::unsafe_arena_release_accountid() {
  // @@protoc_insertion_point(field_release:proto.AccountAmount.accountID)
  
  ::proto::AccountID* temp = _impl_.accountid_;
  _impl_.accountid_ = nullptr;
  return temp;
}
inline ::proto::AccountID* AccountAmount::_internal_mutable_accountid() {
  
  if (_impl_.accountid_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AccountID>(GetArenaForAllocation());
    _impl_.accountid_ = p;
  }
  return _impl_.accountid_;
}
inline ::proto::AccountID* AccountAmount::mutable_accountid() {
  ::proto::AccountID* _msg = _internal_mutable_accountid();
  // @@protoc_insertion_point(field_mutable:proto.AccountAmount.accountID)
  return _msg;
}
inline void AccountAmount::set_allocated_accountid(::proto::AccountID* accountid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.accountid_;
  }
  if (accountid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(accountid);
    if (message_arena != submessage_arena) {
      accountid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, accountid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.accountid_ = accountid;
  // @@protoc_insertion_point(field_set_allocated:proto.AccountAmount.accountID)
}

// sint64 amount = 2;
inline void AccountAmount::clear_amount() {
  _impl_.amount_ = int64_t{0};
}
inline int64_t AccountAmount::_internal_amount() const {
  return _impl_.amount_;
}
inline int64_t AccountAmount::amount() const {
  // @@protoc_insertion_point(field_get:proto.AccountAmount.amount)
  return _internal_amount();
}
inline void AccountAmount::_internal_set_amount(int64_t value) {
  
  _impl_.amount_ = value;
}
inline void AccountAmount::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:proto.AccountAmount.amount)
}

// bool is_approval = 3;
inline void AccountAmount::clear_is_approval() {
  _impl_.is_approval_ = false;
}
inline bool AccountAmount::_internal_is_approval() const {
  return _impl_.is_approval_;
}
inline bool AccountAmount::is_approval() const {
  // @@protoc_insertion_point(field_get:proto.AccountAmount.is_approval)
  return _internal_is_approval();
}
inline void AccountAmount::_internal_set_is_approval(bool value) {
  
  _impl_.is_approval_ = value;
}
inline void AccountAmount::set_is_approval(bool value) {
  _internal_set_is_approval(value);
  // @@protoc_insertion_point(field_set:proto.AccountAmount.is_approval)
}

// -------------------------------------------------------------------

// TransferList

// repeated .proto.AccountAmount accountAmounts = 1;
inline int TransferList::_internal_accountamounts_size() const {
  return _impl_.accountamounts_.size();
}
inline int TransferList::accountamounts_size() const {
  return _internal_accountamounts_size();
}
inline void TransferList::clear_accountamounts() {
  _impl_.accountamounts_.Clear();
}
inline ::proto::AccountAmount* TransferList::mutable_accountamounts(int index) {
  // @@protoc_insertion_point(field_mutable:proto.TransferList.accountAmounts)
  return _impl_.accountamounts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::AccountAmount >*
TransferList::mutable_accountamounts() {
  // @@protoc_insertion_point(field_mutable_list:proto.TransferList.accountAmounts)
  return &_impl_.accountamounts_;
}
inline const ::proto::AccountAmount& TransferList::_internal_accountamounts(int index) const {
  return _impl_.accountamounts_.Get(index);
}
inline const ::proto::AccountAmount& TransferList::accountamounts(int index) const {
  // @@protoc_insertion_point(field_get:proto.TransferList.accountAmounts)
  return _internal_accountamounts(index);
}
inline ::proto::AccountAmount* TransferList::_internal_add_accountamounts() {
  return _impl_.accountamounts_.Add();
}
inline ::proto::AccountAmount* TransferList::add_accountamounts() {
  ::proto::AccountAmount* _add = _internal_add_accountamounts();
  // @@protoc_insertion_point(field_add:proto.TransferList.accountAmounts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::AccountAmount >&
TransferList::accountamounts() const {
  // @@protoc_insertion_point(field_list:proto.TransferList.accountAmounts)
  return _impl_.accountamounts_;
}

// -------------------------------------------------------------------

// NftTransfer

// .proto.AccountID senderAccountID = 1;
inline bool NftTransfer::_internal_has_senderaccountid() const {
  return this != internal_default_instance() && _impl_.senderaccountid_ != nullptr;
}
inline bool NftTransfer::has_senderaccountid() const {
  return _internal_has_senderaccountid();
}
inline void NftTransfer::clear_senderaccountid() {
  if (GetArenaForAllocation() == nullptr && _impl_.senderaccountid_ != nullptr) {
    delete _impl_.senderaccountid_;
  }
  _impl_.senderaccountid_ = nullptr;
}
inline const ::proto::AccountID& NftTransfer::_internal_senderaccountid() const {
  const ::proto::AccountID* p = _impl_.senderaccountid_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AccountID&>(
      ::proto::_AccountID_default_instance_);
}
inline const ::proto::AccountID& NftTransfer::senderaccountid() const {
  // @@protoc_insertion_point(field_get:proto.NftTransfer.senderAccountID)
  return _internal_senderaccountid();
}
inline void NftTransfer::unsafe_arena_set_allocated_senderaccountid(
    ::proto::AccountID* senderaccountid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.senderaccountid_);
  }
  _impl_.senderaccountid_ = senderaccountid;
  if (senderaccountid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.NftTransfer.senderAccountID)
}
inline ::proto::AccountID* NftTransfer::release_senderaccountid() {
  
  ::proto::AccountID* temp = _impl_.senderaccountid_;
  _impl_.senderaccountid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AccountID* NftTransfer::unsafe_arena_release_senderaccountid() {
  // @@protoc_insertion_point(field_release:proto.NftTransfer.senderAccountID)
  
  ::proto::AccountID* temp = _impl_.senderaccountid_;
  _impl_.senderaccountid_ = nullptr;
  return temp;
}
inline ::proto::AccountID* NftTransfer::_internal_mutable_senderaccountid() {
  
  if (_impl_.senderaccountid_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AccountID>(GetArenaForAllocation());
    _impl_.senderaccountid_ = p;
  }
  return _impl_.senderaccountid_;
}
inline ::proto::AccountID* NftTransfer::mutable_senderaccountid() {
  ::proto::AccountID* _msg = _internal_mutable_senderaccountid();
  // @@protoc_insertion_point(field_mutable:proto.NftTransfer.senderAccountID)
  return _msg;
}
inline void NftTransfer::set_allocated_senderaccountid(::proto::AccountID* senderaccountid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.senderaccountid_;
  }
  if (senderaccountid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(senderaccountid);
    if (message_arena != submessage_arena) {
      senderaccountid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, senderaccountid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.senderaccountid_ = senderaccountid;
  // @@protoc_insertion_point(field_set_allocated:proto.NftTransfer.senderAccountID)
}

// .proto.AccountID receiverAccountID = 2;
inline bool NftTransfer::_internal_has_receiveraccountid() const {
  return this != internal_default_instance() && _impl_.receiveraccountid_ != nullptr;
}
inline bool NftTransfer::has_receiveraccountid() const {
  return _internal_has_receiveraccountid();
}
inline void NftTransfer::clear_receiveraccountid() {
  if (GetArenaForAllocation() == nullptr && _impl_.receiveraccountid_ != nullptr) {
    delete _impl_.receiveraccountid_;
  }
  _impl_.receiveraccountid_ = nullptr;
}
inline const ::proto::AccountID& NftTransfer::_internal_receiveraccountid() const {
  const ::proto::AccountID* p = _impl_.receiveraccountid_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AccountID&>(
      ::proto::_AccountID_default_instance_);
}
inline const ::proto::AccountID& NftTransfer::receiveraccountid() const {
  // @@protoc_insertion_point(field_get:proto.NftTransfer.receiverAccountID)
  return _internal_receiveraccountid();
}
inline void NftTransfer::unsafe_arena_set_allocated_receiveraccountid(
    ::proto::AccountID* receiveraccountid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.receiveraccountid_);
  }
  _impl_.receiveraccountid_ = receiveraccountid;
  if (receiveraccountid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.NftTransfer.receiverAccountID)
}
inline ::proto::AccountID* NftTransfer::release_receiveraccountid() {
  
  ::proto::AccountID* temp = _impl_.receiveraccountid_;
  _impl_.receiveraccountid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AccountID* NftTransfer::unsafe_arena_release_receiveraccountid() {
  // @@protoc_insertion_point(field_release:proto.NftTransfer.receiverAccountID)
  
  ::proto::AccountID* temp = _impl_.receiveraccountid_;
  _impl_.receiveraccountid_ = nullptr;
  return temp;
}
inline ::proto::AccountID* NftTransfer::_internal_mutable_receiveraccountid() {
  
  if (_impl_.receiveraccountid_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AccountID>(GetArenaForAllocation());
    _impl_.receiveraccountid_ = p;
  }
  return _impl_.receiveraccountid_;
}
inline ::proto::AccountID* NftTransfer::mutable_receiveraccountid() {
  ::proto::AccountID* _msg = _internal_mutable_receiveraccountid();
  // @@protoc_insertion_point(field_mutable:proto.NftTransfer.receiverAccountID)
  return _msg;
}
inline void NftTransfer::set_allocated_receiveraccountid(::proto::AccountID* receiveraccountid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.receiveraccountid_;
  }
  if (receiveraccountid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(receiveraccountid);
    if (message_arena != submessage_arena) {
      receiveraccountid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, receiveraccountid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.receiveraccountid_ = receiveraccountid;
  // @@protoc_insertion_point(field_set_allocated:proto.NftTransfer.receiverAccountID)
}

// int64 serialNumber = 3;
inline void NftTransfer::clear_serialnumber() {
  _impl_.serialnumber_ = int64_t{0};
}
inline int64_t NftTransfer::_internal_serialnumber() const {
  return _impl_.serialnumber_;
}
inline int64_t NftTransfer::serialnumber() const {
  // @@protoc_insertion_point(field_get:proto.NftTransfer.serialNumber)
  return _internal_serialnumber();
}
inline void NftTransfer::_internal_set_serialnumber(int64_t value) {
  
  _impl_.serialnumber_ = value;
}
inline void NftTransfer::set_serialnumber(int64_t value) {
  _internal_set_serialnumber(value);
  // @@protoc_insertion_point(field_set:proto.NftTransfer.serialNumber)
}

// bool is_approval = 4;
inline void NftTransfer::clear_is_approval() {
  _impl_.is_approval_ = false;
}
inline bool NftTransfer::_internal_is_approval() const {
  return _impl_.is_approval_;
}
inline bool NftTransfer::is_approval() const {
  // @@protoc_insertion_point(field_get:proto.NftTransfer.is_approval)
  return _internal_is_approval();
}
inline void NftTransfer::_internal_set_is_approval(bool value) {
  
  _impl_.is_approval_ = value;
}
inline void NftTransfer::set_is_approval(bool value) {
  _internal_set_is_approval(value);
  // @@protoc_insertion_point(field_set:proto.NftTransfer.is_approval)
}

// -------------------------------------------------------------------

// TokenTransferList

// .proto.TokenID token = 1;
inline bool TokenTransferList::_internal_has_token() const {
  return this != internal_default_instance() && _impl_.token_ != nullptr;
}
inline bool TokenTransferList::has_token() const {
  return _internal_has_token();
}
inline void TokenTransferList::clear_token() {
  if (GetArenaForAllocation() == nullptr && _impl_.token_ != nullptr) {
    delete _impl_.token_;
  }
  _impl_.token_ = nullptr;
}
inline const ::proto::TokenID& TokenTransferList::_internal_token() const {
  const ::proto::TokenID* p = _impl_.token_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::TokenID&>(
      ::proto::_TokenID_default_instance_);
}
inline const ::proto::TokenID& TokenTransferList::token() const {
  // @@protoc_insertion_point(field_get:proto.TokenTransferList.token)
  return _internal_token();
}
inline void TokenTransferList::unsafe_arena_set_allocated_token(
    ::proto::TokenID* token) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.token_);
  }
  _impl_.token_ = token;
  if (token) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TokenTransferList.token)
}
inline ::proto::TokenID* TokenTransferList::release_token() {
  
  ::proto::TokenID* temp = _impl_.token_;
  _impl_.token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::TokenID* TokenTransferList::unsafe_arena_release_token() {
  // @@protoc_insertion_point(field_release:proto.TokenTransferList.token)
  
  ::proto::TokenID* temp = _impl_.token_;
  _impl_.token_ = nullptr;
  return temp;
}
inline ::proto::TokenID* TokenTransferList::_internal_mutable_token() {
  
  if (_impl_.token_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::TokenID>(GetArenaForAllocation());
    _impl_.token_ = p;
  }
  return _impl_.token_;
}
inline ::proto::TokenID* TokenTransferList::mutable_token() {
  ::proto::TokenID* _msg = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:proto.TokenTransferList.token)
  return _msg;
}
inline void TokenTransferList::set_allocated_token(::proto::TokenID* token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.token_;
  }
  if (token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(token);
    if (message_arena != submessage_arena) {
      token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.token_ = token;
  // @@protoc_insertion_point(field_set_allocated:proto.TokenTransferList.token)
}

// repeated .proto.AccountAmount transfers = 2;
inline int TokenTransferList::_internal_transfers_size() const {
  return _impl_.transfers_.size();
}
inline int TokenTransferList::transfers_size() const {
  return _internal_transfers_size();
}
inline void TokenTransferList::clear_transfers() {
  _impl_.transfers_.Clear();
}
inline ::proto::AccountAmount* TokenTransferList::mutable_transfers(int index) {
  // @@protoc_insertion_point(field_mutable:proto.TokenTransferList.transfers)
  return _impl_.transfers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::AccountAmount >*
TokenTransferList::mutable_transfers() {
  // @@protoc_insertion_point(field_mutable_list:proto.TokenTransferList.transfers)
  return &_impl_.transfers_;
}
inline const ::proto::AccountAmount& TokenTransferList::_internal_transfers(int index) const {
  return _impl_.transfers_.Get(index);
}
inline const ::proto::AccountAmount& TokenTransferList::transfers(int index) const {
  // @@protoc_insertion_point(field_get:proto.TokenTransferList.transfers)
  return _internal_transfers(index);
}
inline ::proto::AccountAmount* TokenTransferList::_internal_add_transfers() {
  return _impl_.transfers_.Add();
}
inline ::proto::AccountAmount* TokenTransferList::add_transfers() {
  ::proto::AccountAmount* _add = _internal_add_transfers();
  // @@protoc_insertion_point(field_add:proto.TokenTransferList.transfers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::AccountAmount >&
TokenTransferList::transfers() const {
  // @@protoc_insertion_point(field_list:proto.TokenTransferList.transfers)
  return _impl_.transfers_;
}

// repeated .proto.NftTransfer nftTransfers = 3;
inline int TokenTransferList::_internal_nfttransfers_size() const {
  return _impl_.nfttransfers_.size();
}
inline int TokenTransferList::nfttransfers_size() const {
  return _internal_nfttransfers_size();
}
inline void TokenTransferList::clear_nfttransfers() {
  _impl_.nfttransfers_.Clear();
}
inline ::proto::NftTransfer* TokenTransferList::mutable_nfttransfers(int index) {
  // @@protoc_insertion_point(field_mutable:proto.TokenTransferList.nftTransfers)
  return _impl_.nfttransfers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::NftTransfer >*
TokenTransferList::mutable_nfttransfers() {
  // @@protoc_insertion_point(field_mutable_list:proto.TokenTransferList.nftTransfers)
  return &_impl_.nfttransfers_;
}
inline const ::proto::NftTransfer& TokenTransferList::_internal_nfttransfers(int index) const {
  return _impl_.nfttransfers_.Get(index);
}
inline const ::proto::NftTransfer& TokenTransferList::nfttransfers(int index) const {
  // @@protoc_insertion_point(field_get:proto.TokenTransferList.nftTransfers)
  return _internal_nfttransfers(index);
}
inline ::proto::NftTransfer* TokenTransferList::_internal_add_nfttransfers() {
  return _impl_.nfttransfers_.Add();
}
inline ::proto::NftTransfer* TokenTransferList::add_nfttransfers() {
  ::proto::NftTransfer* _add = _internal_add_nfttransfers();
  // @@protoc_insertion_point(field_add:proto.TokenTransferList.nftTransfers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::NftTransfer >&
TokenTransferList::nfttransfers() const {
  // @@protoc_insertion_point(field_list:proto.TokenTransferList.nftTransfers)
  return _impl_.nfttransfers_;
}

// .google.protobuf.UInt32Value expected_decimals = 4;
inline bool TokenTransferList::_internal_has_expected_decimals() const {
  return this != internal_default_instance() && _impl_.expected_decimals_ != nullptr;
}
inline bool TokenTransferList::has_expected_decimals() const {
  return _internal_has_expected_decimals();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt32Value& TokenTransferList::_internal_expected_decimals() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value* p = _impl_.expected_decimals_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt32Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt32Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt32Value& TokenTransferList::expected_decimals() const {
  // @@protoc_insertion_point(field_get:proto.TokenTransferList.expected_decimals)
  return _internal_expected_decimals();
}
inline void TokenTransferList::unsafe_arena_set_allocated_expected_decimals(
    ::PROTOBUF_NAMESPACE_ID::UInt32Value* expected_decimals) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expected_decimals_);
  }
  _impl_.expected_decimals_ = expected_decimals;
  if (expected_decimals) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TokenTransferList.expected_decimals)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* TokenTransferList::release_expected_decimals() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* temp = _impl_.expected_decimals_;
  _impl_.expected_decimals_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* TokenTransferList::unsafe_arena_release_expected_decimals() {
  // @@protoc_insertion_point(field_release:proto.TokenTransferList.expected_decimals)
  
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* temp = _impl_.expected_decimals_;
  _impl_.expected_decimals_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* TokenTransferList::_internal_mutable_expected_decimals() {
  
  if (_impl_.expected_decimals_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt32Value>(GetArenaForAllocation());
    _impl_.expected_decimals_ = p;
  }
  return _impl_.expected_decimals_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* TokenTransferList::mutable_expected_decimals() {
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* _msg = _internal_mutable_expected_decimals();
  // @@protoc_insertion_point(field_mutable:proto.TokenTransferList.expected_decimals)
  return _msg;
}
inline void TokenTransferList::set_allocated_expected_decimals(::PROTOBUF_NAMESPACE_ID::UInt32Value* expected_decimals) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expected_decimals_);
  }
  if (expected_decimals) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expected_decimals));
    if (message_arena != submessage_arena) {
      expected_decimals = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expected_decimals, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.expected_decimals_ = expected_decimals;
  // @@protoc_insertion_point(field_set_allocated:proto.TokenTransferList.expected_decimals)
}

// -------------------------------------------------------------------

// Fraction

// int64 numerator = 1;
inline void Fraction::clear_numerator() {
  _impl_.numerator_ = int64_t{0};
}
inline int64_t Fraction::_internal_numerator() const {
  return _impl_.numerator_;
}
inline int64_t Fraction::numerator() const {
  // @@protoc_insertion_point(field_get:proto.Fraction.numerator)
  return _internal_numerator();
}
inline void Fraction::_internal_set_numerator(int64_t value) {
  
  _impl_.numerator_ = value;
}
inline void Fraction::set_numerator(int64_t value) {
  _internal_set_numerator(value);
  // @@protoc_insertion_point(field_set:proto.Fraction.numerator)
}

// int64 denominator = 2;
inline void Fraction::clear_denominator() {
  _impl_.denominator_ = int64_t{0};
}
inline int64_t Fraction::_internal_denominator() const {
  return _impl_.denominator_;
}
inline int64_t Fraction::denominator() const {
  // @@protoc_insertion_point(field_get:proto.Fraction.denominator)
  return _internal_denominator();
}
inline void Fraction::_internal_set_denominator(int64_t value) {
  
  _impl_.denominator_ = value;
}
inline void Fraction::set_denominator(int64_t value) {
  _internal_set_denominator(value);
  // @@protoc_insertion_point(field_set:proto.Fraction.denominator)
}

// -------------------------------------------------------------------

// TopicID

// int64 shardNum = 1;
inline void TopicID::clear_shardnum() {
  _impl_.shardnum_ = int64_t{0};
}
inline int64_t TopicID::_internal_shardnum() const {
  return _impl_.shardnum_;
}
inline int64_t TopicID::shardnum() const {
  // @@protoc_insertion_point(field_get:proto.TopicID.shardNum)
  return _internal_shardnum();
}
inline void TopicID::_internal_set_shardnum(int64_t value) {
  
  _impl_.shardnum_ = value;
}
inline void TopicID::set_shardnum(int64_t value) {
  _internal_set_shardnum(value);
  // @@protoc_insertion_point(field_set:proto.TopicID.shardNum)
}

// int64 realmNum = 2;
inline void TopicID::clear_realmnum() {
  _impl_.realmnum_ = int64_t{0};
}
inline int64_t TopicID::_internal_realmnum() const {
  return _impl_.realmnum_;
}
inline int64_t TopicID::realmnum() const {
  // @@protoc_insertion_point(field_get:proto.TopicID.realmNum)
  return _internal_realmnum();
}
inline void TopicID::_internal_set_realmnum(int64_t value) {
  
  _impl_.realmnum_ = value;
}
inline void TopicID::set_realmnum(int64_t value) {
  _internal_set_realmnum(value);
  // @@protoc_insertion_point(field_set:proto.TopicID.realmNum)
}

// int64 topicNum = 3;
inline void TopicID::clear_topicnum() {
  _impl_.topicnum_ = int64_t{0};
}
inline int64_t TopicID::_internal_topicnum() const {
  return _impl_.topicnum_;
}
inline int64_t TopicID::topicnum() const {
  // @@protoc_insertion_point(field_get:proto.TopicID.topicNum)
  return _internal_topicnum();
}
inline void TopicID::_internal_set_topicnum(int64_t value) {
  
  _impl_.topicnum_ = value;
}
inline void TopicID::set_topicnum(int64_t value) {
  _internal_set_topicnum(value);
  // @@protoc_insertion_point(field_set:proto.TopicID.topicNum)
}

// -------------------------------------------------------------------

// TokenID

// int64 shardNum = 1;
inline void TokenID::clear_shardnum() {
  _impl_.shardnum_ = int64_t{0};
}
inline int64_t TokenID::_internal_shardnum() const {
  return _impl_.shardnum_;
}
inline int64_t TokenID::shardnum() const {
  // @@protoc_insertion_point(field_get:proto.TokenID.shardNum)
  return _internal_shardnum();
}
inline void TokenID::_internal_set_shardnum(int64_t value) {
  
  _impl_.shardnum_ = value;
}
inline void TokenID::set_shardnum(int64_t value) {
  _internal_set_shardnum(value);
  // @@protoc_insertion_point(field_set:proto.TokenID.shardNum)
}

// int64 realmNum = 2;
inline void TokenID::clear_realmnum() {
  _impl_.realmnum_ = int64_t{0};
}
inline int64_t TokenID::_internal_realmnum() const {
  return _impl_.realmnum_;
}
inline int64_t TokenID::realmnum() const {
  // @@protoc_insertion_point(field_get:proto.TokenID.realmNum)
  return _internal_realmnum();
}
inline void TokenID::_internal_set_realmnum(int64_t value) {
  
  _impl_.realmnum_ = value;
}
inline void TokenID::set_realmnum(int64_t value) {
  _internal_set_realmnum(value);
  // @@protoc_insertion_point(field_set:proto.TokenID.realmNum)
}

// int64 tokenNum = 3;
inline void TokenID::clear_tokennum() {
  _impl_.tokennum_ = int64_t{0};
}
inline int64_t TokenID::_internal_tokennum() const {
  return _impl_.tokennum_;
}
inline int64_t TokenID::tokennum() const {
  // @@protoc_insertion_point(field_get:proto.TokenID.tokenNum)
  return _internal_tokennum();
}
inline void TokenID::_internal_set_tokennum(int64_t value) {
  
  _impl_.tokennum_ = value;
}
inline void TokenID::set_tokennum(int64_t value) {
  _internal_set_tokennum(value);
  // @@protoc_insertion_point(field_set:proto.TokenID.tokenNum)
}

// -------------------------------------------------------------------

// ScheduleID

// int64 shardNum = 1;
inline void ScheduleID::clear_shardnum() {
  _impl_.shardnum_ = int64_t{0};
}
inline int64_t ScheduleID::_internal_shardnum() const {
  return _impl_.shardnum_;
}
inline int64_t ScheduleID::shardnum() const {
  // @@protoc_insertion_point(field_get:proto.ScheduleID.shardNum)
  return _internal_shardnum();
}
inline void ScheduleID::_internal_set_shardnum(int64_t value) {
  
  _impl_.shardnum_ = value;
}
inline void ScheduleID::set_shardnum(int64_t value) {
  _internal_set_shardnum(value);
  // @@protoc_insertion_point(field_set:proto.ScheduleID.shardNum)
}

// int64 realmNum = 2;
inline void ScheduleID::clear_realmnum() {
  _impl_.realmnum_ = int64_t{0};
}
inline int64_t ScheduleID::_internal_realmnum() const {
  return _impl_.realmnum_;
}
inline int64_t ScheduleID::realmnum() const {
  // @@protoc_insertion_point(field_get:proto.ScheduleID.realmNum)
  return _internal_realmnum();
}
inline void ScheduleID::_internal_set_realmnum(int64_t value) {
  
  _impl_.realmnum_ = value;
}
inline void ScheduleID::set_realmnum(int64_t value) {
  _internal_set_realmnum(value);
  // @@protoc_insertion_point(field_set:proto.ScheduleID.realmNum)
}

// int64 scheduleNum = 3;
inline void ScheduleID::clear_schedulenum() {
  _impl_.schedulenum_ = int64_t{0};
}
inline int64_t ScheduleID::_internal_schedulenum() const {
  return _impl_.schedulenum_;
}
inline int64_t ScheduleID::schedulenum() const {
  // @@protoc_insertion_point(field_get:proto.ScheduleID.scheduleNum)
  return _internal_schedulenum();
}
inline void ScheduleID::_internal_set_schedulenum(int64_t value) {
  
  _impl_.schedulenum_ = value;
}
inline void ScheduleID::set_schedulenum(int64_t value) {
  _internal_set_schedulenum(value);
  // @@protoc_insertion_point(field_set:proto.ScheduleID.scheduleNum)
}

// -------------------------------------------------------------------

// Key

// .proto.ContractID contractID = 1;
inline bool Key::_internal_has_contractid() const {
  return key_case() == kContractID;
}
inline bool Key::has_contractid() const {
  return _internal_has_contractid();
}
inline void Key::set_has_contractid() {
  _impl_._oneof_case_[0] = kContractID;
}
inline void Key::clear_contractid() {
  if (_internal_has_contractid()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.key_.contractid_;
    }
    clear_has_key();
  }
}
inline ::proto::ContractID* Key::release_contractid() {
  // @@protoc_insertion_point(field_release:proto.Key.contractID)
  if (_internal_has_contractid()) {
    clear_has_key();
    ::proto::ContractID* temp = _impl_.key_.contractid_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.key_.contractid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ContractID& Key::_internal_contractid() const {
  return _internal_has_contractid()
      ? *_impl_.key_.contractid_
      : reinterpret_cast< ::proto::ContractID&>(::proto::_ContractID_default_instance_);
}
inline const ::proto::ContractID& Key::contractid() const {
  // @@protoc_insertion_point(field_get:proto.Key.contractID)
  return _internal_contractid();
}
inline ::proto::ContractID* Key::unsafe_arena_release_contractid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Key.contractID)
  if (_internal_has_contractid()) {
    clear_has_key();
    ::proto::ContractID* temp = _impl_.key_.contractid_;
    _impl_.key_.contractid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Key::unsafe_arena_set_allocated_contractid(::proto::ContractID* contractid) {
  clear_key();
  if (contractid) {
    set_has_contractid();
    _impl_.key_.contractid_ = contractid;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Key.contractID)
}
inline ::proto::ContractID* Key::_internal_mutable_contractid() {
  if (!_internal_has_contractid()) {
    clear_key();
    set_has_contractid();
    _impl_.key_.contractid_ = CreateMaybeMessage< ::proto::ContractID >(GetArenaForAllocation());
  }
  return _impl_.key_.contractid_;
}
inline ::proto::ContractID* Key::mutable_contractid() {
  ::proto::ContractID* _msg = _internal_mutable_contractid();
  // @@protoc_insertion_point(field_mutable:proto.Key.contractID)
  return _msg;
}

// bytes ed25519 = 2;
inline bool Key::_internal_has_ed25519() const {
  return key_case() == kEd25519;
}
inline bool Key::has_ed25519() const {
  return _internal_has_ed25519();
}
inline void Key::set_has_ed25519() {
  _impl_._oneof_case_[0] = kEd25519;
}
inline void Key::clear_ed25519() {
  if (_internal_has_ed25519()) {
    _impl_.key_.ed25519_.Destroy();
    clear_has_key();
  }
}
inline const std::string& Key::ed25519() const {
  // @@protoc_insertion_point(field_get:proto.Key.ed25519)
  return _internal_ed25519();
}
template <typename ArgT0, typename... ArgT>
inline void Key::set_ed25519(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_ed25519()) {
    clear_key();
    set_has_ed25519();
    _impl_.key_.ed25519_.InitDefault();
  }
  _impl_.key_.ed25519_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Key.ed25519)
}
inline std::string* Key::mutable_ed25519() {
  std::string* _s = _internal_mutable_ed25519();
  // @@protoc_insertion_point(field_mutable:proto.Key.ed25519)
  return _s;
}
inline const std::string& Key::_internal_ed25519() const {
  if (_internal_has_ed25519()) {
    return _impl_.key_.ed25519_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Key::_internal_set_ed25519(const std::string& value) {
  if (!_internal_has_ed25519()) {
    clear_key();
    set_has_ed25519();
    _impl_.key_.ed25519_.InitDefault();
  }
  _impl_.key_.ed25519_.Set(value, GetArenaForAllocation());
}
inline std::string* Key::_internal_mutable_ed25519() {
  if (!_internal_has_ed25519()) {
    clear_key();
    set_has_ed25519();
    _impl_.key_.ed25519_.InitDefault();
  }
  return _impl_.key_.ed25519_.Mutable(      GetArenaForAllocation());
}
inline std::string* Key::release_ed25519() {
  // @@protoc_insertion_point(field_release:proto.Key.ed25519)
  if (_internal_has_ed25519()) {
    clear_has_key();
    return _impl_.key_.ed25519_.Release();
  } else {
    return nullptr;
  }
}
inline void Key::set_allocated_ed25519(std::string* ed25519) {
  if (has_key()) {
    clear_key();
  }
  if (ed25519 != nullptr) {
    set_has_ed25519();
    _impl_.key_.ed25519_.InitAllocated(ed25519, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Key.ed25519)
}

// bytes RSA_3072 = 3;
inline bool Key::_internal_has_rsa_3072() const {
  return key_case() == kRSA3072;
}
inline bool Key::has_rsa_3072() const {
  return _internal_has_rsa_3072();
}
inline void Key::set_has_rsa_3072() {
  _impl_._oneof_case_[0] = kRSA3072;
}
inline void Key::clear_rsa_3072() {
  if (_internal_has_rsa_3072()) {
    _impl_.key_.rsa_3072_.Destroy();
    clear_has_key();
  }
}
inline const std::string& Key::rsa_3072() const {
  // @@protoc_insertion_point(field_get:proto.Key.RSA_3072)
  return _internal_rsa_3072();
}
template <typename ArgT0, typename... ArgT>
inline void Key::set_rsa_3072(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_rsa_3072()) {
    clear_key();
    set_has_rsa_3072();
    _impl_.key_.rsa_3072_.InitDefault();
  }
  _impl_.key_.rsa_3072_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Key.RSA_3072)
}
inline std::string* Key::mutable_rsa_3072() {
  std::string* _s = _internal_mutable_rsa_3072();
  // @@protoc_insertion_point(field_mutable:proto.Key.RSA_3072)
  return _s;
}
inline const std::string& Key::_internal_rsa_3072() const {
  if (_internal_has_rsa_3072()) {
    return _impl_.key_.rsa_3072_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Key::_internal_set_rsa_3072(const std::string& value) {
  if (!_internal_has_rsa_3072()) {
    clear_key();
    set_has_rsa_3072();
    _impl_.key_.rsa_3072_.InitDefault();
  }
  _impl_.key_.rsa_3072_.Set(value, GetArenaForAllocation());
}
inline std::string* Key::_internal_mutable_rsa_3072() {
  if (!_internal_has_rsa_3072()) {
    clear_key();
    set_has_rsa_3072();
    _impl_.key_.rsa_3072_.InitDefault();
  }
  return _impl_.key_.rsa_3072_.Mutable(      GetArenaForAllocation());
}
inline std::string* Key::release_rsa_3072() {
  // @@protoc_insertion_point(field_release:proto.Key.RSA_3072)
  if (_internal_has_rsa_3072()) {
    clear_has_key();
    return _impl_.key_.rsa_3072_.Release();
  } else {
    return nullptr;
  }
}
inline void Key::set_allocated_rsa_3072(std::string* rsa_3072) {
  if (has_key()) {
    clear_key();
  }
  if (rsa_3072 != nullptr) {
    set_has_rsa_3072();
    _impl_.key_.rsa_3072_.InitAllocated(rsa_3072, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Key.RSA_3072)
}

// bytes ECDSA_384 = 4;
inline bool Key::_internal_has_ecdsa_384() const {
  return key_case() == kECDSA384;
}
inline bool Key::has_ecdsa_384() const {
  return _internal_has_ecdsa_384();
}
inline void Key::set_has_ecdsa_384() {
  _impl_._oneof_case_[0] = kECDSA384;
}
inline void Key::clear_ecdsa_384() {
  if (_internal_has_ecdsa_384()) {
    _impl_.key_.ecdsa_384_.Destroy();
    clear_has_key();
  }
}
inline const std::string& Key::ecdsa_384() const {
  // @@protoc_insertion_point(field_get:proto.Key.ECDSA_384)
  return _internal_ecdsa_384();
}
template <typename ArgT0, typename... ArgT>
inline void Key::set_ecdsa_384(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_ecdsa_384()) {
    clear_key();
    set_has_ecdsa_384();
    _impl_.key_.ecdsa_384_.InitDefault();
  }
  _impl_.key_.ecdsa_384_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Key.ECDSA_384)
}
inline std::string* Key::mutable_ecdsa_384() {
  std::string* _s = _internal_mutable_ecdsa_384();
  // @@protoc_insertion_point(field_mutable:proto.Key.ECDSA_384)
  return _s;
}
inline const std::string& Key::_internal_ecdsa_384() const {
  if (_internal_has_ecdsa_384()) {
    return _impl_.key_.ecdsa_384_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Key::_internal_set_ecdsa_384(const std::string& value) {
  if (!_internal_has_ecdsa_384()) {
    clear_key();
    set_has_ecdsa_384();
    _impl_.key_.ecdsa_384_.InitDefault();
  }
  _impl_.key_.ecdsa_384_.Set(value, GetArenaForAllocation());
}
inline std::string* Key::_internal_mutable_ecdsa_384() {
  if (!_internal_has_ecdsa_384()) {
    clear_key();
    set_has_ecdsa_384();
    _impl_.key_.ecdsa_384_.InitDefault();
  }
  return _impl_.key_.ecdsa_384_.Mutable(      GetArenaForAllocation());
}
inline std::string* Key::release_ecdsa_384() {
  // @@protoc_insertion_point(field_release:proto.Key.ECDSA_384)
  if (_internal_has_ecdsa_384()) {
    clear_has_key();
    return _impl_.key_.ecdsa_384_.Release();
  } else {
    return nullptr;
  }
}
inline void Key::set_allocated_ecdsa_384(std::string* ecdsa_384) {
  if (has_key()) {
    clear_key();
  }
  if (ecdsa_384 != nullptr) {
    set_has_ecdsa_384();
    _impl_.key_.ecdsa_384_.InitAllocated(ecdsa_384, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Key.ECDSA_384)
}

// .proto.ThresholdKey thresholdKey = 5;
inline bool Key::_internal_has_thresholdkey() const {
  return key_case() == kThresholdKey;
}
inline bool Key::has_thresholdkey() const {
  return _internal_has_thresholdkey();
}
inline void Key::set_has_thresholdkey() {
  _impl_._oneof_case_[0] = kThresholdKey;
}
inline void Key::clear_thresholdkey() {
  if (_internal_has_thresholdkey()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.key_.thresholdkey_;
    }
    clear_has_key();
  }
}
inline ::proto::ThresholdKey* Key::release_thresholdkey() {
  // @@protoc_insertion_point(field_release:proto.Key.thresholdKey)
  if (_internal_has_thresholdkey()) {
    clear_has_key();
    ::proto::ThresholdKey* temp = _impl_.key_.thresholdkey_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.key_.thresholdkey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ThresholdKey& Key::_internal_thresholdkey() const {
  return _internal_has_thresholdkey()
      ? *_impl_.key_.thresholdkey_
      : reinterpret_cast< ::proto::ThresholdKey&>(::proto::_ThresholdKey_default_instance_);
}
inline const ::proto::ThresholdKey& Key::thresholdkey() const {
  // @@protoc_insertion_point(field_get:proto.Key.thresholdKey)
  return _internal_thresholdkey();
}
inline ::proto::ThresholdKey* Key::unsafe_arena_release_thresholdkey() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Key.thresholdKey)
  if (_internal_has_thresholdkey()) {
    clear_has_key();
    ::proto::ThresholdKey* temp = _impl_.key_.thresholdkey_;
    _impl_.key_.thresholdkey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Key::unsafe_arena_set_allocated_thresholdkey(::proto::ThresholdKey* thresholdkey) {
  clear_key();
  if (thresholdkey) {
    set_has_thresholdkey();
    _impl_.key_.thresholdkey_ = thresholdkey;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Key.thresholdKey)
}
inline ::proto::ThresholdKey* Key::_internal_mutable_thresholdkey() {
  if (!_internal_has_thresholdkey()) {
    clear_key();
    set_has_thresholdkey();
    _impl_.key_.thresholdkey_ = CreateMaybeMessage< ::proto::ThresholdKey >(GetArenaForAllocation());
  }
  return _impl_.key_.thresholdkey_;
}
inline ::proto::ThresholdKey* Key::mutable_thresholdkey() {
  ::proto::ThresholdKey* _msg = _internal_mutable_thresholdkey();
  // @@protoc_insertion_point(field_mutable:proto.Key.thresholdKey)
  return _msg;
}

// .proto.KeyList keyList = 6;
inline bool Key::_internal_has_keylist() const {
  return key_case() == kKeyList;
}
inline bool Key::has_keylist() const {
  return _internal_has_keylist();
}
inline void Key::set_has_keylist() {
  _impl_._oneof_case_[0] = kKeyList;
}
inline void Key::clear_keylist() {
  if (_internal_has_keylist()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.key_.keylist_;
    }
    clear_has_key();
  }
}
inline ::proto::KeyList* Key::release_keylist() {
  // @@protoc_insertion_point(field_release:proto.Key.keyList)
  if (_internal_has_keylist()) {
    clear_has_key();
    ::proto::KeyList* temp = _impl_.key_.keylist_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.key_.keylist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::KeyList& Key::_internal_keylist() const {
  return _internal_has_keylist()
      ? *_impl_.key_.keylist_
      : reinterpret_cast< ::proto::KeyList&>(::proto::_KeyList_default_instance_);
}
inline const ::proto::KeyList& Key::keylist() const {
  // @@protoc_insertion_point(field_get:proto.Key.keyList)
  return _internal_keylist();
}
inline ::proto::KeyList* Key::unsafe_arena_release_keylist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Key.keyList)
  if (_internal_has_keylist()) {
    clear_has_key();
    ::proto::KeyList* temp = _impl_.key_.keylist_;
    _impl_.key_.keylist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Key::unsafe_arena_set_allocated_keylist(::proto::KeyList* keylist) {
  clear_key();
  if (keylist) {
    set_has_keylist();
    _impl_.key_.keylist_ = keylist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Key.keyList)
}
inline ::proto::KeyList* Key::_internal_mutable_keylist() {
  if (!_internal_has_keylist()) {
    clear_key();
    set_has_keylist();
    _impl_.key_.keylist_ = CreateMaybeMessage< ::proto::KeyList >(GetArenaForAllocation());
  }
  return _impl_.key_.keylist_;
}
inline ::proto::KeyList* Key::mutable_keylist() {
  ::proto::KeyList* _msg = _internal_mutable_keylist();
  // @@protoc_insertion_point(field_mutable:proto.Key.keyList)
  return _msg;
}

// bytes ECDSA_secp256k1 = 7;
inline bool Key::_internal_has_ecdsa_secp256k1() const {
  return key_case() == kECDSASecp256K1;
}
inline bool Key::has_ecdsa_secp256k1() const {
  return _internal_has_ecdsa_secp256k1();
}
inline void Key::set_has_ecdsa_secp256k1() {
  _impl_._oneof_case_[0] = kECDSASecp256K1;
}
inline void Key::clear_ecdsa_secp256k1() {
  if (_internal_has_ecdsa_secp256k1()) {
    _impl_.key_.ecdsa_secp256k1_.Destroy();
    clear_has_key();
  }
}
inline const std::string& Key::ecdsa_secp256k1() const {
  // @@protoc_insertion_point(field_get:proto.Key.ECDSA_secp256k1)
  return _internal_ecdsa_secp256k1();
}
template <typename ArgT0, typename... ArgT>
inline void Key::set_ecdsa_secp256k1(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_ecdsa_secp256k1()) {
    clear_key();
    set_has_ecdsa_secp256k1();
    _impl_.key_.ecdsa_secp256k1_.InitDefault();
  }
  _impl_.key_.ecdsa_secp256k1_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Key.ECDSA_secp256k1)
}
inline std::string* Key::mutable_ecdsa_secp256k1() {
  std::string* _s = _internal_mutable_ecdsa_secp256k1();
  // @@protoc_insertion_point(field_mutable:proto.Key.ECDSA_secp256k1)
  return _s;
}
inline const std::string& Key::_internal_ecdsa_secp256k1() const {
  if (_internal_has_ecdsa_secp256k1()) {
    return _impl_.key_.ecdsa_secp256k1_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Key::_internal_set_ecdsa_secp256k1(const std::string& value) {
  if (!_internal_has_ecdsa_secp256k1()) {
    clear_key();
    set_has_ecdsa_secp256k1();
    _impl_.key_.ecdsa_secp256k1_.InitDefault();
  }
  _impl_.key_.ecdsa_secp256k1_.Set(value, GetArenaForAllocation());
}
inline std::string* Key::_internal_mutable_ecdsa_secp256k1() {
  if (!_internal_has_ecdsa_secp256k1()) {
    clear_key();
    set_has_ecdsa_secp256k1();
    _impl_.key_.ecdsa_secp256k1_.InitDefault();
  }
  return _impl_.key_.ecdsa_secp256k1_.Mutable(      GetArenaForAllocation());
}
inline std::string* Key::release_ecdsa_secp256k1() {
  // @@protoc_insertion_point(field_release:proto.Key.ECDSA_secp256k1)
  if (_internal_has_ecdsa_secp256k1()) {
    clear_has_key();
    return _impl_.key_.ecdsa_secp256k1_.Release();
  } else {
    return nullptr;
  }
}
inline void Key::set_allocated_ecdsa_secp256k1(std::string* ecdsa_secp256k1) {
  if (has_key()) {
    clear_key();
  }
  if (ecdsa_secp256k1 != nullptr) {
    set_has_ecdsa_secp256k1();
    _impl_.key_.ecdsa_secp256k1_.InitAllocated(ecdsa_secp256k1, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Key.ECDSA_secp256k1)
}

// .proto.ContractID delegatable_contract_id = 8;
inline bool Key::_internal_has_delegatable_contract_id() const {
  return key_case() == kDelegatableContractId;
}
inline bool Key::has_delegatable_contract_id() const {
  return _internal_has_delegatable_contract_id();
}
inline void Key::set_has_delegatable_contract_id() {
  _impl_._oneof_case_[0] = kDelegatableContractId;
}
inline void Key::clear_delegatable_contract_id() {
  if (_internal_has_delegatable_contract_id()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.key_.delegatable_contract_id_;
    }
    clear_has_key();
  }
}
inline ::proto::ContractID* Key::release_delegatable_contract_id() {
  // @@protoc_insertion_point(field_release:proto.Key.delegatable_contract_id)
  if (_internal_has_delegatable_contract_id()) {
    clear_has_key();
    ::proto::ContractID* temp = _impl_.key_.delegatable_contract_id_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.key_.delegatable_contract_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ContractID& Key::_internal_delegatable_contract_id() const {
  return _internal_has_delegatable_contract_id()
      ? *_impl_.key_.delegatable_contract_id_
      : reinterpret_cast< ::proto::ContractID&>(::proto::_ContractID_default_instance_);
}
inline const ::proto::ContractID& Key::delegatable_contract_id() const {
  // @@protoc_insertion_point(field_get:proto.Key.delegatable_contract_id)
  return _internal_delegatable_contract_id();
}
inline ::proto::ContractID* Key::unsafe_arena_release_delegatable_contract_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Key.delegatable_contract_id)
  if (_internal_has_delegatable_contract_id()) {
    clear_has_key();
    ::proto::ContractID* temp = _impl_.key_.delegatable_contract_id_;
    _impl_.key_.delegatable_contract_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Key::unsafe_arena_set_allocated_delegatable_contract_id(::proto::ContractID* delegatable_contract_id) {
  clear_key();
  if (delegatable_contract_id) {
    set_has_delegatable_contract_id();
    _impl_.key_.delegatable_contract_id_ = delegatable_contract_id;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Key.delegatable_contract_id)
}
inline ::proto::ContractID* Key::_internal_mutable_delegatable_contract_id() {
  if (!_internal_has_delegatable_contract_id()) {
    clear_key();
    set_has_delegatable_contract_id();
    _impl_.key_.delegatable_contract_id_ = CreateMaybeMessage< ::proto::ContractID >(GetArenaForAllocation());
  }
  return _impl_.key_.delegatable_contract_id_;
}
inline ::proto::ContractID* Key::mutable_delegatable_contract_id() {
  ::proto::ContractID* _msg = _internal_mutable_delegatable_contract_id();
  // @@protoc_insertion_point(field_mutable:proto.Key.delegatable_contract_id)
  return _msg;
}

inline bool Key::has_key() const {
  return key_case() != KEY_NOT_SET;
}
inline void Key::clear_has_key() {
  _impl_._oneof_case_[0] = KEY_NOT_SET;
}
inline Key::KeyCase Key::key_case() const {
  return Key::KeyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ThresholdKey

// uint32 threshold = 1;
inline void ThresholdKey::clear_threshold() {
  _impl_.threshold_ = 0u;
}
inline uint32_t ThresholdKey::_internal_threshold() const {
  return _impl_.threshold_;
}
inline uint32_t ThresholdKey::threshold() const {
  // @@protoc_insertion_point(field_get:proto.ThresholdKey.threshold)
  return _internal_threshold();
}
inline void ThresholdKey::_internal_set_threshold(uint32_t value) {
  
  _impl_.threshold_ = value;
}
inline void ThresholdKey::set_threshold(uint32_t value) {
  _internal_set_threshold(value);
  // @@protoc_insertion_point(field_set:proto.ThresholdKey.threshold)
}

// .proto.KeyList keys = 2;
inline bool ThresholdKey::_internal_has_keys() const {
  return this != internal_default_instance() && _impl_.keys_ != nullptr;
}
inline bool ThresholdKey::has_keys() const {
  return _internal_has_keys();
}
inline void ThresholdKey::clear_keys() {
  if (GetArenaForAllocation() == nullptr && _impl_.keys_ != nullptr) {
    delete _impl_.keys_;
  }
  _impl_.keys_ = nullptr;
}
inline const ::proto::KeyList& ThresholdKey::_internal_keys() const {
  const ::proto::KeyList* p = _impl_.keys_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::KeyList&>(
      ::proto::_KeyList_default_instance_);
}
inline const ::proto::KeyList& ThresholdKey::keys() const {
  // @@protoc_insertion_point(field_get:proto.ThresholdKey.keys)
  return _internal_keys();
}
inline void ThresholdKey::unsafe_arena_set_allocated_keys(
    ::proto::KeyList* keys) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.keys_);
  }
  _impl_.keys_ = keys;
  if (keys) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ThresholdKey.keys)
}
inline ::proto::KeyList* ThresholdKey::release_keys() {
  
  ::proto::KeyList* temp = _impl_.keys_;
  _impl_.keys_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::KeyList* ThresholdKey::unsafe_arena_release_keys() {
  // @@protoc_insertion_point(field_release:proto.ThresholdKey.keys)
  
  ::proto::KeyList* temp = _impl_.keys_;
  _impl_.keys_ = nullptr;
  return temp;
}
inline ::proto::KeyList* ThresholdKey::_internal_mutable_keys() {
  
  if (_impl_.keys_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::KeyList>(GetArenaForAllocation());
    _impl_.keys_ = p;
  }
  return _impl_.keys_;
}
inline ::proto::KeyList* ThresholdKey::mutable_keys() {
  ::proto::KeyList* _msg = _internal_mutable_keys();
  // @@protoc_insertion_point(field_mutable:proto.ThresholdKey.keys)
  return _msg;
}
inline void ThresholdKey::set_allocated_keys(::proto::KeyList* keys) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.keys_;
  }
  if (keys) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(keys);
    if (message_arena != submessage_arena) {
      keys = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keys, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.keys_ = keys;
  // @@protoc_insertion_point(field_set_allocated:proto.ThresholdKey.keys)
}

// -------------------------------------------------------------------

// KeyList

// repeated .proto.Key keys = 1;
inline int KeyList::_internal_keys_size() const {
  return _impl_.keys_.size();
}
inline int KeyList::keys_size() const {
  return _internal_keys_size();
}
inline void KeyList::clear_keys() {
  _impl_.keys_.Clear();
}
inline ::proto::Key* KeyList::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:proto.KeyList.keys)
  return _impl_.keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Key >*
KeyList::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:proto.KeyList.keys)
  return &_impl_.keys_;
}
inline const ::proto::Key& KeyList::_internal_keys(int index) const {
  return _impl_.keys_.Get(index);
}
inline const ::proto::Key& KeyList::keys(int index) const {
  // @@protoc_insertion_point(field_get:proto.KeyList.keys)
  return _internal_keys(index);
}
inline ::proto::Key* KeyList::_internal_add_keys() {
  return _impl_.keys_.Add();
}
inline ::proto::Key* KeyList::add_keys() {
  ::proto::Key* _add = _internal_add_keys();
  // @@protoc_insertion_point(field_add:proto.KeyList.keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Key >&
KeyList::keys() const {
  // @@protoc_insertion_point(field_list:proto.KeyList.keys)
  return _impl_.keys_;
}

// -------------------------------------------------------------------

// Signature

// bytes contract = 1;
inline bool Signature::_internal_has_contract() const {
  return signature_case() == kContract;
}
inline bool Signature::has_contract() const {
  return _internal_has_contract();
}
inline void Signature::set_has_contract() {
  _impl_._oneof_case_[0] = kContract;
}
inline void Signature::clear_contract() {
  if (_internal_has_contract()) {
    _impl_.signature_.contract_.Destroy();
    clear_has_signature();
  }
}
inline const std::string& Signature::contract() const {
  // @@protoc_insertion_point(field_get:proto.Signature.contract)
  return _internal_contract();
}
template <typename ArgT0, typename... ArgT>
inline void Signature::set_contract(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_contract()) {
    clear_signature();
    set_has_contract();
    _impl_.signature_.contract_.InitDefault();
  }
  _impl_.signature_.contract_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Signature.contract)
}
inline std::string* Signature::mutable_contract() {
  std::string* _s = _internal_mutable_contract();
  // @@protoc_insertion_point(field_mutable:proto.Signature.contract)
  return _s;
}
inline const std::string& Signature::_internal_contract() const {
  if (_internal_has_contract()) {
    return _impl_.signature_.contract_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Signature::_internal_set_contract(const std::string& value) {
  if (!_internal_has_contract()) {
    clear_signature();
    set_has_contract();
    _impl_.signature_.contract_.InitDefault();
  }
  _impl_.signature_.contract_.Set(value, GetArenaForAllocation());
}
inline std::string* Signature::_internal_mutable_contract() {
  if (!_internal_has_contract()) {
    clear_signature();
    set_has_contract();
    _impl_.signature_.contract_.InitDefault();
  }
  return _impl_.signature_.contract_.Mutable(      GetArenaForAllocation());
}
inline std::string* Signature::release_contract() {
  // @@protoc_insertion_point(field_release:proto.Signature.contract)
  if (_internal_has_contract()) {
    clear_has_signature();
    return _impl_.signature_.contract_.Release();
  } else {
    return nullptr;
  }
}
inline void Signature::set_allocated_contract(std::string* contract) {
  if (has_signature()) {
    clear_signature();
  }
  if (contract != nullptr) {
    set_has_contract();
    _impl_.signature_.contract_.InitAllocated(contract, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Signature.contract)
}

// bytes ed25519 = 2;
inline bool Signature::_internal_has_ed25519() const {
  return signature_case() == kEd25519;
}
inline bool Signature::has_ed25519() const {
  return _internal_has_ed25519();
}
inline void Signature::set_has_ed25519() {
  _impl_._oneof_case_[0] = kEd25519;
}
inline void Signature::clear_ed25519() {
  if (_internal_has_ed25519()) {
    _impl_.signature_.ed25519_.Destroy();
    clear_has_signature();
  }
}
inline const std::string& Signature::ed25519() const {
  // @@protoc_insertion_point(field_get:proto.Signature.ed25519)
  return _internal_ed25519();
}
template <typename ArgT0, typename... ArgT>
inline void Signature::set_ed25519(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_ed25519()) {
    clear_signature();
    set_has_ed25519();
    _impl_.signature_.ed25519_.InitDefault();
  }
  _impl_.signature_.ed25519_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Signature.ed25519)
}
inline std::string* Signature::mutable_ed25519() {
  std::string* _s = _internal_mutable_ed25519();
  // @@protoc_insertion_point(field_mutable:proto.Signature.ed25519)
  return _s;
}
inline const std::string& Signature::_internal_ed25519() const {
  if (_internal_has_ed25519()) {
    return _impl_.signature_.ed25519_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Signature::_internal_set_ed25519(const std::string& value) {
  if (!_internal_has_ed25519()) {
    clear_signature();
    set_has_ed25519();
    _impl_.signature_.ed25519_.InitDefault();
  }
  _impl_.signature_.ed25519_.Set(value, GetArenaForAllocation());
}
inline std::string* Signature::_internal_mutable_ed25519() {
  if (!_internal_has_ed25519()) {
    clear_signature();
    set_has_ed25519();
    _impl_.signature_.ed25519_.InitDefault();
  }
  return _impl_.signature_.ed25519_.Mutable(      GetArenaForAllocation());
}
inline std::string* Signature::release_ed25519() {
  // @@protoc_insertion_point(field_release:proto.Signature.ed25519)
  if (_internal_has_ed25519()) {
    clear_has_signature();
    return _impl_.signature_.ed25519_.Release();
  } else {
    return nullptr;
  }
}
inline void Signature::set_allocated_ed25519(std::string* ed25519) {
  if (has_signature()) {
    clear_signature();
  }
  if (ed25519 != nullptr) {
    set_has_ed25519();
    _impl_.signature_.ed25519_.InitAllocated(ed25519, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Signature.ed25519)
}

// bytes RSA_3072 = 3;
inline bool Signature::_internal_has_rsa_3072() const {
  return signature_case() == kRSA3072;
}
inline bool Signature::has_rsa_3072() const {
  return _internal_has_rsa_3072();
}
inline void Signature::set_has_rsa_3072() {
  _impl_._oneof_case_[0] = kRSA3072;
}
inline void Signature::clear_rsa_3072() {
  if (_internal_has_rsa_3072()) {
    _impl_.signature_.rsa_3072_.Destroy();
    clear_has_signature();
  }
}
inline const std::string& Signature::rsa_3072() const {
  // @@protoc_insertion_point(field_get:proto.Signature.RSA_3072)
  return _internal_rsa_3072();
}
template <typename ArgT0, typename... ArgT>
inline void Signature::set_rsa_3072(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_rsa_3072()) {
    clear_signature();
    set_has_rsa_3072();
    _impl_.signature_.rsa_3072_.InitDefault();
  }
  _impl_.signature_.rsa_3072_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Signature.RSA_3072)
}
inline std::string* Signature::mutable_rsa_3072() {
  std::string* _s = _internal_mutable_rsa_3072();
  // @@protoc_insertion_point(field_mutable:proto.Signature.RSA_3072)
  return _s;
}
inline const std::string& Signature::_internal_rsa_3072() const {
  if (_internal_has_rsa_3072()) {
    return _impl_.signature_.rsa_3072_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Signature::_internal_set_rsa_3072(const std::string& value) {
  if (!_internal_has_rsa_3072()) {
    clear_signature();
    set_has_rsa_3072();
    _impl_.signature_.rsa_3072_.InitDefault();
  }
  _impl_.signature_.rsa_3072_.Set(value, GetArenaForAllocation());
}
inline std::string* Signature::_internal_mutable_rsa_3072() {
  if (!_internal_has_rsa_3072()) {
    clear_signature();
    set_has_rsa_3072();
    _impl_.signature_.rsa_3072_.InitDefault();
  }
  return _impl_.signature_.rsa_3072_.Mutable(      GetArenaForAllocation());
}
inline std::string* Signature::release_rsa_3072() {
  // @@protoc_insertion_point(field_release:proto.Signature.RSA_3072)
  if (_internal_has_rsa_3072()) {
    clear_has_signature();
    return _impl_.signature_.rsa_3072_.Release();
  } else {
    return nullptr;
  }
}
inline void Signature::set_allocated_rsa_3072(std::string* rsa_3072) {
  if (has_signature()) {
    clear_signature();
  }
  if (rsa_3072 != nullptr) {
    set_has_rsa_3072();
    _impl_.signature_.rsa_3072_.InitAllocated(rsa_3072, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Signature.RSA_3072)
}

// bytes ECDSA_384 = 4;
inline bool Signature::_internal_has_ecdsa_384() const {
  return signature_case() == kECDSA384;
}
inline bool Signature::has_ecdsa_384() const {
  return _internal_has_ecdsa_384();
}
inline void Signature::set_has_ecdsa_384() {
  _impl_._oneof_case_[0] = kECDSA384;
}
inline void Signature::clear_ecdsa_384() {
  if (_internal_has_ecdsa_384()) {
    _impl_.signature_.ecdsa_384_.Destroy();
    clear_has_signature();
  }
}
inline const std::string& Signature::ecdsa_384() const {
  // @@protoc_insertion_point(field_get:proto.Signature.ECDSA_384)
  return _internal_ecdsa_384();
}
template <typename ArgT0, typename... ArgT>
inline void Signature::set_ecdsa_384(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_ecdsa_384()) {
    clear_signature();
    set_has_ecdsa_384();
    _impl_.signature_.ecdsa_384_.InitDefault();
  }
  _impl_.signature_.ecdsa_384_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Signature.ECDSA_384)
}
inline std::string* Signature::mutable_ecdsa_384() {
  std::string* _s = _internal_mutable_ecdsa_384();
  // @@protoc_insertion_point(field_mutable:proto.Signature.ECDSA_384)
  return _s;
}
inline const std::string& Signature::_internal_ecdsa_384() const {
  if (_internal_has_ecdsa_384()) {
    return _impl_.signature_.ecdsa_384_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Signature::_internal_set_ecdsa_384(const std::string& value) {
  if (!_internal_has_ecdsa_384()) {
    clear_signature();
    set_has_ecdsa_384();
    _impl_.signature_.ecdsa_384_.InitDefault();
  }
  _impl_.signature_.ecdsa_384_.Set(value, GetArenaForAllocation());
}
inline std::string* Signature::_internal_mutable_ecdsa_384() {
  if (!_internal_has_ecdsa_384()) {
    clear_signature();
    set_has_ecdsa_384();
    _impl_.signature_.ecdsa_384_.InitDefault();
  }
  return _impl_.signature_.ecdsa_384_.Mutable(      GetArenaForAllocation());
}
inline std::string* Signature::release_ecdsa_384() {
  // @@protoc_insertion_point(field_release:proto.Signature.ECDSA_384)
  if (_internal_has_ecdsa_384()) {
    clear_has_signature();
    return _impl_.signature_.ecdsa_384_.Release();
  } else {
    return nullptr;
  }
}
inline void Signature::set_allocated_ecdsa_384(std::string* ecdsa_384) {
  if (has_signature()) {
    clear_signature();
  }
  if (ecdsa_384 != nullptr) {
    set_has_ecdsa_384();
    _impl_.signature_.ecdsa_384_.InitAllocated(ecdsa_384, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Signature.ECDSA_384)
}

// .proto.ThresholdSignature thresholdSignature = 5;
inline bool Signature::_internal_has_thresholdsignature() const {
  return signature_case() == kThresholdSignature;
}
inline bool Signature::has_thresholdsignature() const {
  return _internal_has_thresholdsignature();
}
inline void Signature::set_has_thresholdsignature() {
  _impl_._oneof_case_[0] = kThresholdSignature;
}
inline void Signature::clear_thresholdsignature() {
  if (_internal_has_thresholdsignature()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.signature_.thresholdsignature_;
    }
    clear_has_signature();
  }
}
inline ::proto::ThresholdSignature* Signature::release_thresholdsignature() {
  // @@protoc_insertion_point(field_release:proto.Signature.thresholdSignature)
  if (_internal_has_thresholdsignature()) {
    clear_has_signature();
    ::proto::ThresholdSignature* temp = _impl_.signature_.thresholdsignature_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.signature_.thresholdsignature_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ThresholdSignature& Signature::_internal_thresholdsignature() const {
  return _internal_has_thresholdsignature()
      ? *_impl_.signature_.thresholdsignature_
      : reinterpret_cast< ::proto::ThresholdSignature&>(::proto::_ThresholdSignature_default_instance_);
}
inline const ::proto::ThresholdSignature& Signature::thresholdsignature() const {
  // @@protoc_insertion_point(field_get:proto.Signature.thresholdSignature)
  return _internal_thresholdsignature();
}
inline ::proto::ThresholdSignature* Signature::unsafe_arena_release_thresholdsignature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Signature.thresholdSignature)
  if (_internal_has_thresholdsignature()) {
    clear_has_signature();
    ::proto::ThresholdSignature* temp = _impl_.signature_.thresholdsignature_;
    _impl_.signature_.thresholdsignature_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Signature::unsafe_arena_set_allocated_thresholdsignature(::proto::ThresholdSignature* thresholdsignature) {
  clear_signature();
  if (thresholdsignature) {
    set_has_thresholdsignature();
    _impl_.signature_.thresholdsignature_ = thresholdsignature;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Signature.thresholdSignature)
}
inline ::proto::ThresholdSignature* Signature::_internal_mutable_thresholdsignature() {
  if (!_internal_has_thresholdsignature()) {
    clear_signature();
    set_has_thresholdsignature();
    _impl_.signature_.thresholdsignature_ = CreateMaybeMessage< ::proto::ThresholdSignature >(GetArenaForAllocation());
  }
  return _impl_.signature_.thresholdsignature_;
}
inline ::proto::ThresholdSignature* Signature::mutable_thresholdsignature() {
  ::proto::ThresholdSignature* _msg = _internal_mutable_thresholdsignature();
  // @@protoc_insertion_point(field_mutable:proto.Signature.thresholdSignature)
  return _msg;
}

// .proto.SignatureList signatureList = 6;
inline bool Signature::_internal_has_signaturelist() const {
  return signature_case() == kSignatureList;
}
inline bool Signature::has_signaturelist() const {
  return _internal_has_signaturelist();
}
inline void Signature::set_has_signaturelist() {
  _impl_._oneof_case_[0] = kSignatureList;
}
inline void Signature::clear_signaturelist() {
  if (_internal_has_signaturelist()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.signature_.signaturelist_;
    }
    clear_has_signature();
  }
}
inline ::proto::SignatureList* Signature::release_signaturelist() {
  // @@protoc_insertion_point(field_release:proto.Signature.signatureList)
  if (_internal_has_signaturelist()) {
    clear_has_signature();
    ::proto::SignatureList* temp = _impl_.signature_.signaturelist_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.signature_.signaturelist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::SignatureList& Signature::_internal_signaturelist() const {
  return _internal_has_signaturelist()
      ? *_impl_.signature_.signaturelist_
      : reinterpret_cast< ::proto::SignatureList&>(::proto::_SignatureList_default_instance_);
}
inline const ::proto::SignatureList& Signature::signaturelist() const {
  // @@protoc_insertion_point(field_get:proto.Signature.signatureList)
  return _internal_signaturelist();
}
inline ::proto::SignatureList* Signature::unsafe_arena_release_signaturelist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Signature.signatureList)
  if (_internal_has_signaturelist()) {
    clear_has_signature();
    ::proto::SignatureList* temp = _impl_.signature_.signaturelist_;
    _impl_.signature_.signaturelist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Signature::unsafe_arena_set_allocated_signaturelist(::proto::SignatureList* signaturelist) {
  clear_signature();
  if (signaturelist) {
    set_has_signaturelist();
    _impl_.signature_.signaturelist_ = signaturelist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Signature.signatureList)
}
inline ::proto::SignatureList* Signature::_internal_mutable_signaturelist() {
  if (!_internal_has_signaturelist()) {
    clear_signature();
    set_has_signaturelist();
    _impl_.signature_.signaturelist_ = CreateMaybeMessage< ::proto::SignatureList >(GetArenaForAllocation());
  }
  return _impl_.signature_.signaturelist_;
}
inline ::proto::SignatureList* Signature::mutable_signaturelist() {
  ::proto::SignatureList* _msg = _internal_mutable_signaturelist();
  // @@protoc_insertion_point(field_mutable:proto.Signature.signatureList)
  return _msg;
}

inline bool Signature::has_signature() const {
  return signature_case() != SIGNATURE_NOT_SET;
}
inline void Signature::clear_has_signature() {
  _impl_._oneof_case_[0] = SIGNATURE_NOT_SET;
}
inline Signature::SignatureCase Signature::signature_case() const {
  return Signature::SignatureCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ThresholdSignature

// .proto.SignatureList sigs = 2;
inline bool ThresholdSignature::_internal_has_sigs() const {
  return this != internal_default_instance() && _impl_.sigs_ != nullptr;
}
inline bool ThresholdSignature::has_sigs() const {
  return _internal_has_sigs();
}
inline void ThresholdSignature::clear_sigs() {
  if (GetArenaForAllocation() == nullptr && _impl_.sigs_ != nullptr) {
    delete _impl_.sigs_;
  }
  _impl_.sigs_ = nullptr;
}
inline const ::proto::SignatureList& ThresholdSignature::_internal_sigs() const {
  const ::proto::SignatureList* p = _impl_.sigs_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::SignatureList&>(
      ::proto::_SignatureList_default_instance_);
}
inline const ::proto::SignatureList& ThresholdSignature::sigs() const {
  // @@protoc_insertion_point(field_get:proto.ThresholdSignature.sigs)
  return _internal_sigs();
}
inline void ThresholdSignature::unsafe_arena_set_allocated_sigs(
    ::proto::SignatureList* sigs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sigs_);
  }
  _impl_.sigs_ = sigs;
  if (sigs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ThresholdSignature.sigs)
}
inline ::proto::SignatureList* ThresholdSignature::release_sigs() {
  
  ::proto::SignatureList* temp = _impl_.sigs_;
  _impl_.sigs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::SignatureList* ThresholdSignature::unsafe_arena_release_sigs() {
  // @@protoc_insertion_point(field_release:proto.ThresholdSignature.sigs)
  
  ::proto::SignatureList* temp = _impl_.sigs_;
  _impl_.sigs_ = nullptr;
  return temp;
}
inline ::proto::SignatureList* ThresholdSignature::_internal_mutable_sigs() {
  
  if (_impl_.sigs_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::SignatureList>(GetArenaForAllocation());
    _impl_.sigs_ = p;
  }
  return _impl_.sigs_;
}
inline ::proto::SignatureList* ThresholdSignature::mutable_sigs() {
  ::proto::SignatureList* _msg = _internal_mutable_sigs();
  // @@protoc_insertion_point(field_mutable:proto.ThresholdSignature.sigs)
  return _msg;
}
inline void ThresholdSignature::set_allocated_sigs(::proto::SignatureList* sigs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sigs_;
  }
  if (sigs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sigs);
    if (message_arena != submessage_arena) {
      sigs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sigs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sigs_ = sigs;
  // @@protoc_insertion_point(field_set_allocated:proto.ThresholdSignature.sigs)
}

// -------------------------------------------------------------------

// SignatureList

// repeated .proto.Signature sigs = 2;
inline int SignatureList::_internal_sigs_size() const {
  return _impl_.sigs_.size();
}
inline int SignatureList::sigs_size() const {
  return _internal_sigs_size();
}
inline void SignatureList::clear_sigs() {
  _impl_.sigs_.Clear();
}
inline ::proto::Signature* SignatureList::mutable_sigs(int index) {
  // @@protoc_insertion_point(field_mutable:proto.SignatureList.sigs)
  return _impl_.sigs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Signature >*
SignatureList::mutable_sigs() {
  // @@protoc_insertion_point(field_mutable_list:proto.SignatureList.sigs)
  return &_impl_.sigs_;
}
inline const ::proto::Signature& SignatureList::_internal_sigs(int index) const {
  return _impl_.sigs_.Get(index);
}
inline const ::proto::Signature& SignatureList::sigs(int index) const {
  // @@protoc_insertion_point(field_get:proto.SignatureList.sigs)
  return _internal_sigs(index);
}
inline ::proto::Signature* SignatureList::_internal_add_sigs() {
  return _impl_.sigs_.Add();
}
inline ::proto::Signature* SignatureList::add_sigs() {
  ::proto::Signature* _add = _internal_add_sigs();
  // @@protoc_insertion_point(field_add:proto.SignatureList.sigs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Signature >&
SignatureList::sigs() const {
  // @@protoc_insertion_point(field_list:proto.SignatureList.sigs)
  return _impl_.sigs_;
}

// -------------------------------------------------------------------

// SignaturePair

// bytes pubKeyPrefix = 1;
inline void SignaturePair::clear_pubkeyprefix() {
  _impl_.pubkeyprefix_.ClearToEmpty();
}
inline const std::string& SignaturePair::pubkeyprefix() const {
  // @@protoc_insertion_point(field_get:proto.SignaturePair.pubKeyPrefix)
  return _internal_pubkeyprefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignaturePair::set_pubkeyprefix(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pubkeyprefix_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SignaturePair.pubKeyPrefix)
}
inline std::string* SignaturePair::mutable_pubkeyprefix() {
  std::string* _s = _internal_mutable_pubkeyprefix();
  // @@protoc_insertion_point(field_mutable:proto.SignaturePair.pubKeyPrefix)
  return _s;
}
inline const std::string& SignaturePair::_internal_pubkeyprefix() const {
  return _impl_.pubkeyprefix_.Get();
}
inline void SignaturePair::_internal_set_pubkeyprefix(const std::string& value) {
  
  _impl_.pubkeyprefix_.Set(value, GetArenaForAllocation());
}
inline std::string* SignaturePair::_internal_mutable_pubkeyprefix() {
  
  return _impl_.pubkeyprefix_.Mutable(GetArenaForAllocation());
}
inline std::string* SignaturePair::release_pubkeyprefix() {
  // @@protoc_insertion_point(field_release:proto.SignaturePair.pubKeyPrefix)
  return _impl_.pubkeyprefix_.Release();
}
inline void SignaturePair::set_allocated_pubkeyprefix(std::string* pubkeyprefix) {
  if (pubkeyprefix != nullptr) {
    
  } else {
    
  }
  _impl_.pubkeyprefix_.SetAllocated(pubkeyprefix, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pubkeyprefix_.IsDefault()) {
    _impl_.pubkeyprefix_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.SignaturePair.pubKeyPrefix)
}

// bytes contract = 2;
inline bool SignaturePair::_internal_has_contract() const {
  return signature_case() == kContract;
}
inline bool SignaturePair::has_contract() const {
  return _internal_has_contract();
}
inline void SignaturePair::set_has_contract() {
  _impl_._oneof_case_[0] = kContract;
}
inline void SignaturePair::clear_contract() {
  if (_internal_has_contract()) {
    _impl_.signature_.contract_.Destroy();
    clear_has_signature();
  }
}
inline const std::string& SignaturePair::contract() const {
  // @@protoc_insertion_point(field_get:proto.SignaturePair.contract)
  return _internal_contract();
}
template <typename ArgT0, typename... ArgT>
inline void SignaturePair::set_contract(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_contract()) {
    clear_signature();
    set_has_contract();
    _impl_.signature_.contract_.InitDefault();
  }
  _impl_.signature_.contract_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SignaturePair.contract)
}
inline std::string* SignaturePair::mutable_contract() {
  std::string* _s = _internal_mutable_contract();
  // @@protoc_insertion_point(field_mutable:proto.SignaturePair.contract)
  return _s;
}
inline const std::string& SignaturePair::_internal_contract() const {
  if (_internal_has_contract()) {
    return _impl_.signature_.contract_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SignaturePair::_internal_set_contract(const std::string& value) {
  if (!_internal_has_contract()) {
    clear_signature();
    set_has_contract();
    _impl_.signature_.contract_.InitDefault();
  }
  _impl_.signature_.contract_.Set(value, GetArenaForAllocation());
}
inline std::string* SignaturePair::_internal_mutable_contract() {
  if (!_internal_has_contract()) {
    clear_signature();
    set_has_contract();
    _impl_.signature_.contract_.InitDefault();
  }
  return _impl_.signature_.contract_.Mutable(      GetArenaForAllocation());
}
inline std::string* SignaturePair::release_contract() {
  // @@protoc_insertion_point(field_release:proto.SignaturePair.contract)
  if (_internal_has_contract()) {
    clear_has_signature();
    return _impl_.signature_.contract_.Release();
  } else {
    return nullptr;
  }
}
inline void SignaturePair::set_allocated_contract(std::string* contract) {
  if (has_signature()) {
    clear_signature();
  }
  if (contract != nullptr) {
    set_has_contract();
    _impl_.signature_.contract_.InitAllocated(contract, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.SignaturePair.contract)
}

// bytes ed25519 = 3;
inline bool SignaturePair::_internal_has_ed25519() const {
  return signature_case() == kEd25519;
}
inline bool SignaturePair::has_ed25519() const {
  return _internal_has_ed25519();
}
inline void SignaturePair::set_has_ed25519() {
  _impl_._oneof_case_[0] = kEd25519;
}
inline void SignaturePair::clear_ed25519() {
  if (_internal_has_ed25519()) {
    _impl_.signature_.ed25519_.Destroy();
    clear_has_signature();
  }
}
inline const std::string& SignaturePair::ed25519() const {
  // @@protoc_insertion_point(field_get:proto.SignaturePair.ed25519)
  return _internal_ed25519();
}
template <typename ArgT0, typename... ArgT>
inline void SignaturePair::set_ed25519(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_ed25519()) {
    clear_signature();
    set_has_ed25519();
    _impl_.signature_.ed25519_.InitDefault();
  }
  _impl_.signature_.ed25519_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SignaturePair.ed25519)
}
inline std::string* SignaturePair::mutable_ed25519() {
  std::string* _s = _internal_mutable_ed25519();
  // @@protoc_insertion_point(field_mutable:proto.SignaturePair.ed25519)
  return _s;
}
inline const std::string& SignaturePair::_internal_ed25519() const {
  if (_internal_has_ed25519()) {
    return _impl_.signature_.ed25519_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SignaturePair::_internal_set_ed25519(const std::string& value) {
  if (!_internal_has_ed25519()) {
    clear_signature();
    set_has_ed25519();
    _impl_.signature_.ed25519_.InitDefault();
  }
  _impl_.signature_.ed25519_.Set(value, GetArenaForAllocation());
}
inline std::string* SignaturePair::_internal_mutable_ed25519() {
  if (!_internal_has_ed25519()) {
    clear_signature();
    set_has_ed25519();
    _impl_.signature_.ed25519_.InitDefault();
  }
  return _impl_.signature_.ed25519_.Mutable(      GetArenaForAllocation());
}
inline std::string* SignaturePair::release_ed25519() {
  // @@protoc_insertion_point(field_release:proto.SignaturePair.ed25519)
  if (_internal_has_ed25519()) {
    clear_has_signature();
    return _impl_.signature_.ed25519_.Release();
  } else {
    return nullptr;
  }
}
inline void SignaturePair::set_allocated_ed25519(std::string* ed25519) {
  if (has_signature()) {
    clear_signature();
  }
  if (ed25519 != nullptr) {
    set_has_ed25519();
    _impl_.signature_.ed25519_.InitAllocated(ed25519, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.SignaturePair.ed25519)
}

// bytes RSA_3072 = 4;
inline bool SignaturePair::_internal_has_rsa_3072() const {
  return signature_case() == kRSA3072;
}
inline bool SignaturePair::has_rsa_3072() const {
  return _internal_has_rsa_3072();
}
inline void SignaturePair::set_has_rsa_3072() {
  _impl_._oneof_case_[0] = kRSA3072;
}
inline void SignaturePair::clear_rsa_3072() {
  if (_internal_has_rsa_3072()) {
    _impl_.signature_.rsa_3072_.Destroy();
    clear_has_signature();
  }
}
inline const std::string& SignaturePair::rsa_3072() const {
  // @@protoc_insertion_point(field_get:proto.SignaturePair.RSA_3072)
  return _internal_rsa_3072();
}
template <typename ArgT0, typename... ArgT>
inline void SignaturePair::set_rsa_3072(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_rsa_3072()) {
    clear_signature();
    set_has_rsa_3072();
    _impl_.signature_.rsa_3072_.InitDefault();
  }
  _impl_.signature_.rsa_3072_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SignaturePair.RSA_3072)
}
inline std::string* SignaturePair::mutable_rsa_3072() {
  std::string* _s = _internal_mutable_rsa_3072();
  // @@protoc_insertion_point(field_mutable:proto.SignaturePair.RSA_3072)
  return _s;
}
inline const std::string& SignaturePair::_internal_rsa_3072() const {
  if (_internal_has_rsa_3072()) {
    return _impl_.signature_.rsa_3072_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SignaturePair::_internal_set_rsa_3072(const std::string& value) {
  if (!_internal_has_rsa_3072()) {
    clear_signature();
    set_has_rsa_3072();
    _impl_.signature_.rsa_3072_.InitDefault();
  }
  _impl_.signature_.rsa_3072_.Set(value, GetArenaForAllocation());
}
inline std::string* SignaturePair::_internal_mutable_rsa_3072() {
  if (!_internal_has_rsa_3072()) {
    clear_signature();
    set_has_rsa_3072();
    _impl_.signature_.rsa_3072_.InitDefault();
  }
  return _impl_.signature_.rsa_3072_.Mutable(      GetArenaForAllocation());
}
inline std::string* SignaturePair::release_rsa_3072() {
  // @@protoc_insertion_point(field_release:proto.SignaturePair.RSA_3072)
  if (_internal_has_rsa_3072()) {
    clear_has_signature();
    return _impl_.signature_.rsa_3072_.Release();
  } else {
    return nullptr;
  }
}
inline void SignaturePair::set_allocated_rsa_3072(std::string* rsa_3072) {
  if (has_signature()) {
    clear_signature();
  }
  if (rsa_3072 != nullptr) {
    set_has_rsa_3072();
    _impl_.signature_.rsa_3072_.InitAllocated(rsa_3072, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.SignaturePair.RSA_3072)
}

// bytes ECDSA_384 = 5;
inline bool SignaturePair::_internal_has_ecdsa_384() const {
  return signature_case() == kECDSA384;
}
inline bool SignaturePair::has_ecdsa_384() const {
  return _internal_has_ecdsa_384();
}
inline void SignaturePair::set_has_ecdsa_384() {
  _impl_._oneof_case_[0] = kECDSA384;
}
inline void SignaturePair::clear_ecdsa_384() {
  if (_internal_has_ecdsa_384()) {
    _impl_.signature_.ecdsa_384_.Destroy();
    clear_has_signature();
  }
}
inline const std::string& SignaturePair::ecdsa_384() const {
  // @@protoc_insertion_point(field_get:proto.SignaturePair.ECDSA_384)
  return _internal_ecdsa_384();
}
template <typename ArgT0, typename... ArgT>
inline void SignaturePair::set_ecdsa_384(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_ecdsa_384()) {
    clear_signature();
    set_has_ecdsa_384();
    _impl_.signature_.ecdsa_384_.InitDefault();
  }
  _impl_.signature_.ecdsa_384_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SignaturePair.ECDSA_384)
}
inline std::string* SignaturePair::mutable_ecdsa_384() {
  std::string* _s = _internal_mutable_ecdsa_384();
  // @@protoc_insertion_point(field_mutable:proto.SignaturePair.ECDSA_384)
  return _s;
}
inline const std::string& SignaturePair::_internal_ecdsa_384() const {
  if (_internal_has_ecdsa_384()) {
    return _impl_.signature_.ecdsa_384_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SignaturePair::_internal_set_ecdsa_384(const std::string& value) {
  if (!_internal_has_ecdsa_384()) {
    clear_signature();
    set_has_ecdsa_384();
    _impl_.signature_.ecdsa_384_.InitDefault();
  }
  _impl_.signature_.ecdsa_384_.Set(value, GetArenaForAllocation());
}
inline std::string* SignaturePair::_internal_mutable_ecdsa_384() {
  if (!_internal_has_ecdsa_384()) {
    clear_signature();
    set_has_ecdsa_384();
    _impl_.signature_.ecdsa_384_.InitDefault();
  }
  return _impl_.signature_.ecdsa_384_.Mutable(      GetArenaForAllocation());
}
inline std::string* SignaturePair::release_ecdsa_384() {
  // @@protoc_insertion_point(field_release:proto.SignaturePair.ECDSA_384)
  if (_internal_has_ecdsa_384()) {
    clear_has_signature();
    return _impl_.signature_.ecdsa_384_.Release();
  } else {
    return nullptr;
  }
}
inline void SignaturePair::set_allocated_ecdsa_384(std::string* ecdsa_384) {
  if (has_signature()) {
    clear_signature();
  }
  if (ecdsa_384 != nullptr) {
    set_has_ecdsa_384();
    _impl_.signature_.ecdsa_384_.InitAllocated(ecdsa_384, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.SignaturePair.ECDSA_384)
}

// bytes ECDSA_secp256k1 = 6;
inline bool SignaturePair::_internal_has_ecdsa_secp256k1() const {
  return signature_case() == kECDSASecp256K1;
}
inline bool SignaturePair::has_ecdsa_secp256k1() const {
  return _internal_has_ecdsa_secp256k1();
}
inline void SignaturePair::set_has_ecdsa_secp256k1() {
  _impl_._oneof_case_[0] = kECDSASecp256K1;
}
inline void SignaturePair::clear_ecdsa_secp256k1() {
  if (_internal_has_ecdsa_secp256k1()) {
    _impl_.signature_.ecdsa_secp256k1_.Destroy();
    clear_has_signature();
  }
}
inline const std::string& SignaturePair::ecdsa_secp256k1() const {
  // @@protoc_insertion_point(field_get:proto.SignaturePair.ECDSA_secp256k1)
  return _internal_ecdsa_secp256k1();
}
template <typename ArgT0, typename... ArgT>
inline void SignaturePair::set_ecdsa_secp256k1(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_ecdsa_secp256k1()) {
    clear_signature();
    set_has_ecdsa_secp256k1();
    _impl_.signature_.ecdsa_secp256k1_.InitDefault();
  }
  _impl_.signature_.ecdsa_secp256k1_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SignaturePair.ECDSA_secp256k1)
}
inline std::string* SignaturePair::mutable_ecdsa_secp256k1() {
  std::string* _s = _internal_mutable_ecdsa_secp256k1();
  // @@protoc_insertion_point(field_mutable:proto.SignaturePair.ECDSA_secp256k1)
  return _s;
}
inline const std::string& SignaturePair::_internal_ecdsa_secp256k1() const {
  if (_internal_has_ecdsa_secp256k1()) {
    return _impl_.signature_.ecdsa_secp256k1_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SignaturePair::_internal_set_ecdsa_secp256k1(const std::string& value) {
  if (!_internal_has_ecdsa_secp256k1()) {
    clear_signature();
    set_has_ecdsa_secp256k1();
    _impl_.signature_.ecdsa_secp256k1_.InitDefault();
  }
  _impl_.signature_.ecdsa_secp256k1_.Set(value, GetArenaForAllocation());
}
inline std::string* SignaturePair::_internal_mutable_ecdsa_secp256k1() {
  if (!_internal_has_ecdsa_secp256k1()) {
    clear_signature();
    set_has_ecdsa_secp256k1();
    _impl_.signature_.ecdsa_secp256k1_.InitDefault();
  }
  return _impl_.signature_.ecdsa_secp256k1_.Mutable(      GetArenaForAllocation());
}
inline std::string* SignaturePair::release_ecdsa_secp256k1() {
  // @@protoc_insertion_point(field_release:proto.SignaturePair.ECDSA_secp256k1)
  if (_internal_has_ecdsa_secp256k1()) {
    clear_has_signature();
    return _impl_.signature_.ecdsa_secp256k1_.Release();
  } else {
    return nullptr;
  }
}
inline void SignaturePair::set_allocated_ecdsa_secp256k1(std::string* ecdsa_secp256k1) {
  if (has_signature()) {
    clear_signature();
  }
  if (ecdsa_secp256k1 != nullptr) {
    set_has_ecdsa_secp256k1();
    _impl_.signature_.ecdsa_secp256k1_.InitAllocated(ecdsa_secp256k1, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.SignaturePair.ECDSA_secp256k1)
}

inline bool SignaturePair::has_signature() const {
  return signature_case() != SIGNATURE_NOT_SET;
}
inline void SignaturePair::clear_has_signature() {
  _impl_._oneof_case_[0] = SIGNATURE_NOT_SET;
}
inline SignaturePair::SignatureCase SignaturePair::signature_case() const {
  return SignaturePair::SignatureCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SignatureMap

// repeated .proto.SignaturePair sigPair = 1;
inline int SignatureMap::_internal_sigpair_size() const {
  return _impl_.sigpair_.size();
}
inline int SignatureMap::sigpair_size() const {
  return _internal_sigpair_size();
}
inline void SignatureMap::clear_sigpair() {
  _impl_.sigpair_.Clear();
}
inline ::proto::SignaturePair* SignatureMap::mutable_sigpair(int index) {
  // @@protoc_insertion_point(field_mutable:proto.SignatureMap.sigPair)
  return _impl_.sigpair_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::SignaturePair >*
SignatureMap::mutable_sigpair() {
  // @@protoc_insertion_point(field_mutable_list:proto.SignatureMap.sigPair)
  return &_impl_.sigpair_;
}
inline const ::proto::SignaturePair& SignatureMap::_internal_sigpair(int index) const {
  return _impl_.sigpair_.Get(index);
}
inline const ::proto::SignaturePair& SignatureMap::sigpair(int index) const {
  // @@protoc_insertion_point(field_get:proto.SignatureMap.sigPair)
  return _internal_sigpair(index);
}
inline ::proto::SignaturePair* SignatureMap::_internal_add_sigpair() {
  return _impl_.sigpair_.Add();
}
inline ::proto::SignaturePair* SignatureMap::add_sigpair() {
  ::proto::SignaturePair* _add = _internal_add_sigpair();
  // @@protoc_insertion_point(field_add:proto.SignatureMap.sigPair)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::SignaturePair >&
SignatureMap::sigpair() const {
  // @@protoc_insertion_point(field_list:proto.SignatureMap.sigPair)
  return _impl_.sigpair_;
}

// -------------------------------------------------------------------

// FeeComponents

// int64 min = 1;
inline void FeeComponents::clear_min() {
  _impl_.min_ = int64_t{0};
}
inline int64_t FeeComponents::_internal_min() const {
  return _impl_.min_;
}
inline int64_t FeeComponents::min() const {
  // @@protoc_insertion_point(field_get:proto.FeeComponents.min)
  return _internal_min();
}
inline void FeeComponents::_internal_set_min(int64_t value) {
  
  _impl_.min_ = value;
}
inline void FeeComponents::set_min(int64_t value) {
  _internal_set_min(value);
  // @@protoc_insertion_point(field_set:proto.FeeComponents.min)
}

// int64 max = 2;
inline void FeeComponents::clear_max() {
  _impl_.max_ = int64_t{0};
}
inline int64_t FeeComponents::_internal_max() const {
  return _impl_.max_;
}
inline int64_t FeeComponents::max() const {
  // @@protoc_insertion_point(field_get:proto.FeeComponents.max)
  return _internal_max();
}
inline void FeeComponents::_internal_set_max(int64_t value) {
  
  _impl_.max_ = value;
}
inline void FeeComponents::set_max(int64_t value) {
  _internal_set_max(value);
  // @@protoc_insertion_point(field_set:proto.FeeComponents.max)
}

// int64 constant = 3;
inline void FeeComponents::clear_constant() {
  _impl_.constant_ = int64_t{0};
}
inline int64_t FeeComponents::_internal_constant() const {
  return _impl_.constant_;
}
inline int64_t FeeComponents::constant() const {
  // @@protoc_insertion_point(field_get:proto.FeeComponents.constant)
  return _internal_constant();
}
inline void FeeComponents::_internal_set_constant(int64_t value) {
  
  _impl_.constant_ = value;
}
inline void FeeComponents::set_constant(int64_t value) {
  _internal_set_constant(value);
  // @@protoc_insertion_point(field_set:proto.FeeComponents.constant)
}

// int64 bpt = 4;
inline void FeeComponents::clear_bpt() {
  _impl_.bpt_ = int64_t{0};
}
inline int64_t FeeComponents::_internal_bpt() const {
  return _impl_.bpt_;
}
inline int64_t FeeComponents::bpt() const {
  // @@protoc_insertion_point(field_get:proto.FeeComponents.bpt)
  return _internal_bpt();
}
inline void FeeComponents::_internal_set_bpt(int64_t value) {
  
  _impl_.bpt_ = value;
}
inline void FeeComponents::set_bpt(int64_t value) {
  _internal_set_bpt(value);
  // @@protoc_insertion_point(field_set:proto.FeeComponents.bpt)
}

// int64 vpt = 5;
inline void FeeComponents::clear_vpt() {
  _impl_.vpt_ = int64_t{0};
}
inline int64_t FeeComponents::_internal_vpt() const {
  return _impl_.vpt_;
}
inline int64_t FeeComponents::vpt() const {
  // @@protoc_insertion_point(field_get:proto.FeeComponents.vpt)
  return _internal_vpt();
}
inline void FeeComponents::_internal_set_vpt(int64_t value) {
  
  _impl_.vpt_ = value;
}
inline void FeeComponents::set_vpt(int64_t value) {
  _internal_set_vpt(value);
  // @@protoc_insertion_point(field_set:proto.FeeComponents.vpt)
}

// int64 rbh = 6;
inline void FeeComponents::clear_rbh() {
  _impl_.rbh_ = int64_t{0};
}
inline int64_t FeeComponents::_internal_rbh() const {
  return _impl_.rbh_;
}
inline int64_t FeeComponents::rbh() const {
  // @@protoc_insertion_point(field_get:proto.FeeComponents.rbh)
  return _internal_rbh();
}
inline void FeeComponents::_internal_set_rbh(int64_t value) {
  
  _impl_.rbh_ = value;
}
inline void FeeComponents::set_rbh(int64_t value) {
  _internal_set_rbh(value);
  // @@protoc_insertion_point(field_set:proto.FeeComponents.rbh)
}

// int64 sbh = 7;
inline void FeeComponents::clear_sbh() {
  _impl_.sbh_ = int64_t{0};
}
inline int64_t FeeComponents::_internal_sbh() const {
  return _impl_.sbh_;
}
inline int64_t FeeComponents::sbh() const {
  // @@protoc_insertion_point(field_get:proto.FeeComponents.sbh)
  return _internal_sbh();
}
inline void FeeComponents::_internal_set_sbh(int64_t value) {
  
  _impl_.sbh_ = value;
}
inline void FeeComponents::set_sbh(int64_t value) {
  _internal_set_sbh(value);
  // @@protoc_insertion_point(field_set:proto.FeeComponents.sbh)
}

// int64 gas = 8;
inline void FeeComponents::clear_gas() {
  _impl_.gas_ = int64_t{0};
}
inline int64_t FeeComponents::_internal_gas() const {
  return _impl_.gas_;
}
inline int64_t FeeComponents::gas() const {
  // @@protoc_insertion_point(field_get:proto.FeeComponents.gas)
  return _internal_gas();
}
inline void FeeComponents::_internal_set_gas(int64_t value) {
  
  _impl_.gas_ = value;
}
inline void FeeComponents::set_gas(int64_t value) {
  _internal_set_gas(value);
  // @@protoc_insertion_point(field_set:proto.FeeComponents.gas)
}

// int64 tv = 9;
inline void FeeComponents::clear_tv() {
  _impl_.tv_ = int64_t{0};
}
inline int64_t FeeComponents::_internal_tv() const {
  return _impl_.tv_;
}
inline int64_t FeeComponents::tv() const {
  // @@protoc_insertion_point(field_get:proto.FeeComponents.tv)
  return _internal_tv();
}
inline void FeeComponents::_internal_set_tv(int64_t value) {
  
  _impl_.tv_ = value;
}
inline void FeeComponents::set_tv(int64_t value) {
  _internal_set_tv(value);
  // @@protoc_insertion_point(field_set:proto.FeeComponents.tv)
}

// int64 bpr = 10;
inline void FeeComponents::clear_bpr() {
  _impl_.bpr_ = int64_t{0};
}
inline int64_t FeeComponents::_internal_bpr() const {
  return _impl_.bpr_;
}
inline int64_t FeeComponents::bpr() const {
  // @@protoc_insertion_point(field_get:proto.FeeComponents.bpr)
  return _internal_bpr();
}
inline void FeeComponents::_internal_set_bpr(int64_t value) {
  
  _impl_.bpr_ = value;
}
inline void FeeComponents::set_bpr(int64_t value) {
  _internal_set_bpr(value);
  // @@protoc_insertion_point(field_set:proto.FeeComponents.bpr)
}

// int64 sbpr = 11;
inline void FeeComponents::clear_sbpr() {
  _impl_.sbpr_ = int64_t{0};
}
inline int64_t FeeComponents::_internal_sbpr() const {
  return _impl_.sbpr_;
}
inline int64_t FeeComponents::sbpr() const {
  // @@protoc_insertion_point(field_get:proto.FeeComponents.sbpr)
  return _internal_sbpr();
}
inline void FeeComponents::_internal_set_sbpr(int64_t value) {
  
  _impl_.sbpr_ = value;
}
inline void FeeComponents::set_sbpr(int64_t value) {
  _internal_set_sbpr(value);
  // @@protoc_insertion_point(field_set:proto.FeeComponents.sbpr)
}

// -------------------------------------------------------------------

// TransactionFeeSchedule

// .proto.HederaFunctionality hederaFunctionality = 1;
inline void TransactionFeeSchedule::clear_hederafunctionality() {
  _impl_.hederafunctionality_ = 0;
}
inline ::proto::HederaFunctionality TransactionFeeSchedule::_internal_hederafunctionality() const {
  return static_cast< ::proto::HederaFunctionality >(_impl_.hederafunctionality_);
}
inline ::proto::HederaFunctionality TransactionFeeSchedule::hederafunctionality() const {
  // @@protoc_insertion_point(field_get:proto.TransactionFeeSchedule.hederaFunctionality)
  return _internal_hederafunctionality();
}
inline void TransactionFeeSchedule::_internal_set_hederafunctionality(::proto::HederaFunctionality value) {
  
  _impl_.hederafunctionality_ = value;
}
inline void TransactionFeeSchedule::set_hederafunctionality(::proto::HederaFunctionality value) {
  _internal_set_hederafunctionality(value);
  // @@protoc_insertion_point(field_set:proto.TransactionFeeSchedule.hederaFunctionality)
}

// .proto.FeeData feeData = 2 [deprecated = true];
inline bool TransactionFeeSchedule::_internal_has_feedata() const {
  return this != internal_default_instance() && _impl_.feedata_ != nullptr;
}
inline bool TransactionFeeSchedule::has_feedata() const {
  return _internal_has_feedata();
}
inline void TransactionFeeSchedule::clear_feedata() {
  if (GetArenaForAllocation() == nullptr && _impl_.feedata_ != nullptr) {
    delete _impl_.feedata_;
  }
  _impl_.feedata_ = nullptr;
}
inline const ::proto::FeeData& TransactionFeeSchedule::_internal_feedata() const {
  const ::proto::FeeData* p = _impl_.feedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::FeeData&>(
      ::proto::_FeeData_default_instance_);
}
inline const ::proto::FeeData& TransactionFeeSchedule::feedata() const {
  // @@protoc_insertion_point(field_get:proto.TransactionFeeSchedule.feeData)
  return _internal_feedata();
}
inline void TransactionFeeSchedule::unsafe_arena_set_allocated_feedata(
    ::proto::FeeData* feedata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.feedata_);
  }
  _impl_.feedata_ = feedata;
  if (feedata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionFeeSchedule.feeData)
}
inline ::proto::FeeData* TransactionFeeSchedule::release_feedata() {
  
  ::proto::FeeData* temp = _impl_.feedata_;
  _impl_.feedata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::FeeData* TransactionFeeSchedule::unsafe_arena_release_feedata() {
  // @@protoc_insertion_point(field_release:proto.TransactionFeeSchedule.feeData)
  
  ::proto::FeeData* temp = _impl_.feedata_;
  _impl_.feedata_ = nullptr;
  return temp;
}
inline ::proto::FeeData* TransactionFeeSchedule::_internal_mutable_feedata() {
  
  if (_impl_.feedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::FeeData>(GetArenaForAllocation());
    _impl_.feedata_ = p;
  }
  return _impl_.feedata_;
}
inline ::proto::FeeData* TransactionFeeSchedule::mutable_feedata() {
  ::proto::FeeData* _msg = _internal_mutable_feedata();
  // @@protoc_insertion_point(field_mutable:proto.TransactionFeeSchedule.feeData)
  return _msg;
}
inline void TransactionFeeSchedule::set_allocated_feedata(::proto::FeeData* feedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.feedata_;
  }
  if (feedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(feedata);
    if (message_arena != submessage_arena) {
      feedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feedata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.feedata_ = feedata;
  // @@protoc_insertion_point(field_set_allocated:proto.TransactionFeeSchedule.feeData)
}

// repeated .proto.FeeData fees = 3;
inline int TransactionFeeSchedule::_internal_fees_size() const {
  return _impl_.fees_.size();
}
inline int TransactionFeeSchedule::fees_size() const {
  return _internal_fees_size();
}
inline void TransactionFeeSchedule::clear_fees() {
  _impl_.fees_.Clear();
}
inline ::proto::FeeData* TransactionFeeSchedule::mutable_fees(int index) {
  // @@protoc_insertion_point(field_mutable:proto.TransactionFeeSchedule.fees)
  return _impl_.fees_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::FeeData >*
TransactionFeeSchedule::mutable_fees() {
  // @@protoc_insertion_point(field_mutable_list:proto.TransactionFeeSchedule.fees)
  return &_impl_.fees_;
}
inline const ::proto::FeeData& TransactionFeeSchedule::_internal_fees(int index) const {
  return _impl_.fees_.Get(index);
}
inline const ::proto::FeeData& TransactionFeeSchedule::fees(int index) const {
  // @@protoc_insertion_point(field_get:proto.TransactionFeeSchedule.fees)
  return _internal_fees(index);
}
inline ::proto::FeeData* TransactionFeeSchedule::_internal_add_fees() {
  return _impl_.fees_.Add();
}
inline ::proto::FeeData* TransactionFeeSchedule::add_fees() {
  ::proto::FeeData* _add = _internal_add_fees();
  // @@protoc_insertion_point(field_add:proto.TransactionFeeSchedule.fees)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::FeeData >&
TransactionFeeSchedule::fees() const {
  // @@protoc_insertion_point(field_list:proto.TransactionFeeSchedule.fees)
  return _impl_.fees_;
}

// -------------------------------------------------------------------

// FeeData

// .proto.FeeComponents nodedata = 1;
inline bool FeeData::_internal_has_nodedata() const {
  return this != internal_default_instance() && _impl_.nodedata_ != nullptr;
}
inline bool FeeData::has_nodedata() const {
  return _internal_has_nodedata();
}
inline void FeeData::clear_nodedata() {
  if (GetArenaForAllocation() == nullptr && _impl_.nodedata_ != nullptr) {
    delete _impl_.nodedata_;
  }
  _impl_.nodedata_ = nullptr;
}
inline const ::proto::FeeComponents& FeeData::_internal_nodedata() const {
  const ::proto::FeeComponents* p = _impl_.nodedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::FeeComponents&>(
      ::proto::_FeeComponents_default_instance_);
}
inline const ::proto::FeeComponents& FeeData::nodedata() const {
  // @@protoc_insertion_point(field_get:proto.FeeData.nodedata)
  return _internal_nodedata();
}
inline void FeeData::unsafe_arena_set_allocated_nodedata(
    ::proto::FeeComponents* nodedata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nodedata_);
  }
  _impl_.nodedata_ = nodedata;
  if (nodedata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FeeData.nodedata)
}
inline ::proto::FeeComponents* FeeData::release_nodedata() {
  
  ::proto::FeeComponents* temp = _impl_.nodedata_;
  _impl_.nodedata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::FeeComponents* FeeData::unsafe_arena_release_nodedata() {
  // @@protoc_insertion_point(field_release:proto.FeeData.nodedata)
  
  ::proto::FeeComponents* temp = _impl_.nodedata_;
  _impl_.nodedata_ = nullptr;
  return temp;
}
inline ::proto::FeeComponents* FeeData::_internal_mutable_nodedata() {
  
  if (_impl_.nodedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::FeeComponents>(GetArenaForAllocation());
    _impl_.nodedata_ = p;
  }
  return _impl_.nodedata_;
}
inline ::proto::FeeComponents* FeeData::mutable_nodedata() {
  ::proto::FeeComponents* _msg = _internal_mutable_nodedata();
  // @@protoc_insertion_point(field_mutable:proto.FeeData.nodedata)
  return _msg;
}
inline void FeeData::set_allocated_nodedata(::proto::FeeComponents* nodedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nodedata_;
  }
  if (nodedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nodedata);
    if (message_arena != submessage_arena) {
      nodedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodedata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nodedata_ = nodedata;
  // @@protoc_insertion_point(field_set_allocated:proto.FeeData.nodedata)
}

// .proto.FeeComponents networkdata = 2;
inline bool FeeData::_internal_has_networkdata() const {
  return this != internal_default_instance() && _impl_.networkdata_ != nullptr;
}
inline bool FeeData::has_networkdata() const {
  return _internal_has_networkdata();
}
inline void FeeData::clear_networkdata() {
  if (GetArenaForAllocation() == nullptr && _impl_.networkdata_ != nullptr) {
    delete _impl_.networkdata_;
  }
  _impl_.networkdata_ = nullptr;
}
inline const ::proto::FeeComponents& FeeData::_internal_networkdata() const {
  const ::proto::FeeComponents* p = _impl_.networkdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::FeeComponents&>(
      ::proto::_FeeComponents_default_instance_);
}
inline const ::proto::FeeComponents& FeeData::networkdata() const {
  // @@protoc_insertion_point(field_get:proto.FeeData.networkdata)
  return _internal_networkdata();
}
inline void FeeData::unsafe_arena_set_allocated_networkdata(
    ::proto::FeeComponents* networkdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.networkdata_);
  }
  _impl_.networkdata_ = networkdata;
  if (networkdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FeeData.networkdata)
}
inline ::proto::FeeComponents* FeeData::release_networkdata() {
  
  ::proto::FeeComponents* temp = _impl_.networkdata_;
  _impl_.networkdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::FeeComponents* FeeData::unsafe_arena_release_networkdata() {
  // @@protoc_insertion_point(field_release:proto.FeeData.networkdata)
  
  ::proto::FeeComponents* temp = _impl_.networkdata_;
  _impl_.networkdata_ = nullptr;
  return temp;
}
inline ::proto::FeeComponents* FeeData::_internal_mutable_networkdata() {
  
  if (_impl_.networkdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::FeeComponents>(GetArenaForAllocation());
    _impl_.networkdata_ = p;
  }
  return _impl_.networkdata_;
}
inline ::proto::FeeComponents* FeeData::mutable_networkdata() {
  ::proto::FeeComponents* _msg = _internal_mutable_networkdata();
  // @@protoc_insertion_point(field_mutable:proto.FeeData.networkdata)
  return _msg;
}
inline void FeeData::set_allocated_networkdata(::proto::FeeComponents* networkdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.networkdata_;
  }
  if (networkdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(networkdata);
    if (message_arena != submessage_arena) {
      networkdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, networkdata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.networkdata_ = networkdata;
  // @@protoc_insertion_point(field_set_allocated:proto.FeeData.networkdata)
}

// .proto.FeeComponents servicedata = 3;
inline bool FeeData::_internal_has_servicedata() const {
  return this != internal_default_instance() && _impl_.servicedata_ != nullptr;
}
inline bool FeeData::has_servicedata() const {
  return _internal_has_servicedata();
}
inline void FeeData::clear_servicedata() {
  if (GetArenaForAllocation() == nullptr && _impl_.servicedata_ != nullptr) {
    delete _impl_.servicedata_;
  }
  _impl_.servicedata_ = nullptr;
}
inline const ::proto::FeeComponents& FeeData::_internal_servicedata() const {
  const ::proto::FeeComponents* p = _impl_.servicedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::FeeComponents&>(
      ::proto::_FeeComponents_default_instance_);
}
inline const ::proto::FeeComponents& FeeData::servicedata() const {
  // @@protoc_insertion_point(field_get:proto.FeeData.servicedata)
  return _internal_servicedata();
}
inline void FeeData::unsafe_arena_set_allocated_servicedata(
    ::proto::FeeComponents* servicedata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.servicedata_);
  }
  _impl_.servicedata_ = servicedata;
  if (servicedata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FeeData.servicedata)
}
inline ::proto::FeeComponents* FeeData::release_servicedata() {
  
  ::proto::FeeComponents* temp = _impl_.servicedata_;
  _impl_.servicedata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::FeeComponents* FeeData::unsafe_arena_release_servicedata() {
  // @@protoc_insertion_point(field_release:proto.FeeData.servicedata)
  
  ::proto::FeeComponents* temp = _impl_.servicedata_;
  _impl_.servicedata_ = nullptr;
  return temp;
}
inline ::proto::FeeComponents* FeeData::_internal_mutable_servicedata() {
  
  if (_impl_.servicedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::FeeComponents>(GetArenaForAllocation());
    _impl_.servicedata_ = p;
  }
  return _impl_.servicedata_;
}
inline ::proto::FeeComponents* FeeData::mutable_servicedata() {
  ::proto::FeeComponents* _msg = _internal_mutable_servicedata();
  // @@protoc_insertion_point(field_mutable:proto.FeeData.servicedata)
  return _msg;
}
inline void FeeData::set_allocated_servicedata(::proto::FeeComponents* servicedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.servicedata_;
  }
  if (servicedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(servicedata);
    if (message_arena != submessage_arena) {
      servicedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, servicedata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.servicedata_ = servicedata;
  // @@protoc_insertion_point(field_set_allocated:proto.FeeData.servicedata)
}

// .proto.SubType subType = 4;
inline void FeeData::clear_subtype() {
  _impl_.subtype_ = 0;
}
inline ::proto::SubType FeeData::_internal_subtype() const {
  return static_cast< ::proto::SubType >(_impl_.subtype_);
}
inline ::proto::SubType FeeData::subtype() const {
  // @@protoc_insertion_point(field_get:proto.FeeData.subType)
  return _internal_subtype();
}
inline void FeeData::_internal_set_subtype(::proto::SubType value) {
  
  _impl_.subtype_ = value;
}
inline void FeeData::set_subtype(::proto::SubType value) {
  _internal_set_subtype(value);
  // @@protoc_insertion_point(field_set:proto.FeeData.subType)
}

// -------------------------------------------------------------------

// FeeSchedule

// repeated .proto.TransactionFeeSchedule transactionFeeSchedule = 1;
inline int FeeSchedule::_internal_transactionfeeschedule_size() const {
  return _impl_.transactionfeeschedule_.size();
}
inline int FeeSchedule::transactionfeeschedule_size() const {
  return _internal_transactionfeeschedule_size();
}
inline void FeeSchedule::clear_transactionfeeschedule() {
  _impl_.transactionfeeschedule_.Clear();
}
inline ::proto::TransactionFeeSchedule* FeeSchedule::mutable_transactionfeeschedule(int index) {
  // @@protoc_insertion_point(field_mutable:proto.FeeSchedule.transactionFeeSchedule)
  return _impl_.transactionfeeschedule_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TransactionFeeSchedule >*
FeeSchedule::mutable_transactionfeeschedule() {
  // @@protoc_insertion_point(field_mutable_list:proto.FeeSchedule.transactionFeeSchedule)
  return &_impl_.transactionfeeschedule_;
}
inline const ::proto::TransactionFeeSchedule& FeeSchedule::_internal_transactionfeeschedule(int index) const {
  return _impl_.transactionfeeschedule_.Get(index);
}
inline const ::proto::TransactionFeeSchedule& FeeSchedule::transactionfeeschedule(int index) const {
  // @@protoc_insertion_point(field_get:proto.FeeSchedule.transactionFeeSchedule)
  return _internal_transactionfeeschedule(index);
}
inline ::proto::TransactionFeeSchedule* FeeSchedule::_internal_add_transactionfeeschedule() {
  return _impl_.transactionfeeschedule_.Add();
}
inline ::proto::TransactionFeeSchedule* FeeSchedule::add_transactionfeeschedule() {
  ::proto::TransactionFeeSchedule* _add = _internal_add_transactionfeeschedule();
  // @@protoc_insertion_point(field_add:proto.FeeSchedule.transactionFeeSchedule)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TransactionFeeSchedule >&
FeeSchedule::transactionfeeschedule() const {
  // @@protoc_insertion_point(field_list:proto.FeeSchedule.transactionFeeSchedule)
  return _impl_.transactionfeeschedule_;
}

// .proto.TimestampSeconds expiryTime = 2;
inline bool FeeSchedule::_internal_has_expirytime() const {
  return this != internal_default_instance() && _impl_.expirytime_ != nullptr;
}
inline bool FeeSchedule::has_expirytime() const {
  return _internal_has_expirytime();
}
inline const ::proto::TimestampSeconds& FeeSchedule::_internal_expirytime() const {
  const ::proto::TimestampSeconds* p = _impl_.expirytime_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::TimestampSeconds&>(
      ::proto::_TimestampSeconds_default_instance_);
}
inline const ::proto::TimestampSeconds& FeeSchedule::expirytime() const {
  // @@protoc_insertion_point(field_get:proto.FeeSchedule.expiryTime)
  return _internal_expirytime();
}
inline void FeeSchedule::unsafe_arena_set_allocated_expirytime(
    ::proto::TimestampSeconds* expirytime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expirytime_);
  }
  _impl_.expirytime_ = expirytime;
  if (expirytime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.FeeSchedule.expiryTime)
}
inline ::proto::TimestampSeconds* FeeSchedule::release_expirytime() {
  
  ::proto::TimestampSeconds* temp = _impl_.expirytime_;
  _impl_.expirytime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::TimestampSeconds* FeeSchedule::unsafe_arena_release_expirytime() {
  // @@protoc_insertion_point(field_release:proto.FeeSchedule.expiryTime)
  
  ::proto::TimestampSeconds* temp = _impl_.expirytime_;
  _impl_.expirytime_ = nullptr;
  return temp;
}
inline ::proto::TimestampSeconds* FeeSchedule::_internal_mutable_expirytime() {
  
  if (_impl_.expirytime_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::TimestampSeconds>(GetArenaForAllocation());
    _impl_.expirytime_ = p;
  }
  return _impl_.expirytime_;
}
inline ::proto::TimestampSeconds* FeeSchedule::mutable_expirytime() {
  ::proto::TimestampSeconds* _msg = _internal_mutable_expirytime();
  // @@protoc_insertion_point(field_mutable:proto.FeeSchedule.expiryTime)
  return _msg;
}
inline void FeeSchedule::set_allocated_expirytime(::proto::TimestampSeconds* expirytime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expirytime_);
  }
  if (expirytime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expirytime));
    if (message_arena != submessage_arena) {
      expirytime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expirytime, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.expirytime_ = expirytime;
  // @@protoc_insertion_point(field_set_allocated:proto.FeeSchedule.expiryTime)
}

// -------------------------------------------------------------------

// CurrentAndNextFeeSchedule

// .proto.FeeSchedule currentFeeSchedule = 1;
inline bool CurrentAndNextFeeSchedule::_internal_has_currentfeeschedule() const {
  return this != internal_default_instance() && _impl_.currentfeeschedule_ != nullptr;
}
inline bool CurrentAndNextFeeSchedule::has_currentfeeschedule() const {
  return _internal_has_currentfeeschedule();
}
inline void CurrentAndNextFeeSchedule::clear_currentfeeschedule() {
  if (GetArenaForAllocation() == nullptr && _impl_.currentfeeschedule_ != nullptr) {
    delete _impl_.currentfeeschedule_;
  }
  _impl_.currentfeeschedule_ = nullptr;
}
inline const ::proto::FeeSchedule& CurrentAndNextFeeSchedule::_internal_currentfeeschedule() const {
  const ::proto::FeeSchedule* p = _impl_.currentfeeschedule_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::FeeSchedule&>(
      ::proto::_FeeSchedule_default_instance_);
}
inline const ::proto::FeeSchedule& CurrentAndNextFeeSchedule::currentfeeschedule() const {
  // @@protoc_insertion_point(field_get:proto.CurrentAndNextFeeSchedule.currentFeeSchedule)
  return _internal_currentfeeschedule();
}
inline void CurrentAndNextFeeSchedule::unsafe_arena_set_allocated_currentfeeschedule(
    ::proto::FeeSchedule* currentfeeschedule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.currentfeeschedule_);
  }
  _impl_.currentfeeschedule_ = currentfeeschedule;
  if (currentfeeschedule) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.CurrentAndNextFeeSchedule.currentFeeSchedule)
}
inline ::proto::FeeSchedule* CurrentAndNextFeeSchedule::release_currentfeeschedule() {
  
  ::proto::FeeSchedule* temp = _impl_.currentfeeschedule_;
  _impl_.currentfeeschedule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::FeeSchedule* CurrentAndNextFeeSchedule::unsafe_arena_release_currentfeeschedule() {
  // @@protoc_insertion_point(field_release:proto.CurrentAndNextFeeSchedule.currentFeeSchedule)
  
  ::proto::FeeSchedule* temp = _impl_.currentfeeschedule_;
  _impl_.currentfeeschedule_ = nullptr;
  return temp;
}
inline ::proto::FeeSchedule* CurrentAndNextFeeSchedule::_internal_mutable_currentfeeschedule() {
  
  if (_impl_.currentfeeschedule_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::FeeSchedule>(GetArenaForAllocation());
    _impl_.currentfeeschedule_ = p;
  }
  return _impl_.currentfeeschedule_;
}
inline ::proto::FeeSchedule* CurrentAndNextFeeSchedule::mutable_currentfeeschedule() {
  ::proto::FeeSchedule* _msg = _internal_mutable_currentfeeschedule();
  // @@protoc_insertion_point(field_mutable:proto.CurrentAndNextFeeSchedule.currentFeeSchedule)
  return _msg;
}
inline void CurrentAndNextFeeSchedule::set_allocated_currentfeeschedule(::proto::FeeSchedule* currentfeeschedule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.currentfeeschedule_;
  }
  if (currentfeeschedule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(currentfeeschedule);
    if (message_arena != submessage_arena) {
      currentfeeschedule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, currentfeeschedule, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.currentfeeschedule_ = currentfeeschedule;
  // @@protoc_insertion_point(field_set_allocated:proto.CurrentAndNextFeeSchedule.currentFeeSchedule)
}

// .proto.FeeSchedule nextFeeSchedule = 2;
inline bool CurrentAndNextFeeSchedule::_internal_has_nextfeeschedule() const {
  return this != internal_default_instance() && _impl_.nextfeeschedule_ != nullptr;
}
inline bool CurrentAndNextFeeSchedule::has_nextfeeschedule() const {
  return _internal_has_nextfeeschedule();
}
inline void CurrentAndNextFeeSchedule::clear_nextfeeschedule() {
  if (GetArenaForAllocation() == nullptr && _impl_.nextfeeschedule_ != nullptr) {
    delete _impl_.nextfeeschedule_;
  }
  _impl_.nextfeeschedule_ = nullptr;
}
inline const ::proto::FeeSchedule& CurrentAndNextFeeSchedule::_internal_nextfeeschedule() const {
  const ::proto::FeeSchedule* p = _impl_.nextfeeschedule_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::FeeSchedule&>(
      ::proto::_FeeSchedule_default_instance_);
}
inline const ::proto::FeeSchedule& CurrentAndNextFeeSchedule::nextfeeschedule() const {
  // @@protoc_insertion_point(field_get:proto.CurrentAndNextFeeSchedule.nextFeeSchedule)
  return _internal_nextfeeschedule();
}
inline void CurrentAndNextFeeSchedule::unsafe_arena_set_allocated_nextfeeschedule(
    ::proto::FeeSchedule* nextfeeschedule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nextfeeschedule_);
  }
  _impl_.nextfeeschedule_ = nextfeeschedule;
  if (nextfeeschedule) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.CurrentAndNextFeeSchedule.nextFeeSchedule)
}
inline ::proto::FeeSchedule* CurrentAndNextFeeSchedule::release_nextfeeschedule() {
  
  ::proto::FeeSchedule* temp = _impl_.nextfeeschedule_;
  _impl_.nextfeeschedule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::FeeSchedule* CurrentAndNextFeeSchedule::unsafe_arena_release_nextfeeschedule() {
  // @@protoc_insertion_point(field_release:proto.CurrentAndNextFeeSchedule.nextFeeSchedule)
  
  ::proto::FeeSchedule* temp = _impl_.nextfeeschedule_;
  _impl_.nextfeeschedule_ = nullptr;
  return temp;
}
inline ::proto::FeeSchedule* CurrentAndNextFeeSchedule::_internal_mutable_nextfeeschedule() {
  
  if (_impl_.nextfeeschedule_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::FeeSchedule>(GetArenaForAllocation());
    _impl_.nextfeeschedule_ = p;
  }
  return _impl_.nextfeeschedule_;
}
inline ::proto::FeeSchedule* CurrentAndNextFeeSchedule::mutable_nextfeeschedule() {
  ::proto::FeeSchedule* _msg = _internal_mutable_nextfeeschedule();
  // @@protoc_insertion_point(field_mutable:proto.CurrentAndNextFeeSchedule.nextFeeSchedule)
  return _msg;
}
inline void CurrentAndNextFeeSchedule::set_allocated_nextfeeschedule(::proto::FeeSchedule* nextfeeschedule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nextfeeschedule_;
  }
  if (nextfeeschedule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nextfeeschedule);
    if (message_arena != submessage_arena) {
      nextfeeschedule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextfeeschedule, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nextfeeschedule_ = nextfeeschedule;
  // @@protoc_insertion_point(field_set_allocated:proto.CurrentAndNextFeeSchedule.nextFeeSchedule)
}

// -------------------------------------------------------------------

// ServiceEndpoint

// bytes ipAddressV4 = 1;
inline void ServiceEndpoint::clear_ipaddressv4() {
  _impl_.ipaddressv4_.ClearToEmpty();
}
inline const std::string& ServiceEndpoint::ipaddressv4() const {
  // @@protoc_insertion_point(field_get:proto.ServiceEndpoint.ipAddressV4)
  return _internal_ipaddressv4();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceEndpoint::set_ipaddressv4(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ipaddressv4_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ServiceEndpoint.ipAddressV4)
}
inline std::string* ServiceEndpoint::mutable_ipaddressv4() {
  std::string* _s = _internal_mutable_ipaddressv4();
  // @@protoc_insertion_point(field_mutable:proto.ServiceEndpoint.ipAddressV4)
  return _s;
}
inline const std::string& ServiceEndpoint::_internal_ipaddressv4() const {
  return _impl_.ipaddressv4_.Get();
}
inline void ServiceEndpoint::_internal_set_ipaddressv4(const std::string& value) {
  
  _impl_.ipaddressv4_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceEndpoint::_internal_mutable_ipaddressv4() {
  
  return _impl_.ipaddressv4_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceEndpoint::release_ipaddressv4() {
  // @@protoc_insertion_point(field_release:proto.ServiceEndpoint.ipAddressV4)
  return _impl_.ipaddressv4_.Release();
}
inline void ServiceEndpoint::set_allocated_ipaddressv4(std::string* ipaddressv4) {
  if (ipaddressv4 != nullptr) {
    
  } else {
    
  }
  _impl_.ipaddressv4_.SetAllocated(ipaddressv4, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ipaddressv4_.IsDefault()) {
    _impl_.ipaddressv4_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ServiceEndpoint.ipAddressV4)
}

// int32 port = 2;
inline void ServiceEndpoint::clear_port() {
  _impl_.port_ = 0;
}
inline int32_t ServiceEndpoint::_internal_port() const {
  return _impl_.port_;
}
inline int32_t ServiceEndpoint::port() const {
  // @@protoc_insertion_point(field_get:proto.ServiceEndpoint.port)
  return _internal_port();
}
inline void ServiceEndpoint::_internal_set_port(int32_t value) {
  
  _impl_.port_ = value;
}
inline void ServiceEndpoint::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:proto.ServiceEndpoint.port)
}

// -------------------------------------------------------------------

// NodeAddress

// bytes ipAddress = 1 [deprecated = true];
inline void NodeAddress::clear_ipaddress() {
  _impl_.ipaddress_.ClearToEmpty();
}
inline const std::string& NodeAddress::ipaddress() const {
  // @@protoc_insertion_point(field_get:proto.NodeAddress.ipAddress)
  return _internal_ipaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeAddress::set_ipaddress(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ipaddress_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.NodeAddress.ipAddress)
}
inline std::string* NodeAddress::mutable_ipaddress() {
  std::string* _s = _internal_mutable_ipaddress();
  // @@protoc_insertion_point(field_mutable:proto.NodeAddress.ipAddress)
  return _s;
}
inline const std::string& NodeAddress::_internal_ipaddress() const {
  return _impl_.ipaddress_.Get();
}
inline void NodeAddress::_internal_set_ipaddress(const std::string& value) {
  
  _impl_.ipaddress_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeAddress::_internal_mutable_ipaddress() {
  
  return _impl_.ipaddress_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeAddress::release_ipaddress() {
  // @@protoc_insertion_point(field_release:proto.NodeAddress.ipAddress)
  return _impl_.ipaddress_.Release();
}
inline void NodeAddress::set_allocated_ipaddress(std::string* ipaddress) {
  if (ipaddress != nullptr) {
    
  } else {
    
  }
  _impl_.ipaddress_.SetAllocated(ipaddress, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ipaddress_.IsDefault()) {
    _impl_.ipaddress_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.NodeAddress.ipAddress)
}

// int32 portno = 2 [deprecated = true];
inline void NodeAddress::clear_portno() {
  _impl_.portno_ = 0;
}
inline int32_t NodeAddress::_internal_portno() const {
  return _impl_.portno_;
}
inline int32_t NodeAddress::portno() const {
  // @@protoc_insertion_point(field_get:proto.NodeAddress.portno)
  return _internal_portno();
}
inline void NodeAddress::_internal_set_portno(int32_t value) {
  
  _impl_.portno_ = value;
}
inline void NodeAddress::set_portno(int32_t value) {
  _internal_set_portno(value);
  // @@protoc_insertion_point(field_set:proto.NodeAddress.portno)
}

// bytes memo = 3 [deprecated = true];
inline void NodeAddress::clear_memo() {
  _impl_.memo_.ClearToEmpty();
}
inline const std::string& NodeAddress::memo() const {
  // @@protoc_insertion_point(field_get:proto.NodeAddress.memo)
  return _internal_memo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeAddress::set_memo(ArgT0&& arg0, ArgT... args) {
 
 _impl_.memo_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.NodeAddress.memo)
}
inline std::string* NodeAddress::mutable_memo() {
  std::string* _s = _internal_mutable_memo();
  // @@protoc_insertion_point(field_mutable:proto.NodeAddress.memo)
  return _s;
}
inline const std::string& NodeAddress::_internal_memo() const {
  return _impl_.memo_.Get();
}
inline void NodeAddress::_internal_set_memo(const std::string& value) {
  
  _impl_.memo_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeAddress::_internal_mutable_memo() {
  
  return _impl_.memo_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeAddress::release_memo() {
  // @@protoc_insertion_point(field_release:proto.NodeAddress.memo)
  return _impl_.memo_.Release();
}
inline void NodeAddress::set_allocated_memo(std::string* memo) {
  if (memo != nullptr) {
    
  } else {
    
  }
  _impl_.memo_.SetAllocated(memo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.memo_.IsDefault()) {
    _impl_.memo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.NodeAddress.memo)
}

// string RSA_PubKey = 4;
inline void NodeAddress::clear_rsa_pubkey() {
  _impl_.rsa_pubkey_.ClearToEmpty();
}
inline const std::string& NodeAddress::rsa_pubkey() const {
  // @@protoc_insertion_point(field_get:proto.NodeAddress.RSA_PubKey)
  return _internal_rsa_pubkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeAddress::set_rsa_pubkey(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rsa_pubkey_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.NodeAddress.RSA_PubKey)
}
inline std::string* NodeAddress::mutable_rsa_pubkey() {
  std::string* _s = _internal_mutable_rsa_pubkey();
  // @@protoc_insertion_point(field_mutable:proto.NodeAddress.RSA_PubKey)
  return _s;
}
inline const std::string& NodeAddress::_internal_rsa_pubkey() const {
  return _impl_.rsa_pubkey_.Get();
}
inline void NodeAddress::_internal_set_rsa_pubkey(const std::string& value) {
  
  _impl_.rsa_pubkey_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeAddress::_internal_mutable_rsa_pubkey() {
  
  return _impl_.rsa_pubkey_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeAddress::release_rsa_pubkey() {
  // @@protoc_insertion_point(field_release:proto.NodeAddress.RSA_PubKey)
  return _impl_.rsa_pubkey_.Release();
}
inline void NodeAddress::set_allocated_rsa_pubkey(std::string* rsa_pubkey) {
  if (rsa_pubkey != nullptr) {
    
  } else {
    
  }
  _impl_.rsa_pubkey_.SetAllocated(rsa_pubkey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rsa_pubkey_.IsDefault()) {
    _impl_.rsa_pubkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.NodeAddress.RSA_PubKey)
}

// int64 nodeId = 5;
inline void NodeAddress::clear_nodeid() {
  _impl_.nodeid_ = int64_t{0};
}
inline int64_t NodeAddress::_internal_nodeid() const {
  return _impl_.nodeid_;
}
inline int64_t NodeAddress::nodeid() const {
  // @@protoc_insertion_point(field_get:proto.NodeAddress.nodeId)
  return _internal_nodeid();
}
inline void NodeAddress::_internal_set_nodeid(int64_t value) {
  
  _impl_.nodeid_ = value;
}
inline void NodeAddress::set_nodeid(int64_t value) {
  _internal_set_nodeid(value);
  // @@protoc_insertion_point(field_set:proto.NodeAddress.nodeId)
}

// .proto.AccountID nodeAccountId = 6;
inline bool NodeAddress::_internal_has_nodeaccountid() const {
  return this != internal_default_instance() && _impl_.nodeaccountid_ != nullptr;
}
inline bool NodeAddress::has_nodeaccountid() const {
  return _internal_has_nodeaccountid();
}
inline void NodeAddress::clear_nodeaccountid() {
  if (GetArenaForAllocation() == nullptr && _impl_.nodeaccountid_ != nullptr) {
    delete _impl_.nodeaccountid_;
  }
  _impl_.nodeaccountid_ = nullptr;
}
inline const ::proto::AccountID& NodeAddress::_internal_nodeaccountid() const {
  const ::proto::AccountID* p = _impl_.nodeaccountid_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AccountID&>(
      ::proto::_AccountID_default_instance_);
}
inline const ::proto::AccountID& NodeAddress::nodeaccountid() const {
  // @@protoc_insertion_point(field_get:proto.NodeAddress.nodeAccountId)
  return _internal_nodeaccountid();
}
inline void NodeAddress::unsafe_arena_set_allocated_nodeaccountid(
    ::proto::AccountID* nodeaccountid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nodeaccountid_);
  }
  _impl_.nodeaccountid_ = nodeaccountid;
  if (nodeaccountid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.NodeAddress.nodeAccountId)
}
inline ::proto::AccountID* NodeAddress::release_nodeaccountid() {
  
  ::proto::AccountID* temp = _impl_.nodeaccountid_;
  _impl_.nodeaccountid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AccountID* NodeAddress::unsafe_arena_release_nodeaccountid() {
  // @@protoc_insertion_point(field_release:proto.NodeAddress.nodeAccountId)
  
  ::proto::AccountID* temp = _impl_.nodeaccountid_;
  _impl_.nodeaccountid_ = nullptr;
  return temp;
}
inline ::proto::AccountID* NodeAddress::_internal_mutable_nodeaccountid() {
  
  if (_impl_.nodeaccountid_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AccountID>(GetArenaForAllocation());
    _impl_.nodeaccountid_ = p;
  }
  return _impl_.nodeaccountid_;
}
inline ::proto::AccountID* NodeAddress::mutable_nodeaccountid() {
  ::proto::AccountID* _msg = _internal_mutable_nodeaccountid();
  // @@protoc_insertion_point(field_mutable:proto.NodeAddress.nodeAccountId)
  return _msg;
}
inline void NodeAddress::set_allocated_nodeaccountid(::proto::AccountID* nodeaccountid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nodeaccountid_;
  }
  if (nodeaccountid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nodeaccountid);
    if (message_arena != submessage_arena) {
      nodeaccountid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodeaccountid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nodeaccountid_ = nodeaccountid;
  // @@protoc_insertion_point(field_set_allocated:proto.NodeAddress.nodeAccountId)
}

// bytes nodeCertHash = 7;
inline void NodeAddress::clear_nodecerthash() {
  _impl_.nodecerthash_.ClearToEmpty();
}
inline const std::string& NodeAddress::nodecerthash() const {
  // @@protoc_insertion_point(field_get:proto.NodeAddress.nodeCertHash)
  return _internal_nodecerthash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeAddress::set_nodecerthash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nodecerthash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.NodeAddress.nodeCertHash)
}
inline std::string* NodeAddress::mutable_nodecerthash() {
  std::string* _s = _internal_mutable_nodecerthash();
  // @@protoc_insertion_point(field_mutable:proto.NodeAddress.nodeCertHash)
  return _s;
}
inline const std::string& NodeAddress::_internal_nodecerthash() const {
  return _impl_.nodecerthash_.Get();
}
inline void NodeAddress::_internal_set_nodecerthash(const std::string& value) {
  
  _impl_.nodecerthash_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeAddress::_internal_mutable_nodecerthash() {
  
  return _impl_.nodecerthash_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeAddress::release_nodecerthash() {
  // @@protoc_insertion_point(field_release:proto.NodeAddress.nodeCertHash)
  return _impl_.nodecerthash_.Release();
}
inline void NodeAddress::set_allocated_nodecerthash(std::string* nodecerthash) {
  if (nodecerthash != nullptr) {
    
  } else {
    
  }
  _impl_.nodecerthash_.SetAllocated(nodecerthash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nodecerthash_.IsDefault()) {
    _impl_.nodecerthash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.NodeAddress.nodeCertHash)
}

// repeated .proto.ServiceEndpoint serviceEndpoint = 8;
inline int NodeAddress::_internal_serviceendpoint_size() const {
  return _impl_.serviceendpoint_.size();
}
inline int NodeAddress::serviceendpoint_size() const {
  return _internal_serviceendpoint_size();
}
inline void NodeAddress::clear_serviceendpoint() {
  _impl_.serviceendpoint_.Clear();
}
inline ::proto::ServiceEndpoint* NodeAddress::mutable_serviceendpoint(int index) {
  // @@protoc_insertion_point(field_mutable:proto.NodeAddress.serviceEndpoint)
  return _impl_.serviceendpoint_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ServiceEndpoint >*
NodeAddress::mutable_serviceendpoint() {
  // @@protoc_insertion_point(field_mutable_list:proto.NodeAddress.serviceEndpoint)
  return &_impl_.serviceendpoint_;
}
inline const ::proto::ServiceEndpoint& NodeAddress::_internal_serviceendpoint(int index) const {
  return _impl_.serviceendpoint_.Get(index);
}
inline const ::proto::ServiceEndpoint& NodeAddress::serviceendpoint(int index) const {
  // @@protoc_insertion_point(field_get:proto.NodeAddress.serviceEndpoint)
  return _internal_serviceendpoint(index);
}
inline ::proto::ServiceEndpoint* NodeAddress::_internal_add_serviceendpoint() {
  return _impl_.serviceendpoint_.Add();
}
inline ::proto::ServiceEndpoint* NodeAddress::add_serviceendpoint() {
  ::proto::ServiceEndpoint* _add = _internal_add_serviceendpoint();
  // @@protoc_insertion_point(field_add:proto.NodeAddress.serviceEndpoint)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ServiceEndpoint >&
NodeAddress::serviceendpoint() const {
  // @@protoc_insertion_point(field_list:proto.NodeAddress.serviceEndpoint)
  return _impl_.serviceendpoint_;
}

// string description = 9;
inline void NodeAddress::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& NodeAddress::description() const {
  // @@protoc_insertion_point(field_get:proto.NodeAddress.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeAddress::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.NodeAddress.description)
}
inline std::string* NodeAddress::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:proto.NodeAddress.description)
  return _s;
}
inline const std::string& NodeAddress::_internal_description() const {
  return _impl_.description_.Get();
}
inline void NodeAddress::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeAddress::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeAddress::release_description() {
  // @@protoc_insertion_point(field_release:proto.NodeAddress.description)
  return _impl_.description_.Release();
}
inline void NodeAddress::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.NodeAddress.description)
}

// int64 stake = 10 [deprecated = true];
inline void NodeAddress::clear_stake() {
  _impl_.stake_ = int64_t{0};
}
inline int64_t NodeAddress::_internal_stake() const {
  return _impl_.stake_;
}
inline int64_t NodeAddress::stake() const {
  // @@protoc_insertion_point(field_get:proto.NodeAddress.stake)
  return _internal_stake();
}
inline void NodeAddress::_internal_set_stake(int64_t value) {
  
  _impl_.stake_ = value;
}
inline void NodeAddress::set_stake(int64_t value) {
  _internal_set_stake(value);
  // @@protoc_insertion_point(field_set:proto.NodeAddress.stake)
}

// -------------------------------------------------------------------

// NodeAddressBook

// repeated .proto.NodeAddress nodeAddress = 1;
inline int NodeAddressBook::_internal_nodeaddress_size() const {
  return _impl_.nodeaddress_.size();
}
inline int NodeAddressBook::nodeaddress_size() const {
  return _internal_nodeaddress_size();
}
inline void NodeAddressBook::clear_nodeaddress() {
  _impl_.nodeaddress_.Clear();
}
inline ::proto::NodeAddress* NodeAddressBook::mutable_nodeaddress(int index) {
  // @@protoc_insertion_point(field_mutable:proto.NodeAddressBook.nodeAddress)
  return _impl_.nodeaddress_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::NodeAddress >*
NodeAddressBook::mutable_nodeaddress() {
  // @@protoc_insertion_point(field_mutable_list:proto.NodeAddressBook.nodeAddress)
  return &_impl_.nodeaddress_;
}
inline const ::proto::NodeAddress& NodeAddressBook::_internal_nodeaddress(int index) const {
  return _impl_.nodeaddress_.Get(index);
}
inline const ::proto::NodeAddress& NodeAddressBook::nodeaddress(int index) const {
  // @@protoc_insertion_point(field_get:proto.NodeAddressBook.nodeAddress)
  return _internal_nodeaddress(index);
}
inline ::proto::NodeAddress* NodeAddressBook::_internal_add_nodeaddress() {
  return _impl_.nodeaddress_.Add();
}
inline ::proto::NodeAddress* NodeAddressBook::add_nodeaddress() {
  ::proto::NodeAddress* _add = _internal_add_nodeaddress();
  // @@protoc_insertion_point(field_add:proto.NodeAddressBook.nodeAddress)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::NodeAddress >&
NodeAddressBook::nodeaddress() const {
  // @@protoc_insertion_point(field_list:proto.NodeAddressBook.nodeAddress)
  return _impl_.nodeaddress_;
}

// -------------------------------------------------------------------

// SemanticVersion

// int32 major = 1;
inline void SemanticVersion::clear_major() {
  _impl_.major_ = 0;
}
inline int32_t SemanticVersion::_internal_major() const {
  return _impl_.major_;
}
inline int32_t SemanticVersion::major() const {
  // @@protoc_insertion_point(field_get:proto.SemanticVersion.major)
  return _internal_major();
}
inline void SemanticVersion::_internal_set_major(int32_t value) {
  
  _impl_.major_ = value;
}
inline void SemanticVersion::set_major(int32_t value) {
  _internal_set_major(value);
  // @@protoc_insertion_point(field_set:proto.SemanticVersion.major)
}

// int32 minor = 2;
inline void SemanticVersion::clear_minor() {
  _impl_.minor_ = 0;
}
inline int32_t SemanticVersion::_internal_minor() const {
  return _impl_.minor_;
}
inline int32_t SemanticVersion::minor() const {
  // @@protoc_insertion_point(field_get:proto.SemanticVersion.minor)
  return _internal_minor();
}
inline void SemanticVersion::_internal_set_minor(int32_t value) {
  
  _impl_.minor_ = value;
}
inline void SemanticVersion::set_minor(int32_t value) {
  _internal_set_minor(value);
  // @@protoc_insertion_point(field_set:proto.SemanticVersion.minor)
}

// int32 patch = 3;
inline void SemanticVersion::clear_patch() {
  _impl_.patch_ = 0;
}
inline int32_t SemanticVersion::_internal_patch() const {
  return _impl_.patch_;
}
inline int32_t SemanticVersion::patch() const {
  // @@protoc_insertion_point(field_get:proto.SemanticVersion.patch)
  return _internal_patch();
}
inline void SemanticVersion::_internal_set_patch(int32_t value) {
  
  _impl_.patch_ = value;
}
inline void SemanticVersion::set_patch(int32_t value) {
  _internal_set_patch(value);
  // @@protoc_insertion_point(field_set:proto.SemanticVersion.patch)
}

// string pre = 4;
inline void SemanticVersion::clear_pre() {
  _impl_.pre_.ClearToEmpty();
}
inline const std::string& SemanticVersion::pre() const {
  // @@protoc_insertion_point(field_get:proto.SemanticVersion.pre)
  return _internal_pre();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SemanticVersion::set_pre(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pre_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SemanticVersion.pre)
}
inline std::string* SemanticVersion::mutable_pre() {
  std::string* _s = _internal_mutable_pre();
  // @@protoc_insertion_point(field_mutable:proto.SemanticVersion.pre)
  return _s;
}
inline const std::string& SemanticVersion::_internal_pre() const {
  return _impl_.pre_.Get();
}
inline void SemanticVersion::_internal_set_pre(const std::string& value) {
  
  _impl_.pre_.Set(value, GetArenaForAllocation());
}
inline std::string* SemanticVersion::_internal_mutable_pre() {
  
  return _impl_.pre_.Mutable(GetArenaForAllocation());
}
inline std::string* SemanticVersion::release_pre() {
  // @@protoc_insertion_point(field_release:proto.SemanticVersion.pre)
  return _impl_.pre_.Release();
}
inline void SemanticVersion::set_allocated_pre(std::string* pre) {
  if (pre != nullptr) {
    
  } else {
    
  }
  _impl_.pre_.SetAllocated(pre, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pre_.IsDefault()) {
    _impl_.pre_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.SemanticVersion.pre)
}

// string build = 5;
inline void SemanticVersion::clear_build() {
  _impl_.build_.ClearToEmpty();
}
inline const std::string& SemanticVersion::build() const {
  // @@protoc_insertion_point(field_get:proto.SemanticVersion.build)
  return _internal_build();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SemanticVersion::set_build(ArgT0&& arg0, ArgT... args) {
 
 _impl_.build_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.SemanticVersion.build)
}
inline std::string* SemanticVersion::mutable_build() {
  std::string* _s = _internal_mutable_build();
  // @@protoc_insertion_point(field_mutable:proto.SemanticVersion.build)
  return _s;
}
inline const std::string& SemanticVersion::_internal_build() const {
  return _impl_.build_.Get();
}
inline void SemanticVersion::_internal_set_build(const std::string& value) {
  
  _impl_.build_.Set(value, GetArenaForAllocation());
}
inline std::string* SemanticVersion::_internal_mutable_build() {
  
  return _impl_.build_.Mutable(GetArenaForAllocation());
}
inline std::string* SemanticVersion::release_build() {
  // @@protoc_insertion_point(field_release:proto.SemanticVersion.build)
  return _impl_.build_.Release();
}
inline void SemanticVersion::set_allocated_build(std::string* build) {
  if (build != nullptr) {
    
  } else {
    
  }
  _impl_.build_.SetAllocated(build, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.build_.IsDefault()) {
    _impl_.build_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.SemanticVersion.build)
}

// -------------------------------------------------------------------

// Setting

// string name = 1;
inline void Setting::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Setting::name() const {
  // @@protoc_insertion_point(field_get:proto.Setting.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Setting::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Setting.name)
}
inline std::string* Setting::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.Setting.name)
  return _s;
}
inline const std::string& Setting::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Setting::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Setting::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Setting::release_name() {
  // @@protoc_insertion_point(field_release:proto.Setting.name)
  return _impl_.name_.Release();
}
inline void Setting::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Setting.name)
}

// string value = 2;
inline void Setting::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& Setting::value() const {
  // @@protoc_insertion_point(field_get:proto.Setting.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Setting::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Setting.value)
}
inline std::string* Setting::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:proto.Setting.value)
  return _s;
}
inline const std::string& Setting::_internal_value() const {
  return _impl_.value_.Get();
}
inline void Setting::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Setting::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* Setting::release_value() {
  // @@protoc_insertion_point(field_release:proto.Setting.value)
  return _impl_.value_.Release();
}
inline void Setting::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Setting.value)
}

// bytes data = 3;
inline void Setting::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Setting::data() const {
  // @@protoc_insertion_point(field_get:proto.Setting.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Setting::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.Setting.data)
}
inline std::string* Setting::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:proto.Setting.data)
  return _s;
}
inline const std::string& Setting::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Setting::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Setting::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Setting::release_data() {
  // @@protoc_insertion_point(field_release:proto.Setting.data)
  return _impl_.data_.Release();
}
inline void Setting::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.Setting.data)
}

// -------------------------------------------------------------------

// ServicesConfigurationList

// repeated .proto.Setting nameValue = 1;
inline int ServicesConfigurationList::_internal_namevalue_size() const {
  return _impl_.namevalue_.size();
}
inline int ServicesConfigurationList::namevalue_size() const {
  return _internal_namevalue_size();
}
inline void ServicesConfigurationList::clear_namevalue() {
  _impl_.namevalue_.Clear();
}
inline ::proto::Setting* ServicesConfigurationList::mutable_namevalue(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ServicesConfigurationList.nameValue)
  return _impl_.namevalue_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Setting >*
ServicesConfigurationList::mutable_namevalue() {
  // @@protoc_insertion_point(field_mutable_list:proto.ServicesConfigurationList.nameValue)
  return &_impl_.namevalue_;
}
inline const ::proto::Setting& ServicesConfigurationList::_internal_namevalue(int index) const {
  return _impl_.namevalue_.Get(index);
}
inline const ::proto::Setting& ServicesConfigurationList::namevalue(int index) const {
  // @@protoc_insertion_point(field_get:proto.ServicesConfigurationList.nameValue)
  return _internal_namevalue(index);
}
inline ::proto::Setting* ServicesConfigurationList::_internal_add_namevalue() {
  return _impl_.namevalue_.Add();
}
inline ::proto::Setting* ServicesConfigurationList::add_namevalue() {
  ::proto::Setting* _add = _internal_add_namevalue();
  // @@protoc_insertion_point(field_add:proto.ServicesConfigurationList.nameValue)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Setting >&
ServicesConfigurationList::namevalue() const {
  // @@protoc_insertion_point(field_list:proto.ServicesConfigurationList.nameValue)
  return _impl_.namevalue_;
}

// -------------------------------------------------------------------

// TokenRelationship

// .proto.TokenID tokenId = 1;
inline bool TokenRelationship::_internal_has_tokenid() const {
  return this != internal_default_instance() && _impl_.tokenid_ != nullptr;
}
inline bool TokenRelationship::has_tokenid() const {
  return _internal_has_tokenid();
}
inline void TokenRelationship::clear_tokenid() {
  if (GetArenaForAllocation() == nullptr && _impl_.tokenid_ != nullptr) {
    delete _impl_.tokenid_;
  }
  _impl_.tokenid_ = nullptr;
}
inline const ::proto::TokenID& TokenRelationship::_internal_tokenid() const {
  const ::proto::TokenID* p = _impl_.tokenid_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::TokenID&>(
      ::proto::_TokenID_default_instance_);
}
inline const ::proto::TokenID& TokenRelationship::tokenid() const {
  // @@protoc_insertion_point(field_get:proto.TokenRelationship.tokenId)
  return _internal_tokenid();
}
inline void TokenRelationship::unsafe_arena_set_allocated_tokenid(
    ::proto::TokenID* tokenid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tokenid_);
  }
  _impl_.tokenid_ = tokenid;
  if (tokenid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TokenRelationship.tokenId)
}
inline ::proto::TokenID* TokenRelationship::release_tokenid() {
  
  ::proto::TokenID* temp = _impl_.tokenid_;
  _impl_.tokenid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::TokenID* TokenRelationship::unsafe_arena_release_tokenid() {
  // @@protoc_insertion_point(field_release:proto.TokenRelationship.tokenId)
  
  ::proto::TokenID* temp = _impl_.tokenid_;
  _impl_.tokenid_ = nullptr;
  return temp;
}
inline ::proto::TokenID* TokenRelationship::_internal_mutable_tokenid() {
  
  if (_impl_.tokenid_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::TokenID>(GetArenaForAllocation());
    _impl_.tokenid_ = p;
  }
  return _impl_.tokenid_;
}
inline ::proto::TokenID* TokenRelationship::mutable_tokenid() {
  ::proto::TokenID* _msg = _internal_mutable_tokenid();
  // @@protoc_insertion_point(field_mutable:proto.TokenRelationship.tokenId)
  return _msg;
}
inline void TokenRelationship::set_allocated_tokenid(::proto::TokenID* tokenid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tokenid_;
  }
  if (tokenid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tokenid);
    if (message_arena != submessage_arena) {
      tokenid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tokenid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tokenid_ = tokenid;
  // @@protoc_insertion_point(field_set_allocated:proto.TokenRelationship.tokenId)
}

// string symbol = 2;
inline void TokenRelationship::clear_symbol() {
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& TokenRelationship::symbol() const {
  // @@protoc_insertion_point(field_get:proto.TokenRelationship.symbol)
  return _internal_symbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenRelationship::set_symbol(ArgT0&& arg0, ArgT... args) {
 
 _impl_.symbol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.TokenRelationship.symbol)
}
inline std::string* TokenRelationship::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:proto.TokenRelationship.symbol)
  return _s;
}
inline const std::string& TokenRelationship::_internal_symbol() const {
  return _impl_.symbol_.Get();
}
inline void TokenRelationship::_internal_set_symbol(const std::string& value) {
  
  _impl_.symbol_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenRelationship::_internal_mutable_symbol() {
  
  return _impl_.symbol_.Mutable(GetArenaForAllocation());
}
inline std::string* TokenRelationship::release_symbol() {
  // @@protoc_insertion_point(field_release:proto.TokenRelationship.symbol)
  return _impl_.symbol_.Release();
}
inline void TokenRelationship::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    
  } else {
    
  }
  _impl_.symbol_.SetAllocated(symbol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.symbol_.IsDefault()) {
    _impl_.symbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.TokenRelationship.symbol)
}

// uint64 balance = 3;
inline void TokenRelationship::clear_balance() {
  _impl_.balance_ = uint64_t{0u};
}
inline uint64_t TokenRelationship::_internal_balance() const {
  return _impl_.balance_;
}
inline uint64_t TokenRelationship::balance() const {
  // @@protoc_insertion_point(field_get:proto.TokenRelationship.balance)
  return _internal_balance();
}
inline void TokenRelationship::_internal_set_balance(uint64_t value) {
  
  _impl_.balance_ = value;
}
inline void TokenRelationship::set_balance(uint64_t value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:proto.TokenRelationship.balance)
}

// .proto.TokenKycStatus kycStatus = 4;
inline void TokenRelationship::clear_kycstatus() {
  _impl_.kycstatus_ = 0;
}
inline ::proto::TokenKycStatus TokenRelationship::_internal_kycstatus() const {
  return static_cast< ::proto::TokenKycStatus >(_impl_.kycstatus_);
}
inline ::proto::TokenKycStatus TokenRelationship::kycstatus() const {
  // @@protoc_insertion_point(field_get:proto.TokenRelationship.kycStatus)
  return _internal_kycstatus();
}
inline void TokenRelationship::_internal_set_kycstatus(::proto::TokenKycStatus value) {
  
  _impl_.kycstatus_ = value;
}
inline void TokenRelationship::set_kycstatus(::proto::TokenKycStatus value) {
  _internal_set_kycstatus(value);
  // @@protoc_insertion_point(field_set:proto.TokenRelationship.kycStatus)
}

// .proto.TokenFreezeStatus freezeStatus = 5;
inline void TokenRelationship::clear_freezestatus() {
  _impl_.freezestatus_ = 0;
}
inline ::proto::TokenFreezeStatus TokenRelationship::_internal_freezestatus() const {
  return static_cast< ::proto::TokenFreezeStatus >(_impl_.freezestatus_);
}
inline ::proto::TokenFreezeStatus TokenRelationship::freezestatus() const {
  // @@protoc_insertion_point(field_get:proto.TokenRelationship.freezeStatus)
  return _internal_freezestatus();
}
inline void TokenRelationship::_internal_set_freezestatus(::proto::TokenFreezeStatus value) {
  
  _impl_.freezestatus_ = value;
}
inline void TokenRelationship::set_freezestatus(::proto::TokenFreezeStatus value) {
  _internal_set_freezestatus(value);
  // @@protoc_insertion_point(field_set:proto.TokenRelationship.freezeStatus)
}

// uint32 decimals = 6;
inline void TokenRelationship::clear_decimals() {
  _impl_.decimals_ = 0u;
}
inline uint32_t TokenRelationship::_internal_decimals() const {
  return _impl_.decimals_;
}
inline uint32_t TokenRelationship::decimals() const {
  // @@protoc_insertion_point(field_get:proto.TokenRelationship.decimals)
  return _internal_decimals();
}
inline void TokenRelationship::_internal_set_decimals(uint32_t value) {
  
  _impl_.decimals_ = value;
}
inline void TokenRelationship::set_decimals(uint32_t value) {
  _internal_set_decimals(value);
  // @@protoc_insertion_point(field_set:proto.TokenRelationship.decimals)
}

// bool automatic_association = 7;
inline void TokenRelationship::clear_automatic_association() {
  _impl_.automatic_association_ = false;
}
inline bool TokenRelationship::_internal_automatic_association() const {
  return _impl_.automatic_association_;
}
inline bool TokenRelationship::automatic_association() const {
  // @@protoc_insertion_point(field_get:proto.TokenRelationship.automatic_association)
  return _internal_automatic_association();
}
inline void TokenRelationship::_internal_set_automatic_association(bool value) {
  
  _impl_.automatic_association_ = value;
}
inline void TokenRelationship::set_automatic_association(bool value) {
  _internal_set_automatic_association(value);
  // @@protoc_insertion_point(field_set:proto.TokenRelationship.automatic_association)
}

// -------------------------------------------------------------------

// TokenBalance

// .proto.TokenID tokenId = 1;
inline bool TokenBalance::_internal_has_tokenid() const {
  return this != internal_default_instance() && _impl_.tokenid_ != nullptr;
}
inline bool TokenBalance::has_tokenid() const {
  return _internal_has_tokenid();
}
inline void TokenBalance::clear_tokenid() {
  if (GetArenaForAllocation() == nullptr && _impl_.tokenid_ != nullptr) {
    delete _impl_.tokenid_;
  }
  _impl_.tokenid_ = nullptr;
}
inline const ::proto::TokenID& TokenBalance::_internal_tokenid() const {
  const ::proto::TokenID* p = _impl_.tokenid_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::TokenID&>(
      ::proto::_TokenID_default_instance_);
}
inline const ::proto::TokenID& TokenBalance::tokenid() const {
  // @@protoc_insertion_point(field_get:proto.TokenBalance.tokenId)
  return _internal_tokenid();
}
inline void TokenBalance::unsafe_arena_set_allocated_tokenid(
    ::proto::TokenID* tokenid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tokenid_);
  }
  _impl_.tokenid_ = tokenid;
  if (tokenid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TokenBalance.tokenId)
}
inline ::proto::TokenID* TokenBalance::release_tokenid() {
  
  ::proto::TokenID* temp = _impl_.tokenid_;
  _impl_.tokenid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::TokenID* TokenBalance::unsafe_arena_release_tokenid() {
  // @@protoc_insertion_point(field_release:proto.TokenBalance.tokenId)
  
  ::proto::TokenID* temp = _impl_.tokenid_;
  _impl_.tokenid_ = nullptr;
  return temp;
}
inline ::proto::TokenID* TokenBalance::_internal_mutable_tokenid() {
  
  if (_impl_.tokenid_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::TokenID>(GetArenaForAllocation());
    _impl_.tokenid_ = p;
  }
  return _impl_.tokenid_;
}
inline ::proto::TokenID* TokenBalance::mutable_tokenid() {
  ::proto::TokenID* _msg = _internal_mutable_tokenid();
  // @@protoc_insertion_point(field_mutable:proto.TokenBalance.tokenId)
  return _msg;
}
inline void TokenBalance::set_allocated_tokenid(::proto::TokenID* tokenid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tokenid_;
  }
  if (tokenid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tokenid);
    if (message_arena != submessage_arena) {
      tokenid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tokenid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tokenid_ = tokenid;
  // @@protoc_insertion_point(field_set_allocated:proto.TokenBalance.tokenId)
}

// uint64 balance = 2;
inline void TokenBalance::clear_balance() {
  _impl_.balance_ = uint64_t{0u};
}
inline uint64_t TokenBalance::_internal_balance() const {
  return _impl_.balance_;
}
inline uint64_t TokenBalance::balance() const {
  // @@protoc_insertion_point(field_get:proto.TokenBalance.balance)
  return _internal_balance();
}
inline void TokenBalance::_internal_set_balance(uint64_t value) {
  
  _impl_.balance_ = value;
}
inline void TokenBalance::set_balance(uint64_t value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:proto.TokenBalance.balance)
}

// uint32 decimals = 3;
inline void TokenBalance::clear_decimals() {
  _impl_.decimals_ = 0u;
}
inline uint32_t TokenBalance::_internal_decimals() const {
  return _impl_.decimals_;
}
inline uint32_t TokenBalance::decimals() const {
  // @@protoc_insertion_point(field_get:proto.TokenBalance.decimals)
  return _internal_decimals();
}
inline void TokenBalance::_internal_set_decimals(uint32_t value) {
  
  _impl_.decimals_ = value;
}
inline void TokenBalance::set_decimals(uint32_t value) {
  _internal_set_decimals(value);
  // @@protoc_insertion_point(field_set:proto.TokenBalance.decimals)
}

// -------------------------------------------------------------------

// TokenBalances

// repeated .proto.TokenBalance tokenBalances = 1;
inline int TokenBalances::_internal_tokenbalances_size() const {
  return _impl_.tokenbalances_.size();
}
inline int TokenBalances::tokenbalances_size() const {
  return _internal_tokenbalances_size();
}
inline void TokenBalances::clear_tokenbalances() {
  _impl_.tokenbalances_.Clear();
}
inline ::proto::TokenBalance* TokenBalances::mutable_tokenbalances(int index) {
  // @@protoc_insertion_point(field_mutable:proto.TokenBalances.tokenBalances)
  return _impl_.tokenbalances_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TokenBalance >*
TokenBalances::mutable_tokenbalances() {
  // @@protoc_insertion_point(field_mutable_list:proto.TokenBalances.tokenBalances)
  return &_impl_.tokenbalances_;
}
inline const ::proto::TokenBalance& TokenBalances::_internal_tokenbalances(int index) const {
  return _impl_.tokenbalances_.Get(index);
}
inline const ::proto::TokenBalance& TokenBalances::tokenbalances(int index) const {
  // @@protoc_insertion_point(field_get:proto.TokenBalances.tokenBalances)
  return _internal_tokenbalances(index);
}
inline ::proto::TokenBalance* TokenBalances::_internal_add_tokenbalances() {
  return _impl_.tokenbalances_.Add();
}
inline ::proto::TokenBalance* TokenBalances::add_tokenbalances() {
  ::proto::TokenBalance* _add = _internal_add_tokenbalances();
  // @@protoc_insertion_point(field_add:proto.TokenBalances.tokenBalances)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TokenBalance >&
TokenBalances::tokenbalances() const {
  // @@protoc_insertion_point(field_list:proto.TokenBalances.tokenBalances)
  return _impl_.tokenbalances_;
}

// -------------------------------------------------------------------

// TokenAssociation

// .proto.TokenID token_id = 1;
inline bool TokenAssociation::_internal_has_token_id() const {
  return this != internal_default_instance() && _impl_.token_id_ != nullptr;
}
inline bool TokenAssociation::has_token_id() const {
  return _internal_has_token_id();
}
inline void TokenAssociation::clear_token_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.token_id_ != nullptr) {
    delete _impl_.token_id_;
  }
  _impl_.token_id_ = nullptr;
}
inline const ::proto::TokenID& TokenAssociation::_internal_token_id() const {
  const ::proto::TokenID* p = _impl_.token_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::TokenID&>(
      ::proto::_TokenID_default_instance_);
}
inline const ::proto::TokenID& TokenAssociation::token_id() const {
  // @@protoc_insertion_point(field_get:proto.TokenAssociation.token_id)
  return _internal_token_id();
}
inline void TokenAssociation::unsafe_arena_set_allocated_token_id(
    ::proto::TokenID* token_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.token_id_);
  }
  _impl_.token_id_ = token_id;
  if (token_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TokenAssociation.token_id)
}
inline ::proto::TokenID* TokenAssociation::release_token_id() {
  
  ::proto::TokenID* temp = _impl_.token_id_;
  _impl_.token_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::TokenID* TokenAssociation::unsafe_arena_release_token_id() {
  // @@protoc_insertion_point(field_release:proto.TokenAssociation.token_id)
  
  ::proto::TokenID* temp = _impl_.token_id_;
  _impl_.token_id_ = nullptr;
  return temp;
}
inline ::proto::TokenID* TokenAssociation::_internal_mutable_token_id() {
  
  if (_impl_.token_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::TokenID>(GetArenaForAllocation());
    _impl_.token_id_ = p;
  }
  return _impl_.token_id_;
}
inline ::proto::TokenID* TokenAssociation::mutable_token_id() {
  ::proto::TokenID* _msg = _internal_mutable_token_id();
  // @@protoc_insertion_point(field_mutable:proto.TokenAssociation.token_id)
  return _msg;
}
inline void TokenAssociation::set_allocated_token_id(::proto::TokenID* token_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.token_id_;
  }
  if (token_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(token_id);
    if (message_arena != submessage_arena) {
      token_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.token_id_ = token_id;
  // @@protoc_insertion_point(field_set_allocated:proto.TokenAssociation.token_id)
}

// .proto.AccountID account_id = 2;
inline bool TokenAssociation::_internal_has_account_id() const {
  return this != internal_default_instance() && _impl_.account_id_ != nullptr;
}
inline bool TokenAssociation::has_account_id() const {
  return _internal_has_account_id();
}
inline void TokenAssociation::clear_account_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.account_id_ != nullptr) {
    delete _impl_.account_id_;
  }
  _impl_.account_id_ = nullptr;
}
inline const ::proto::AccountID& TokenAssociation::_internal_account_id() const {
  const ::proto::AccountID* p = _impl_.account_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AccountID&>(
      ::proto::_AccountID_default_instance_);
}
inline const ::proto::AccountID& TokenAssociation::account_id() const {
  // @@protoc_insertion_point(field_get:proto.TokenAssociation.account_id)
  return _internal_account_id();
}
inline void TokenAssociation::unsafe_arena_set_allocated_account_id(
    ::proto::AccountID* account_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.account_id_);
  }
  _impl_.account_id_ = account_id;
  if (account_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TokenAssociation.account_id)
}
inline ::proto::AccountID* TokenAssociation::release_account_id() {
  
  ::proto::AccountID* temp = _impl_.account_id_;
  _impl_.account_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AccountID* TokenAssociation::unsafe_arena_release_account_id() {
  // @@protoc_insertion_point(field_release:proto.TokenAssociation.account_id)
  
  ::proto::AccountID* temp = _impl_.account_id_;
  _impl_.account_id_ = nullptr;
  return temp;
}
inline ::proto::AccountID* TokenAssociation::_internal_mutable_account_id() {
  
  if (_impl_.account_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AccountID>(GetArenaForAllocation());
    _impl_.account_id_ = p;
  }
  return _impl_.account_id_;
}
inline ::proto::AccountID* TokenAssociation::mutable_account_id() {
  ::proto::AccountID* _msg = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:proto.TokenAssociation.account_id)
  return _msg;
}
inline void TokenAssociation::set_allocated_account_id(::proto::AccountID* account_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.account_id_;
  }
  if (account_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(account_id);
    if (message_arena != submessage_arena) {
      account_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.account_id_ = account_id;
  // @@protoc_insertion_point(field_set_allocated:proto.TokenAssociation.account_id)
}

// -------------------------------------------------------------------

// StakingInfo

// bool decline_reward = 1;
inline void StakingInfo::clear_decline_reward() {
  _impl_.decline_reward_ = false;
}
inline bool StakingInfo::_internal_decline_reward() const {
  return _impl_.decline_reward_;
}
inline bool StakingInfo::decline_reward() const {
  // @@protoc_insertion_point(field_get:proto.StakingInfo.decline_reward)
  return _internal_decline_reward();
}
inline void StakingInfo::_internal_set_decline_reward(bool value) {
  
  _impl_.decline_reward_ = value;
}
inline void StakingInfo::set_decline_reward(bool value) {
  _internal_set_decline_reward(value);
  // @@protoc_insertion_point(field_set:proto.StakingInfo.decline_reward)
}

// .proto.Timestamp stake_period_start = 2;
inline bool StakingInfo::_internal_has_stake_period_start() const {
  return this != internal_default_instance() && _impl_.stake_period_start_ != nullptr;
}
inline bool StakingInfo::has_stake_period_start() const {
  return _internal_has_stake_period_start();
}
inline const ::proto::Timestamp& StakingInfo::_internal_stake_period_start() const {
  const ::proto::Timestamp* p = _impl_.stake_period_start_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Timestamp&>(
      ::proto::_Timestamp_default_instance_);
}
inline const ::proto::Timestamp& StakingInfo::stake_period_start() const {
  // @@protoc_insertion_point(field_get:proto.StakingInfo.stake_period_start)
  return _internal_stake_period_start();
}
inline void StakingInfo::unsafe_arena_set_allocated_stake_period_start(
    ::proto::Timestamp* stake_period_start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stake_period_start_);
  }
  _impl_.stake_period_start_ = stake_period_start;
  if (stake_period_start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.StakingInfo.stake_period_start)
}
inline ::proto::Timestamp* StakingInfo::release_stake_period_start() {
  
  ::proto::Timestamp* temp = _impl_.stake_period_start_;
  _impl_.stake_period_start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Timestamp* StakingInfo::unsafe_arena_release_stake_period_start() {
  // @@protoc_insertion_point(field_release:proto.StakingInfo.stake_period_start)
  
  ::proto::Timestamp* temp = _impl_.stake_period_start_;
  _impl_.stake_period_start_ = nullptr;
  return temp;
}
inline ::proto::Timestamp* StakingInfo::_internal_mutable_stake_period_start() {
  
  if (_impl_.stake_period_start_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Timestamp>(GetArenaForAllocation());
    _impl_.stake_period_start_ = p;
  }
  return _impl_.stake_period_start_;
}
inline ::proto::Timestamp* StakingInfo::mutable_stake_period_start() {
  ::proto::Timestamp* _msg = _internal_mutable_stake_period_start();
  // @@protoc_insertion_point(field_mutable:proto.StakingInfo.stake_period_start)
  return _msg;
}
inline void StakingInfo::set_allocated_stake_period_start(::proto::Timestamp* stake_period_start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stake_period_start_);
  }
  if (stake_period_start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stake_period_start));
    if (message_arena != submessage_arena) {
      stake_period_start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stake_period_start, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stake_period_start_ = stake_period_start;
  // @@protoc_insertion_point(field_set_allocated:proto.StakingInfo.stake_period_start)
}

// int64 pending_reward = 3;
inline void StakingInfo::clear_pending_reward() {
  _impl_.pending_reward_ = int64_t{0};
}
inline int64_t StakingInfo::_internal_pending_reward() const {
  return _impl_.pending_reward_;
}
inline int64_t StakingInfo::pending_reward() const {
  // @@protoc_insertion_point(field_get:proto.StakingInfo.pending_reward)
  return _internal_pending_reward();
}
inline void StakingInfo::_internal_set_pending_reward(int64_t value) {
  
  _impl_.pending_reward_ = value;
}
inline void StakingInfo::set_pending_reward(int64_t value) {
  _internal_set_pending_reward(value);
  // @@protoc_insertion_point(field_set:proto.StakingInfo.pending_reward)
}

// int64 staked_to_me = 4;
inline void StakingInfo::clear_staked_to_me() {
  _impl_.staked_to_me_ = int64_t{0};
}
inline int64_t StakingInfo::_internal_staked_to_me() const {
  return _impl_.staked_to_me_;
}
inline int64_t StakingInfo::staked_to_me() const {
  // @@protoc_insertion_point(field_get:proto.StakingInfo.staked_to_me)
  return _internal_staked_to_me();
}
inline void StakingInfo::_internal_set_staked_to_me(int64_t value) {
  
  _impl_.staked_to_me_ = value;
}
inline void StakingInfo::set_staked_to_me(int64_t value) {
  _internal_set_staked_to_me(value);
  // @@protoc_insertion_point(field_set:proto.StakingInfo.staked_to_me)
}

// .proto.AccountID staked_account_id = 5;
inline bool StakingInfo::_internal_has_staked_account_id() const {
  return staked_id_case() == kStakedAccountId;
}
inline bool StakingInfo::has_staked_account_id() const {
  return _internal_has_staked_account_id();
}
inline void StakingInfo::set_has_staked_account_id() {
  _impl_._oneof_case_[0] = kStakedAccountId;
}
inline void StakingInfo::clear_staked_account_id() {
  if (_internal_has_staked_account_id()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.staked_id_.staked_account_id_;
    }
    clear_has_staked_id();
  }
}
inline ::proto::AccountID* StakingInfo::release_staked_account_id() {
  // @@protoc_insertion_point(field_release:proto.StakingInfo.staked_account_id)
  if (_internal_has_staked_account_id()) {
    clear_has_staked_id();
    ::proto::AccountID* temp = _impl_.staked_id_.staked_account_id_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.staked_id_.staked_account_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::AccountID& StakingInfo::_internal_staked_account_id() const {
  return _internal_has_staked_account_id()
      ? *_impl_.staked_id_.staked_account_id_
      : reinterpret_cast< ::proto::AccountID&>(::proto::_AccountID_default_instance_);
}
inline const ::proto::AccountID& StakingInfo::staked_account_id() const {
  // @@protoc_insertion_point(field_get:proto.StakingInfo.staked_account_id)
  return _internal_staked_account_id();
}
inline ::proto::AccountID* StakingInfo::unsafe_arena_release_staked_account_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.StakingInfo.staked_account_id)
  if (_internal_has_staked_account_id()) {
    clear_has_staked_id();
    ::proto::AccountID* temp = _impl_.staked_id_.staked_account_id_;
    _impl_.staked_id_.staked_account_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StakingInfo::unsafe_arena_set_allocated_staked_account_id(::proto::AccountID* staked_account_id) {
  clear_staked_id();
  if (staked_account_id) {
    set_has_staked_account_id();
    _impl_.staked_id_.staked_account_id_ = staked_account_id;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.StakingInfo.staked_account_id)
}
inline ::proto::AccountID* StakingInfo::_internal_mutable_staked_account_id() {
  if (!_internal_has_staked_account_id()) {
    clear_staked_id();
    set_has_staked_account_id();
    _impl_.staked_id_.staked_account_id_ = CreateMaybeMessage< ::proto::AccountID >(GetArenaForAllocation());
  }
  return _impl_.staked_id_.staked_account_id_;
}
inline ::proto::AccountID* StakingInfo::mutable_staked_account_id() {
  ::proto::AccountID* _msg = _internal_mutable_staked_account_id();
  // @@protoc_insertion_point(field_mutable:proto.StakingInfo.staked_account_id)
  return _msg;
}

// int64 staked_node_id = 6;
inline bool StakingInfo::_internal_has_staked_node_id() const {
  return staked_id_case() == kStakedNodeId;
}
inline bool StakingInfo::has_staked_node_id() const {
  return _internal_has_staked_node_id();
}
inline void StakingInfo::set_has_staked_node_id() {
  _impl_._oneof_case_[0] = kStakedNodeId;
}
inline void StakingInfo::clear_staked_node_id() {
  if (_internal_has_staked_node_id()) {
    _impl_.staked_id_.staked_node_id_ = int64_t{0};
    clear_has_staked_id();
  }
}
inline int64_t StakingInfo::_internal_staked_node_id() const {
  if (_internal_has_staked_node_id()) {
    return _impl_.staked_id_.staked_node_id_;
  }
  return int64_t{0};
}
inline void StakingInfo::_internal_set_staked_node_id(int64_t value) {
  if (!_internal_has_staked_node_id()) {
    clear_staked_id();
    set_has_staked_node_id();
  }
  _impl_.staked_id_.staked_node_id_ = value;
}
inline int64_t StakingInfo::staked_node_id() const {
  // @@protoc_insertion_point(field_get:proto.StakingInfo.staked_node_id)
  return _internal_staked_node_id();
}
inline void StakingInfo::set_staked_node_id(int64_t value) {
  _internal_set_staked_node_id(value);
  // @@protoc_insertion_point(field_set:proto.StakingInfo.staked_node_id)
}

inline bool StakingInfo::has_staked_id() const {
  return staked_id_case() != STAKED_ID_NOT_SET;
}
inline void StakingInfo::clear_has_staked_id() {
  _impl_._oneof_case_[0] = STAKED_ID_NOT_SET;
}
inline StakingInfo::StakedIdCase StakingInfo::staked_id_case() const {
  return StakingInfo::StakedIdCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::proto::TokenType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::TokenType>() {
  return ::proto::TokenType_descriptor();
}
template <> struct is_proto_enum< ::proto::SubType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::SubType>() {
  return ::proto::SubType_descriptor();
}
template <> struct is_proto_enum< ::proto::TokenSupplyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::TokenSupplyType>() {
  return ::proto::TokenSupplyType_descriptor();
}
template <> struct is_proto_enum< ::proto::TokenFreezeStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::TokenFreezeStatus>() {
  return ::proto::TokenFreezeStatus_descriptor();
}
template <> struct is_proto_enum< ::proto::TokenKycStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::TokenKycStatus>() {
  return ::proto::TokenKycStatus_descriptor();
}
template <> struct is_proto_enum< ::proto::TokenPauseStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::TokenPauseStatus>() {
  return ::proto::TokenPauseStatus_descriptor();
}
template <> struct is_proto_enum< ::proto::HederaFunctionality> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::HederaFunctionality>() {
  return ::proto::HederaFunctionality_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_basic_5ftypes_2eproto
