// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: crypto_get_info.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_crypto_5fget_5finfo_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_crypto_5fget_5finfo_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "timestamp.pb.h"
#include "duration.pb.h"
#include "basic_types.pb.h"
#include "query_header.pb.h"
#include "response_header.pb.h"
#include "crypto_add_live_hash.pb.h"
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_crypto_5fget_5finfo_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_crypto_5fget_5finfo_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_crypto_5fget_5finfo_2eproto;
namespace proto {
class CryptoGetInfoQuery;
struct CryptoGetInfoQueryDefaultTypeInternal;
extern CryptoGetInfoQueryDefaultTypeInternal _CryptoGetInfoQuery_default_instance_;
class CryptoGetInfoResponse;
struct CryptoGetInfoResponseDefaultTypeInternal;
extern CryptoGetInfoResponseDefaultTypeInternal _CryptoGetInfoResponse_default_instance_;
class CryptoGetInfoResponse_AccountInfo;
struct CryptoGetInfoResponse_AccountInfoDefaultTypeInternal;
extern CryptoGetInfoResponse_AccountInfoDefaultTypeInternal _CryptoGetInfoResponse_AccountInfo_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::CryptoGetInfoQuery* Arena::CreateMaybeMessage<::proto::CryptoGetInfoQuery>(Arena*);
template<> ::proto::CryptoGetInfoResponse* Arena::CreateMaybeMessage<::proto::CryptoGetInfoResponse>(Arena*);
template<> ::proto::CryptoGetInfoResponse_AccountInfo* Arena::CreateMaybeMessage<::proto::CryptoGetInfoResponse_AccountInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

// ===================================================================

class CryptoGetInfoQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.CryptoGetInfoQuery) */ {
 public:
  inline CryptoGetInfoQuery() : CryptoGetInfoQuery(nullptr) {}
  ~CryptoGetInfoQuery() override;
  explicit PROTOBUF_CONSTEXPR CryptoGetInfoQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CryptoGetInfoQuery(const CryptoGetInfoQuery& from);
  CryptoGetInfoQuery(CryptoGetInfoQuery&& from) noexcept
    : CryptoGetInfoQuery() {
    *this = ::std::move(from);
  }

  inline CryptoGetInfoQuery& operator=(const CryptoGetInfoQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline CryptoGetInfoQuery& operator=(CryptoGetInfoQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CryptoGetInfoQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const CryptoGetInfoQuery* internal_default_instance() {
    return reinterpret_cast<const CryptoGetInfoQuery*>(
               &_CryptoGetInfoQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CryptoGetInfoQuery& a, CryptoGetInfoQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(CryptoGetInfoQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CryptoGetInfoQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CryptoGetInfoQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CryptoGetInfoQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CryptoGetInfoQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CryptoGetInfoQuery& from) {
    CryptoGetInfoQuery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CryptoGetInfoQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.CryptoGetInfoQuery";
  }
  protected:
  explicit CryptoGetInfoQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kAccountIDFieldNumber = 2,
  };
  // .proto.QueryHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::proto::QueryHeader& header() const;
  PROTOBUF_NODISCARD ::proto::QueryHeader* release_header();
  ::proto::QueryHeader* mutable_header();
  void set_allocated_header(::proto::QueryHeader* header);
  private:
  const ::proto::QueryHeader& _internal_header() const;
  ::proto::QueryHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::proto::QueryHeader* header);
  ::proto::QueryHeader* unsafe_arena_release_header();

  // .proto.AccountID accountID = 2;
  bool has_accountid() const;
  private:
  bool _internal_has_accountid() const;
  public:
  void clear_accountid();
  const ::proto::AccountID& accountid() const;
  PROTOBUF_NODISCARD ::proto::AccountID* release_accountid();
  ::proto::AccountID* mutable_accountid();
  void set_allocated_accountid(::proto::AccountID* accountid);
  private:
  const ::proto::AccountID& _internal_accountid() const;
  ::proto::AccountID* _internal_mutable_accountid();
  public:
  void unsafe_arena_set_allocated_accountid(
      ::proto::AccountID* accountid);
  ::proto::AccountID* unsafe_arena_release_accountid();

  // @@protoc_insertion_point(class_scope:proto.CryptoGetInfoQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::QueryHeader* header_;
    ::proto::AccountID* accountid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_crypto_5fget_5finfo_2eproto;
};
// -------------------------------------------------------------------

class CryptoGetInfoResponse_AccountInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.CryptoGetInfoResponse.AccountInfo) */ {
 public:
  inline CryptoGetInfoResponse_AccountInfo() : CryptoGetInfoResponse_AccountInfo(nullptr) {}
  ~CryptoGetInfoResponse_AccountInfo() override;
  explicit PROTOBUF_CONSTEXPR CryptoGetInfoResponse_AccountInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CryptoGetInfoResponse_AccountInfo(const CryptoGetInfoResponse_AccountInfo& from);
  CryptoGetInfoResponse_AccountInfo(CryptoGetInfoResponse_AccountInfo&& from) noexcept
    : CryptoGetInfoResponse_AccountInfo() {
    *this = ::std::move(from);
  }

  inline CryptoGetInfoResponse_AccountInfo& operator=(const CryptoGetInfoResponse_AccountInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CryptoGetInfoResponse_AccountInfo& operator=(CryptoGetInfoResponse_AccountInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CryptoGetInfoResponse_AccountInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CryptoGetInfoResponse_AccountInfo* internal_default_instance() {
    return reinterpret_cast<const CryptoGetInfoResponse_AccountInfo*>(
               &_CryptoGetInfoResponse_AccountInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CryptoGetInfoResponse_AccountInfo& a, CryptoGetInfoResponse_AccountInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CryptoGetInfoResponse_AccountInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CryptoGetInfoResponse_AccountInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CryptoGetInfoResponse_AccountInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CryptoGetInfoResponse_AccountInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CryptoGetInfoResponse_AccountInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CryptoGetInfoResponse_AccountInfo& from) {
    CryptoGetInfoResponse_AccountInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CryptoGetInfoResponse_AccountInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.CryptoGetInfoResponse.AccountInfo";
  }
  protected:
  explicit CryptoGetInfoResponse_AccountInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLiveHashesFieldNumber = 14,
    kTokenRelationshipsFieldNumber = 15,
    kContractAccountIDFieldNumber = 2,
    kMemoFieldNumber = 16,
    kAliasFieldNumber = 19,
    kLedgerIdFieldNumber = 20,
    kAccountIDFieldNumber = 1,
    kProxyAccountIDFieldNumber = 4,
    kKeyFieldNumber = 7,
    kExpirationTimeFieldNumber = 12,
    kAutoRenewPeriodFieldNumber = 13,
    kStakingInfoFieldNumber = 22,
    kProxyReceivedFieldNumber = 6,
    kBalanceFieldNumber = 8,
    kGenerateSendRecordThresholdFieldNumber = 9,
    kGenerateReceiveRecordThresholdFieldNumber = 10,
    kDeletedFieldNumber = 3,
    kReceiverSigRequiredFieldNumber = 11,
    kMaxAutomaticTokenAssociationsFieldNumber = 18,
    kOwnedNftsFieldNumber = 17,
    kEthereumNonceFieldNumber = 21,
  };
  // repeated .proto.LiveHash liveHashes = 14;
  int livehashes_size() const;
  private:
  int _internal_livehashes_size() const;
  public:
  void clear_livehashes();
  ::proto::LiveHash* mutable_livehashes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::LiveHash >*
      mutable_livehashes();
  private:
  const ::proto::LiveHash& _internal_livehashes(int index) const;
  ::proto::LiveHash* _internal_add_livehashes();
  public:
  const ::proto::LiveHash& livehashes(int index) const;
  ::proto::LiveHash* add_livehashes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::LiveHash >&
      livehashes() const;

  // repeated .proto.TokenRelationship tokenRelationships = 15 [deprecated = true];
  PROTOBUF_DEPRECATED int tokenrelationships_size() const;
  private:
  int _internal_tokenrelationships_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_tokenrelationships();
  PROTOBUF_DEPRECATED ::proto::TokenRelationship* mutable_tokenrelationships(int index);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TokenRelationship >*
      mutable_tokenrelationships();
  private:
  const ::proto::TokenRelationship& _internal_tokenrelationships(int index) const;
  ::proto::TokenRelationship* _internal_add_tokenrelationships();
  public:
  PROTOBUF_DEPRECATED const ::proto::TokenRelationship& tokenrelationships(int index) const;
  PROTOBUF_DEPRECATED ::proto::TokenRelationship* add_tokenrelationships();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TokenRelationship >&
      tokenrelationships() const;

  // string contractAccountID = 2;
  void clear_contractaccountid();
  const std::string& contractaccountid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contractaccountid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contractaccountid();
  PROTOBUF_NODISCARD std::string* release_contractaccountid();
  void set_allocated_contractaccountid(std::string* contractaccountid);
  private:
  const std::string& _internal_contractaccountid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contractaccountid(const std::string& value);
  std::string* _internal_mutable_contractaccountid();
  public:

  // string memo = 16;
  void clear_memo();
  const std::string& memo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memo();
  PROTOBUF_NODISCARD std::string* release_memo();
  void set_allocated_memo(std::string* memo);
  private:
  const std::string& _internal_memo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memo(const std::string& value);
  std::string* _internal_mutable_memo();
  public:

  // bytes alias = 19;
  void clear_alias();
  const std::string& alias() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_alias(ArgT0&& arg0, ArgT... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* alias);
  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(const std::string& value);
  std::string* _internal_mutable_alias();
  public:

  // bytes ledger_id = 20;
  void clear_ledger_id();
  const std::string& ledger_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ledger_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ledger_id();
  PROTOBUF_NODISCARD std::string* release_ledger_id();
  void set_allocated_ledger_id(std::string* ledger_id);
  private:
  const std::string& _internal_ledger_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ledger_id(const std::string& value);
  std::string* _internal_mutable_ledger_id();
  public:

  // .proto.AccountID accountID = 1;
  bool has_accountid() const;
  private:
  bool _internal_has_accountid() const;
  public:
  void clear_accountid();
  const ::proto::AccountID& accountid() const;
  PROTOBUF_NODISCARD ::proto::AccountID* release_accountid();
  ::proto::AccountID* mutable_accountid();
  void set_allocated_accountid(::proto::AccountID* accountid);
  private:
  const ::proto::AccountID& _internal_accountid() const;
  ::proto::AccountID* _internal_mutable_accountid();
  public:
  void unsafe_arena_set_allocated_accountid(
      ::proto::AccountID* accountid);
  ::proto::AccountID* unsafe_arena_release_accountid();

  // .proto.AccountID proxyAccountID = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_proxyaccountid() const;
  private:
  bool _internal_has_proxyaccountid() const;
  public:
  PROTOBUF_DEPRECATED void clear_proxyaccountid();
  PROTOBUF_DEPRECATED const ::proto::AccountID& proxyaccountid() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::proto::AccountID* release_proxyaccountid();
  PROTOBUF_DEPRECATED ::proto::AccountID* mutable_proxyaccountid();
  PROTOBUF_DEPRECATED void set_allocated_proxyaccountid(::proto::AccountID* proxyaccountid);
  private:
  const ::proto::AccountID& _internal_proxyaccountid() const;
  ::proto::AccountID* _internal_mutable_proxyaccountid();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_proxyaccountid(
      ::proto::AccountID* proxyaccountid);
  PROTOBUF_DEPRECATED ::proto::AccountID* unsafe_arena_release_proxyaccountid();

  // .proto.Key key = 7;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::proto::Key& key() const;
  PROTOBUF_NODISCARD ::proto::Key* release_key();
  ::proto::Key* mutable_key();
  void set_allocated_key(::proto::Key* key);
  private:
  const ::proto::Key& _internal_key() const;
  ::proto::Key* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::proto::Key* key);
  ::proto::Key* unsafe_arena_release_key();

  // .proto.Timestamp expirationTime = 12;
  bool has_expirationtime() const;
  private:
  bool _internal_has_expirationtime() const;
  public:
  void clear_expirationtime();
  const ::proto::Timestamp& expirationtime() const;
  PROTOBUF_NODISCARD ::proto::Timestamp* release_expirationtime();
  ::proto::Timestamp* mutable_expirationtime();
  void set_allocated_expirationtime(::proto::Timestamp* expirationtime);
  private:
  const ::proto::Timestamp& _internal_expirationtime() const;
  ::proto::Timestamp* _internal_mutable_expirationtime();
  public:
  void unsafe_arena_set_allocated_expirationtime(
      ::proto::Timestamp* expirationtime);
  ::proto::Timestamp* unsafe_arena_release_expirationtime();

  // .proto.Duration autoRenewPeriod = 13;
  bool has_autorenewperiod() const;
  private:
  bool _internal_has_autorenewperiod() const;
  public:
  void clear_autorenewperiod();
  const ::proto::Duration& autorenewperiod() const;
  PROTOBUF_NODISCARD ::proto::Duration* release_autorenewperiod();
  ::proto::Duration* mutable_autorenewperiod();
  void set_allocated_autorenewperiod(::proto::Duration* autorenewperiod);
  private:
  const ::proto::Duration& _internal_autorenewperiod() const;
  ::proto::Duration* _internal_mutable_autorenewperiod();
  public:
  void unsafe_arena_set_allocated_autorenewperiod(
      ::proto::Duration* autorenewperiod);
  ::proto::Duration* unsafe_arena_release_autorenewperiod();

  // .proto.StakingInfo staking_info = 22;
  bool has_staking_info() const;
  private:
  bool _internal_has_staking_info() const;
  public:
  void clear_staking_info();
  const ::proto::StakingInfo& staking_info() const;
  PROTOBUF_NODISCARD ::proto::StakingInfo* release_staking_info();
  ::proto::StakingInfo* mutable_staking_info();
  void set_allocated_staking_info(::proto::StakingInfo* staking_info);
  private:
  const ::proto::StakingInfo& _internal_staking_info() const;
  ::proto::StakingInfo* _internal_mutable_staking_info();
  public:
  void unsafe_arena_set_allocated_staking_info(
      ::proto::StakingInfo* staking_info);
  ::proto::StakingInfo* unsafe_arena_release_staking_info();

  // int64 proxyReceived = 6;
  void clear_proxyreceived();
  int64_t proxyreceived() const;
  void set_proxyreceived(int64_t value);
  private:
  int64_t _internal_proxyreceived() const;
  void _internal_set_proxyreceived(int64_t value);
  public:

  // uint64 balance = 8;
  void clear_balance();
  uint64_t balance() const;
  void set_balance(uint64_t value);
  private:
  uint64_t _internal_balance() const;
  void _internal_set_balance(uint64_t value);
  public:

  // uint64 generateSendRecordThreshold = 9 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_generatesendrecordthreshold();
  PROTOBUF_DEPRECATED uint64_t generatesendrecordthreshold() const;
  PROTOBUF_DEPRECATED void set_generatesendrecordthreshold(uint64_t value);
  private:
  uint64_t _internal_generatesendrecordthreshold() const;
  void _internal_set_generatesendrecordthreshold(uint64_t value);
  public:

  // uint64 generateReceiveRecordThreshold = 10 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_generatereceiverecordthreshold();
  PROTOBUF_DEPRECATED uint64_t generatereceiverecordthreshold() const;
  PROTOBUF_DEPRECATED void set_generatereceiverecordthreshold(uint64_t value);
  private:
  uint64_t _internal_generatereceiverecordthreshold() const;
  void _internal_set_generatereceiverecordthreshold(uint64_t value);
  public:

  // bool deleted = 3;
  void clear_deleted();
  bool deleted() const;
  void set_deleted(bool value);
  private:
  bool _internal_deleted() const;
  void _internal_set_deleted(bool value);
  public:

  // bool receiverSigRequired = 11;
  void clear_receiversigrequired();
  bool receiversigrequired() const;
  void set_receiversigrequired(bool value);
  private:
  bool _internal_receiversigrequired() const;
  void _internal_set_receiversigrequired(bool value);
  public:

  // int32 max_automatic_token_associations = 18;
  void clear_max_automatic_token_associations();
  int32_t max_automatic_token_associations() const;
  void set_max_automatic_token_associations(int32_t value);
  private:
  int32_t _internal_max_automatic_token_associations() const;
  void _internal_set_max_automatic_token_associations(int32_t value);
  public:

  // int64 ownedNfts = 17;
  void clear_ownednfts();
  int64_t ownednfts() const;
  void set_ownednfts(int64_t value);
  private:
  int64_t _internal_ownednfts() const;
  void _internal_set_ownednfts(int64_t value);
  public:

  // int64 ethereum_nonce = 21;
  void clear_ethereum_nonce();
  int64_t ethereum_nonce() const;
  void set_ethereum_nonce(int64_t value);
  private:
  int64_t _internal_ethereum_nonce() const;
  void _internal_set_ethereum_nonce(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.CryptoGetInfoResponse.AccountInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::LiveHash > livehashes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TokenRelationship > tokenrelationships_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contractaccountid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alias_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ledger_id_;
    ::proto::AccountID* accountid_;
    ::proto::AccountID* proxyaccountid_;
    ::proto::Key* key_;
    ::proto::Timestamp* expirationtime_;
    ::proto::Duration* autorenewperiod_;
    ::proto::StakingInfo* staking_info_;
    int64_t proxyreceived_;
    uint64_t balance_;
    uint64_t generatesendrecordthreshold_;
    uint64_t generatereceiverecordthreshold_;
    bool deleted_;
    bool receiversigrequired_;
    int32_t max_automatic_token_associations_;
    int64_t ownednfts_;
    int64_t ethereum_nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_crypto_5fget_5finfo_2eproto;
};
// -------------------------------------------------------------------

class CryptoGetInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.CryptoGetInfoResponse) */ {
 public:
  inline CryptoGetInfoResponse() : CryptoGetInfoResponse(nullptr) {}
  ~CryptoGetInfoResponse() override;
  explicit PROTOBUF_CONSTEXPR CryptoGetInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CryptoGetInfoResponse(const CryptoGetInfoResponse& from);
  CryptoGetInfoResponse(CryptoGetInfoResponse&& from) noexcept
    : CryptoGetInfoResponse() {
    *this = ::std::move(from);
  }

  inline CryptoGetInfoResponse& operator=(const CryptoGetInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CryptoGetInfoResponse& operator=(CryptoGetInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CryptoGetInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CryptoGetInfoResponse* internal_default_instance() {
    return reinterpret_cast<const CryptoGetInfoResponse*>(
               &_CryptoGetInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CryptoGetInfoResponse& a, CryptoGetInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CryptoGetInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CryptoGetInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CryptoGetInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CryptoGetInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CryptoGetInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CryptoGetInfoResponse& from) {
    CryptoGetInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CryptoGetInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.CryptoGetInfoResponse";
  }
  protected:
  explicit CryptoGetInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CryptoGetInfoResponse_AccountInfo AccountInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kAccountInfoFieldNumber = 2,
  };
  // .proto.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::proto::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::proto::ResponseHeader* release_header();
  ::proto::ResponseHeader* mutable_header();
  void set_allocated_header(::proto::ResponseHeader* header);
  private:
  const ::proto::ResponseHeader& _internal_header() const;
  ::proto::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::proto::ResponseHeader* header);
  ::proto::ResponseHeader* unsafe_arena_release_header();

  // .proto.CryptoGetInfoResponse.AccountInfo accountInfo = 2;
  bool has_accountinfo() const;
  private:
  bool _internal_has_accountinfo() const;
  public:
  void clear_accountinfo();
  const ::proto::CryptoGetInfoResponse_AccountInfo& accountinfo() const;
  PROTOBUF_NODISCARD ::proto::CryptoGetInfoResponse_AccountInfo* release_accountinfo();
  ::proto::CryptoGetInfoResponse_AccountInfo* mutable_accountinfo();
  void set_allocated_accountinfo(::proto::CryptoGetInfoResponse_AccountInfo* accountinfo);
  private:
  const ::proto::CryptoGetInfoResponse_AccountInfo& _internal_accountinfo() const;
  ::proto::CryptoGetInfoResponse_AccountInfo* _internal_mutable_accountinfo();
  public:
  void unsafe_arena_set_allocated_accountinfo(
      ::proto::CryptoGetInfoResponse_AccountInfo* accountinfo);
  ::proto::CryptoGetInfoResponse_AccountInfo* unsafe_arena_release_accountinfo();

  // @@protoc_insertion_point(class_scope:proto.CryptoGetInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::ResponseHeader* header_;
    ::proto::CryptoGetInfoResponse_AccountInfo* accountinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_crypto_5fget_5finfo_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CryptoGetInfoQuery

// .proto.QueryHeader header = 1;
inline bool CryptoGetInfoQuery::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool CryptoGetInfoQuery::has_header() const {
  return _internal_has_header();
}
inline const ::proto::QueryHeader& CryptoGetInfoQuery::_internal_header() const {
  const ::proto::QueryHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::QueryHeader&>(
      ::proto::_QueryHeader_default_instance_);
}
inline const ::proto::QueryHeader& CryptoGetInfoQuery::header() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoQuery.header)
  return _internal_header();
}
inline void CryptoGetInfoQuery::unsafe_arena_set_allocated_header(
    ::proto::QueryHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.CryptoGetInfoQuery.header)
}
inline ::proto::QueryHeader* CryptoGetInfoQuery::release_header() {
  
  ::proto::QueryHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::QueryHeader* CryptoGetInfoQuery::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:proto.CryptoGetInfoQuery.header)
  
  ::proto::QueryHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::proto::QueryHeader* CryptoGetInfoQuery::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::QueryHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::proto::QueryHeader* CryptoGetInfoQuery::mutable_header() {
  ::proto::QueryHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:proto.CryptoGetInfoQuery.header)
  return _msg;
}
inline void CryptoGetInfoQuery::set_allocated_header(::proto::QueryHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:proto.CryptoGetInfoQuery.header)
}

// .proto.AccountID accountID = 2;
inline bool CryptoGetInfoQuery::_internal_has_accountid() const {
  return this != internal_default_instance() && _impl_.accountid_ != nullptr;
}
inline bool CryptoGetInfoQuery::has_accountid() const {
  return _internal_has_accountid();
}
inline const ::proto::AccountID& CryptoGetInfoQuery::_internal_accountid() const {
  const ::proto::AccountID* p = _impl_.accountid_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AccountID&>(
      ::proto::_AccountID_default_instance_);
}
inline const ::proto::AccountID& CryptoGetInfoQuery::accountid() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoQuery.accountID)
  return _internal_accountid();
}
inline void CryptoGetInfoQuery::unsafe_arena_set_allocated_accountid(
    ::proto::AccountID* accountid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.accountid_);
  }
  _impl_.accountid_ = accountid;
  if (accountid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.CryptoGetInfoQuery.accountID)
}
inline ::proto::AccountID* CryptoGetInfoQuery::release_accountid() {
  
  ::proto::AccountID* temp = _impl_.accountid_;
  _impl_.accountid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AccountID* CryptoGetInfoQuery::unsafe_arena_release_accountid() {
  // @@protoc_insertion_point(field_release:proto.CryptoGetInfoQuery.accountID)
  
  ::proto::AccountID* temp = _impl_.accountid_;
  _impl_.accountid_ = nullptr;
  return temp;
}
inline ::proto::AccountID* CryptoGetInfoQuery::_internal_mutable_accountid() {
  
  if (_impl_.accountid_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AccountID>(GetArenaForAllocation());
    _impl_.accountid_ = p;
  }
  return _impl_.accountid_;
}
inline ::proto::AccountID* CryptoGetInfoQuery::mutable_accountid() {
  ::proto::AccountID* _msg = _internal_mutable_accountid();
  // @@protoc_insertion_point(field_mutable:proto.CryptoGetInfoQuery.accountID)
  return _msg;
}
inline void CryptoGetInfoQuery::set_allocated_accountid(::proto::AccountID* accountid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.accountid_);
  }
  if (accountid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(accountid));
    if (message_arena != submessage_arena) {
      accountid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, accountid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.accountid_ = accountid;
  // @@protoc_insertion_point(field_set_allocated:proto.CryptoGetInfoQuery.accountID)
}

// -------------------------------------------------------------------

// CryptoGetInfoResponse_AccountInfo

// .proto.AccountID accountID = 1;
inline bool CryptoGetInfoResponse_AccountInfo::_internal_has_accountid() const {
  return this != internal_default_instance() && _impl_.accountid_ != nullptr;
}
inline bool CryptoGetInfoResponse_AccountInfo::has_accountid() const {
  return _internal_has_accountid();
}
inline const ::proto::AccountID& CryptoGetInfoResponse_AccountInfo::_internal_accountid() const {
  const ::proto::AccountID* p = _impl_.accountid_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AccountID&>(
      ::proto::_AccountID_default_instance_);
}
inline const ::proto::AccountID& CryptoGetInfoResponse_AccountInfo::accountid() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.AccountInfo.accountID)
  return _internal_accountid();
}
inline void CryptoGetInfoResponse_AccountInfo::unsafe_arena_set_allocated_accountid(
    ::proto::AccountID* accountid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.accountid_);
  }
  _impl_.accountid_ = accountid;
  if (accountid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.CryptoGetInfoResponse.AccountInfo.accountID)
}
inline ::proto::AccountID* CryptoGetInfoResponse_AccountInfo::release_accountid() {
  
  ::proto::AccountID* temp = _impl_.accountid_;
  _impl_.accountid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AccountID* CryptoGetInfoResponse_AccountInfo::unsafe_arena_release_accountid() {
  // @@protoc_insertion_point(field_release:proto.CryptoGetInfoResponse.AccountInfo.accountID)
  
  ::proto::AccountID* temp = _impl_.accountid_;
  _impl_.accountid_ = nullptr;
  return temp;
}
inline ::proto::AccountID* CryptoGetInfoResponse_AccountInfo::_internal_mutable_accountid() {
  
  if (_impl_.accountid_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AccountID>(GetArenaForAllocation());
    _impl_.accountid_ = p;
  }
  return _impl_.accountid_;
}
inline ::proto::AccountID* CryptoGetInfoResponse_AccountInfo::mutable_accountid() {
  ::proto::AccountID* _msg = _internal_mutable_accountid();
  // @@protoc_insertion_point(field_mutable:proto.CryptoGetInfoResponse.AccountInfo.accountID)
  return _msg;
}
inline void CryptoGetInfoResponse_AccountInfo::set_allocated_accountid(::proto::AccountID* accountid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.accountid_);
  }
  if (accountid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(accountid));
    if (message_arena != submessage_arena) {
      accountid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, accountid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.accountid_ = accountid;
  // @@protoc_insertion_point(field_set_allocated:proto.CryptoGetInfoResponse.AccountInfo.accountID)
}

// string contractAccountID = 2;
inline void CryptoGetInfoResponse_AccountInfo::clear_contractaccountid() {
  _impl_.contractaccountid_.ClearToEmpty();
}
inline const std::string& CryptoGetInfoResponse_AccountInfo::contractaccountid() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.AccountInfo.contractAccountID)
  return _internal_contractaccountid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CryptoGetInfoResponse_AccountInfo::set_contractaccountid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contractaccountid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.CryptoGetInfoResponse.AccountInfo.contractAccountID)
}
inline std::string* CryptoGetInfoResponse_AccountInfo::mutable_contractaccountid() {
  std::string* _s = _internal_mutable_contractaccountid();
  // @@protoc_insertion_point(field_mutable:proto.CryptoGetInfoResponse.AccountInfo.contractAccountID)
  return _s;
}
inline const std::string& CryptoGetInfoResponse_AccountInfo::_internal_contractaccountid() const {
  return _impl_.contractaccountid_.Get();
}
inline void CryptoGetInfoResponse_AccountInfo::_internal_set_contractaccountid(const std::string& value) {
  
  _impl_.contractaccountid_.Set(value, GetArenaForAllocation());
}
inline std::string* CryptoGetInfoResponse_AccountInfo::_internal_mutable_contractaccountid() {
  
  return _impl_.contractaccountid_.Mutable(GetArenaForAllocation());
}
inline std::string* CryptoGetInfoResponse_AccountInfo::release_contractaccountid() {
  // @@protoc_insertion_point(field_release:proto.CryptoGetInfoResponse.AccountInfo.contractAccountID)
  return _impl_.contractaccountid_.Release();
}
inline void CryptoGetInfoResponse_AccountInfo::set_allocated_contractaccountid(std::string* contractaccountid) {
  if (contractaccountid != nullptr) {
    
  } else {
    
  }
  _impl_.contractaccountid_.SetAllocated(contractaccountid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contractaccountid_.IsDefault()) {
    _impl_.contractaccountid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.CryptoGetInfoResponse.AccountInfo.contractAccountID)
}

// bool deleted = 3;
inline void CryptoGetInfoResponse_AccountInfo::clear_deleted() {
  _impl_.deleted_ = false;
}
inline bool CryptoGetInfoResponse_AccountInfo::_internal_deleted() const {
  return _impl_.deleted_;
}
inline bool CryptoGetInfoResponse_AccountInfo::deleted() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.AccountInfo.deleted)
  return _internal_deleted();
}
inline void CryptoGetInfoResponse_AccountInfo::_internal_set_deleted(bool value) {
  
  _impl_.deleted_ = value;
}
inline void CryptoGetInfoResponse_AccountInfo::set_deleted(bool value) {
  _internal_set_deleted(value);
  // @@protoc_insertion_point(field_set:proto.CryptoGetInfoResponse.AccountInfo.deleted)
}

// .proto.AccountID proxyAccountID = 4 [deprecated = true];
inline bool CryptoGetInfoResponse_AccountInfo::_internal_has_proxyaccountid() const {
  return this != internal_default_instance() && _impl_.proxyaccountid_ != nullptr;
}
inline bool CryptoGetInfoResponse_AccountInfo::has_proxyaccountid() const {
  return _internal_has_proxyaccountid();
}
inline const ::proto::AccountID& CryptoGetInfoResponse_AccountInfo::_internal_proxyaccountid() const {
  const ::proto::AccountID* p = _impl_.proxyaccountid_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AccountID&>(
      ::proto::_AccountID_default_instance_);
}
inline const ::proto::AccountID& CryptoGetInfoResponse_AccountInfo::proxyaccountid() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.AccountInfo.proxyAccountID)
  return _internal_proxyaccountid();
}
inline void CryptoGetInfoResponse_AccountInfo::unsafe_arena_set_allocated_proxyaccountid(
    ::proto::AccountID* proxyaccountid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proxyaccountid_);
  }
  _impl_.proxyaccountid_ = proxyaccountid;
  if (proxyaccountid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.CryptoGetInfoResponse.AccountInfo.proxyAccountID)
}
inline ::proto::AccountID* CryptoGetInfoResponse_AccountInfo::release_proxyaccountid() {
  
  ::proto::AccountID* temp = _impl_.proxyaccountid_;
  _impl_.proxyaccountid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AccountID* CryptoGetInfoResponse_AccountInfo::unsafe_arena_release_proxyaccountid() {
  // @@protoc_insertion_point(field_release:proto.CryptoGetInfoResponse.AccountInfo.proxyAccountID)
  
  ::proto::AccountID* temp = _impl_.proxyaccountid_;
  _impl_.proxyaccountid_ = nullptr;
  return temp;
}
inline ::proto::AccountID* CryptoGetInfoResponse_AccountInfo::_internal_mutable_proxyaccountid() {
  
  if (_impl_.proxyaccountid_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AccountID>(GetArenaForAllocation());
    _impl_.proxyaccountid_ = p;
  }
  return _impl_.proxyaccountid_;
}
inline ::proto::AccountID* CryptoGetInfoResponse_AccountInfo::mutable_proxyaccountid() {
  ::proto::AccountID* _msg = _internal_mutable_proxyaccountid();
  // @@protoc_insertion_point(field_mutable:proto.CryptoGetInfoResponse.AccountInfo.proxyAccountID)
  return _msg;
}
inline void CryptoGetInfoResponse_AccountInfo::set_allocated_proxyaccountid(::proto::AccountID* proxyaccountid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proxyaccountid_);
  }
  if (proxyaccountid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proxyaccountid));
    if (message_arena != submessage_arena) {
      proxyaccountid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proxyaccountid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.proxyaccountid_ = proxyaccountid;
  // @@protoc_insertion_point(field_set_allocated:proto.CryptoGetInfoResponse.AccountInfo.proxyAccountID)
}

// int64 proxyReceived = 6;
inline void CryptoGetInfoResponse_AccountInfo::clear_proxyreceived() {
  _impl_.proxyreceived_ = int64_t{0};
}
inline int64_t CryptoGetInfoResponse_AccountInfo::_internal_proxyreceived() const {
  return _impl_.proxyreceived_;
}
inline int64_t CryptoGetInfoResponse_AccountInfo::proxyreceived() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.AccountInfo.proxyReceived)
  return _internal_proxyreceived();
}
inline void CryptoGetInfoResponse_AccountInfo::_internal_set_proxyreceived(int64_t value) {
  
  _impl_.proxyreceived_ = value;
}
inline void CryptoGetInfoResponse_AccountInfo::set_proxyreceived(int64_t value) {
  _internal_set_proxyreceived(value);
  // @@protoc_insertion_point(field_set:proto.CryptoGetInfoResponse.AccountInfo.proxyReceived)
}

// .proto.Key key = 7;
inline bool CryptoGetInfoResponse_AccountInfo::_internal_has_key() const {
  return this != internal_default_instance() && _impl_.key_ != nullptr;
}
inline bool CryptoGetInfoResponse_AccountInfo::has_key() const {
  return _internal_has_key();
}
inline const ::proto::Key& CryptoGetInfoResponse_AccountInfo::_internal_key() const {
  const ::proto::Key* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Key&>(
      ::proto::_Key_default_instance_);
}
inline const ::proto::Key& CryptoGetInfoResponse_AccountInfo::key() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.AccountInfo.key)
  return _internal_key();
}
inline void CryptoGetInfoResponse_AccountInfo::unsafe_arena_set_allocated_key(
    ::proto::Key* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.CryptoGetInfoResponse.AccountInfo.key)
}
inline ::proto::Key* CryptoGetInfoResponse_AccountInfo::release_key() {
  
  ::proto::Key* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Key* CryptoGetInfoResponse_AccountInfo::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:proto.CryptoGetInfoResponse.AccountInfo.key)
  
  ::proto::Key* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::proto::Key* CryptoGetInfoResponse_AccountInfo::_internal_mutable_key() {
  
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Key>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::proto::Key* CryptoGetInfoResponse_AccountInfo::mutable_key() {
  ::proto::Key* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:proto.CryptoGetInfoResponse.AccountInfo.key)
  return _msg;
}
inline void CryptoGetInfoResponse_AccountInfo::set_allocated_key(::proto::Key* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key));
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:proto.CryptoGetInfoResponse.AccountInfo.key)
}

// uint64 balance = 8;
inline void CryptoGetInfoResponse_AccountInfo::clear_balance() {
  _impl_.balance_ = uint64_t{0u};
}
inline uint64_t CryptoGetInfoResponse_AccountInfo::_internal_balance() const {
  return _impl_.balance_;
}
inline uint64_t CryptoGetInfoResponse_AccountInfo::balance() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.AccountInfo.balance)
  return _internal_balance();
}
inline void CryptoGetInfoResponse_AccountInfo::_internal_set_balance(uint64_t value) {
  
  _impl_.balance_ = value;
}
inline void CryptoGetInfoResponse_AccountInfo::set_balance(uint64_t value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:proto.CryptoGetInfoResponse.AccountInfo.balance)
}

// uint64 generateSendRecordThreshold = 9 [deprecated = true];
inline void CryptoGetInfoResponse_AccountInfo::clear_generatesendrecordthreshold() {
  _impl_.generatesendrecordthreshold_ = uint64_t{0u};
}
inline uint64_t CryptoGetInfoResponse_AccountInfo::_internal_generatesendrecordthreshold() const {
  return _impl_.generatesendrecordthreshold_;
}
inline uint64_t CryptoGetInfoResponse_AccountInfo::generatesendrecordthreshold() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.AccountInfo.generateSendRecordThreshold)
  return _internal_generatesendrecordthreshold();
}
inline void CryptoGetInfoResponse_AccountInfo::_internal_set_generatesendrecordthreshold(uint64_t value) {
  
  _impl_.generatesendrecordthreshold_ = value;
}
inline void CryptoGetInfoResponse_AccountInfo::set_generatesendrecordthreshold(uint64_t value) {
  _internal_set_generatesendrecordthreshold(value);
  // @@protoc_insertion_point(field_set:proto.CryptoGetInfoResponse.AccountInfo.generateSendRecordThreshold)
}

// uint64 generateReceiveRecordThreshold = 10 [deprecated = true];
inline void CryptoGetInfoResponse_AccountInfo::clear_generatereceiverecordthreshold() {
  _impl_.generatereceiverecordthreshold_ = uint64_t{0u};
}
inline uint64_t CryptoGetInfoResponse_AccountInfo::_internal_generatereceiverecordthreshold() const {
  return _impl_.generatereceiverecordthreshold_;
}
inline uint64_t CryptoGetInfoResponse_AccountInfo::generatereceiverecordthreshold() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.AccountInfo.generateReceiveRecordThreshold)
  return _internal_generatereceiverecordthreshold();
}
inline void CryptoGetInfoResponse_AccountInfo::_internal_set_generatereceiverecordthreshold(uint64_t value) {
  
  _impl_.generatereceiverecordthreshold_ = value;
}
inline void CryptoGetInfoResponse_AccountInfo::set_generatereceiverecordthreshold(uint64_t value) {
  _internal_set_generatereceiverecordthreshold(value);
  // @@protoc_insertion_point(field_set:proto.CryptoGetInfoResponse.AccountInfo.generateReceiveRecordThreshold)
}

// bool receiverSigRequired = 11;
inline void CryptoGetInfoResponse_AccountInfo::clear_receiversigrequired() {
  _impl_.receiversigrequired_ = false;
}
inline bool CryptoGetInfoResponse_AccountInfo::_internal_receiversigrequired() const {
  return _impl_.receiversigrequired_;
}
inline bool CryptoGetInfoResponse_AccountInfo::receiversigrequired() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.AccountInfo.receiverSigRequired)
  return _internal_receiversigrequired();
}
inline void CryptoGetInfoResponse_AccountInfo::_internal_set_receiversigrequired(bool value) {
  
  _impl_.receiversigrequired_ = value;
}
inline void CryptoGetInfoResponse_AccountInfo::set_receiversigrequired(bool value) {
  _internal_set_receiversigrequired(value);
  // @@protoc_insertion_point(field_set:proto.CryptoGetInfoResponse.AccountInfo.receiverSigRequired)
}

// .proto.Timestamp expirationTime = 12;
inline bool CryptoGetInfoResponse_AccountInfo::_internal_has_expirationtime() const {
  return this != internal_default_instance() && _impl_.expirationtime_ != nullptr;
}
inline bool CryptoGetInfoResponse_AccountInfo::has_expirationtime() const {
  return _internal_has_expirationtime();
}
inline const ::proto::Timestamp& CryptoGetInfoResponse_AccountInfo::_internal_expirationtime() const {
  const ::proto::Timestamp* p = _impl_.expirationtime_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Timestamp&>(
      ::proto::_Timestamp_default_instance_);
}
inline const ::proto::Timestamp& CryptoGetInfoResponse_AccountInfo::expirationtime() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.AccountInfo.expirationTime)
  return _internal_expirationtime();
}
inline void CryptoGetInfoResponse_AccountInfo::unsafe_arena_set_allocated_expirationtime(
    ::proto::Timestamp* expirationtime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expirationtime_);
  }
  _impl_.expirationtime_ = expirationtime;
  if (expirationtime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.CryptoGetInfoResponse.AccountInfo.expirationTime)
}
inline ::proto::Timestamp* CryptoGetInfoResponse_AccountInfo::release_expirationtime() {
  
  ::proto::Timestamp* temp = _impl_.expirationtime_;
  _impl_.expirationtime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Timestamp* CryptoGetInfoResponse_AccountInfo::unsafe_arena_release_expirationtime() {
  // @@protoc_insertion_point(field_release:proto.CryptoGetInfoResponse.AccountInfo.expirationTime)
  
  ::proto::Timestamp* temp = _impl_.expirationtime_;
  _impl_.expirationtime_ = nullptr;
  return temp;
}
inline ::proto::Timestamp* CryptoGetInfoResponse_AccountInfo::_internal_mutable_expirationtime() {
  
  if (_impl_.expirationtime_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Timestamp>(GetArenaForAllocation());
    _impl_.expirationtime_ = p;
  }
  return _impl_.expirationtime_;
}
inline ::proto::Timestamp* CryptoGetInfoResponse_AccountInfo::mutable_expirationtime() {
  ::proto::Timestamp* _msg = _internal_mutable_expirationtime();
  // @@protoc_insertion_point(field_mutable:proto.CryptoGetInfoResponse.AccountInfo.expirationTime)
  return _msg;
}
inline void CryptoGetInfoResponse_AccountInfo::set_allocated_expirationtime(::proto::Timestamp* expirationtime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expirationtime_);
  }
  if (expirationtime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expirationtime));
    if (message_arena != submessage_arena) {
      expirationtime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expirationtime, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.expirationtime_ = expirationtime;
  // @@protoc_insertion_point(field_set_allocated:proto.CryptoGetInfoResponse.AccountInfo.expirationTime)
}

// .proto.Duration autoRenewPeriod = 13;
inline bool CryptoGetInfoResponse_AccountInfo::_internal_has_autorenewperiod() const {
  return this != internal_default_instance() && _impl_.autorenewperiod_ != nullptr;
}
inline bool CryptoGetInfoResponse_AccountInfo::has_autorenewperiod() const {
  return _internal_has_autorenewperiod();
}
inline const ::proto::Duration& CryptoGetInfoResponse_AccountInfo::_internal_autorenewperiod() const {
  const ::proto::Duration* p = _impl_.autorenewperiod_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Duration&>(
      ::proto::_Duration_default_instance_);
}
inline const ::proto::Duration& CryptoGetInfoResponse_AccountInfo::autorenewperiod() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.AccountInfo.autoRenewPeriod)
  return _internal_autorenewperiod();
}
inline void CryptoGetInfoResponse_AccountInfo::unsafe_arena_set_allocated_autorenewperiod(
    ::proto::Duration* autorenewperiod) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.autorenewperiod_);
  }
  _impl_.autorenewperiod_ = autorenewperiod;
  if (autorenewperiod) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.CryptoGetInfoResponse.AccountInfo.autoRenewPeriod)
}
inline ::proto::Duration* CryptoGetInfoResponse_AccountInfo::release_autorenewperiod() {
  
  ::proto::Duration* temp = _impl_.autorenewperiod_;
  _impl_.autorenewperiod_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Duration* CryptoGetInfoResponse_AccountInfo::unsafe_arena_release_autorenewperiod() {
  // @@protoc_insertion_point(field_release:proto.CryptoGetInfoResponse.AccountInfo.autoRenewPeriod)
  
  ::proto::Duration* temp = _impl_.autorenewperiod_;
  _impl_.autorenewperiod_ = nullptr;
  return temp;
}
inline ::proto::Duration* CryptoGetInfoResponse_AccountInfo::_internal_mutable_autorenewperiod() {
  
  if (_impl_.autorenewperiod_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Duration>(GetArenaForAllocation());
    _impl_.autorenewperiod_ = p;
  }
  return _impl_.autorenewperiod_;
}
inline ::proto::Duration* CryptoGetInfoResponse_AccountInfo::mutable_autorenewperiod() {
  ::proto::Duration* _msg = _internal_mutable_autorenewperiod();
  // @@protoc_insertion_point(field_mutable:proto.CryptoGetInfoResponse.AccountInfo.autoRenewPeriod)
  return _msg;
}
inline void CryptoGetInfoResponse_AccountInfo::set_allocated_autorenewperiod(::proto::Duration* autorenewperiod) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.autorenewperiod_);
  }
  if (autorenewperiod) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(autorenewperiod));
    if (message_arena != submessage_arena) {
      autorenewperiod = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, autorenewperiod, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.autorenewperiod_ = autorenewperiod;
  // @@protoc_insertion_point(field_set_allocated:proto.CryptoGetInfoResponse.AccountInfo.autoRenewPeriod)
}

// repeated .proto.LiveHash liveHashes = 14;
inline int CryptoGetInfoResponse_AccountInfo::_internal_livehashes_size() const {
  return _impl_.livehashes_.size();
}
inline int CryptoGetInfoResponse_AccountInfo::livehashes_size() const {
  return _internal_livehashes_size();
}
inline ::proto::LiveHash* CryptoGetInfoResponse_AccountInfo::mutable_livehashes(int index) {
  // @@protoc_insertion_point(field_mutable:proto.CryptoGetInfoResponse.AccountInfo.liveHashes)
  return _impl_.livehashes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::LiveHash >*
CryptoGetInfoResponse_AccountInfo::mutable_livehashes() {
  // @@protoc_insertion_point(field_mutable_list:proto.CryptoGetInfoResponse.AccountInfo.liveHashes)
  return &_impl_.livehashes_;
}
inline const ::proto::LiveHash& CryptoGetInfoResponse_AccountInfo::_internal_livehashes(int index) const {
  return _impl_.livehashes_.Get(index);
}
inline const ::proto::LiveHash& CryptoGetInfoResponse_AccountInfo::livehashes(int index) const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.AccountInfo.liveHashes)
  return _internal_livehashes(index);
}
inline ::proto::LiveHash* CryptoGetInfoResponse_AccountInfo::_internal_add_livehashes() {
  return _impl_.livehashes_.Add();
}
inline ::proto::LiveHash* CryptoGetInfoResponse_AccountInfo::add_livehashes() {
  ::proto::LiveHash* _add = _internal_add_livehashes();
  // @@protoc_insertion_point(field_add:proto.CryptoGetInfoResponse.AccountInfo.liveHashes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::LiveHash >&
CryptoGetInfoResponse_AccountInfo::livehashes() const {
  // @@protoc_insertion_point(field_list:proto.CryptoGetInfoResponse.AccountInfo.liveHashes)
  return _impl_.livehashes_;
}

// repeated .proto.TokenRelationship tokenRelationships = 15 [deprecated = true];
inline int CryptoGetInfoResponse_AccountInfo::_internal_tokenrelationships_size() const {
  return _impl_.tokenrelationships_.size();
}
inline int CryptoGetInfoResponse_AccountInfo::tokenrelationships_size() const {
  return _internal_tokenrelationships_size();
}
inline ::proto::TokenRelationship* CryptoGetInfoResponse_AccountInfo::mutable_tokenrelationships(int index) {
  // @@protoc_insertion_point(field_mutable:proto.CryptoGetInfoResponse.AccountInfo.tokenRelationships)
  return _impl_.tokenrelationships_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TokenRelationship >*
CryptoGetInfoResponse_AccountInfo::mutable_tokenrelationships() {
  // @@protoc_insertion_point(field_mutable_list:proto.CryptoGetInfoResponse.AccountInfo.tokenRelationships)
  return &_impl_.tokenrelationships_;
}
inline const ::proto::TokenRelationship& CryptoGetInfoResponse_AccountInfo::_internal_tokenrelationships(int index) const {
  return _impl_.tokenrelationships_.Get(index);
}
inline const ::proto::TokenRelationship& CryptoGetInfoResponse_AccountInfo::tokenrelationships(int index) const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.AccountInfo.tokenRelationships)
  return _internal_tokenrelationships(index);
}
inline ::proto::TokenRelationship* CryptoGetInfoResponse_AccountInfo::_internal_add_tokenrelationships() {
  return _impl_.tokenrelationships_.Add();
}
inline ::proto::TokenRelationship* CryptoGetInfoResponse_AccountInfo::add_tokenrelationships() {
  ::proto::TokenRelationship* _add = _internal_add_tokenrelationships();
  // @@protoc_insertion_point(field_add:proto.CryptoGetInfoResponse.AccountInfo.tokenRelationships)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TokenRelationship >&
CryptoGetInfoResponse_AccountInfo::tokenrelationships() const {
  // @@protoc_insertion_point(field_list:proto.CryptoGetInfoResponse.AccountInfo.tokenRelationships)
  return _impl_.tokenrelationships_;
}

// string memo = 16;
inline void CryptoGetInfoResponse_AccountInfo::clear_memo() {
  _impl_.memo_.ClearToEmpty();
}
inline const std::string& CryptoGetInfoResponse_AccountInfo::memo() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.AccountInfo.memo)
  return _internal_memo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CryptoGetInfoResponse_AccountInfo::set_memo(ArgT0&& arg0, ArgT... args) {
 
 _impl_.memo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.CryptoGetInfoResponse.AccountInfo.memo)
}
inline std::string* CryptoGetInfoResponse_AccountInfo::mutable_memo() {
  std::string* _s = _internal_mutable_memo();
  // @@protoc_insertion_point(field_mutable:proto.CryptoGetInfoResponse.AccountInfo.memo)
  return _s;
}
inline const std::string& CryptoGetInfoResponse_AccountInfo::_internal_memo() const {
  return _impl_.memo_.Get();
}
inline void CryptoGetInfoResponse_AccountInfo::_internal_set_memo(const std::string& value) {
  
  _impl_.memo_.Set(value, GetArenaForAllocation());
}
inline std::string* CryptoGetInfoResponse_AccountInfo::_internal_mutable_memo() {
  
  return _impl_.memo_.Mutable(GetArenaForAllocation());
}
inline std::string* CryptoGetInfoResponse_AccountInfo::release_memo() {
  // @@protoc_insertion_point(field_release:proto.CryptoGetInfoResponse.AccountInfo.memo)
  return _impl_.memo_.Release();
}
inline void CryptoGetInfoResponse_AccountInfo::set_allocated_memo(std::string* memo) {
  if (memo != nullptr) {
    
  } else {
    
  }
  _impl_.memo_.SetAllocated(memo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.memo_.IsDefault()) {
    _impl_.memo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.CryptoGetInfoResponse.AccountInfo.memo)
}

// int64 ownedNfts = 17;
inline void CryptoGetInfoResponse_AccountInfo::clear_ownednfts() {
  _impl_.ownednfts_ = int64_t{0};
}
inline int64_t CryptoGetInfoResponse_AccountInfo::_internal_ownednfts() const {
  return _impl_.ownednfts_;
}
inline int64_t CryptoGetInfoResponse_AccountInfo::ownednfts() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.AccountInfo.ownedNfts)
  return _internal_ownednfts();
}
inline void CryptoGetInfoResponse_AccountInfo::_internal_set_ownednfts(int64_t value) {
  
  _impl_.ownednfts_ = value;
}
inline void CryptoGetInfoResponse_AccountInfo::set_ownednfts(int64_t value) {
  _internal_set_ownednfts(value);
  // @@protoc_insertion_point(field_set:proto.CryptoGetInfoResponse.AccountInfo.ownedNfts)
}

// int32 max_automatic_token_associations = 18;
inline void CryptoGetInfoResponse_AccountInfo::clear_max_automatic_token_associations() {
  _impl_.max_automatic_token_associations_ = 0;
}
inline int32_t CryptoGetInfoResponse_AccountInfo::_internal_max_automatic_token_associations() const {
  return _impl_.max_automatic_token_associations_;
}
inline int32_t CryptoGetInfoResponse_AccountInfo::max_automatic_token_associations() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.AccountInfo.max_automatic_token_associations)
  return _internal_max_automatic_token_associations();
}
inline void CryptoGetInfoResponse_AccountInfo::_internal_set_max_automatic_token_associations(int32_t value) {
  
  _impl_.max_automatic_token_associations_ = value;
}
inline void CryptoGetInfoResponse_AccountInfo::set_max_automatic_token_associations(int32_t value) {
  _internal_set_max_automatic_token_associations(value);
  // @@protoc_insertion_point(field_set:proto.CryptoGetInfoResponse.AccountInfo.max_automatic_token_associations)
}

// bytes alias = 19;
inline void CryptoGetInfoResponse_AccountInfo::clear_alias() {
  _impl_.alias_.ClearToEmpty();
}
inline const std::string& CryptoGetInfoResponse_AccountInfo::alias() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.AccountInfo.alias)
  return _internal_alias();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CryptoGetInfoResponse_AccountInfo::set_alias(ArgT0&& arg0, ArgT... args) {
 
 _impl_.alias_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.CryptoGetInfoResponse.AccountInfo.alias)
}
inline std::string* CryptoGetInfoResponse_AccountInfo::mutable_alias() {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:proto.CryptoGetInfoResponse.AccountInfo.alias)
  return _s;
}
inline const std::string& CryptoGetInfoResponse_AccountInfo::_internal_alias() const {
  return _impl_.alias_.Get();
}
inline void CryptoGetInfoResponse_AccountInfo::_internal_set_alias(const std::string& value) {
  
  _impl_.alias_.Set(value, GetArenaForAllocation());
}
inline std::string* CryptoGetInfoResponse_AccountInfo::_internal_mutable_alias() {
  
  return _impl_.alias_.Mutable(GetArenaForAllocation());
}
inline std::string* CryptoGetInfoResponse_AccountInfo::release_alias() {
  // @@protoc_insertion_point(field_release:proto.CryptoGetInfoResponse.AccountInfo.alias)
  return _impl_.alias_.Release();
}
inline void CryptoGetInfoResponse_AccountInfo::set_allocated_alias(std::string* alias) {
  if (alias != nullptr) {
    
  } else {
    
  }
  _impl_.alias_.SetAllocated(alias, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.alias_.IsDefault()) {
    _impl_.alias_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.CryptoGetInfoResponse.AccountInfo.alias)
}

// bytes ledger_id = 20;
inline void CryptoGetInfoResponse_AccountInfo::clear_ledger_id() {
  _impl_.ledger_id_.ClearToEmpty();
}
inline const std::string& CryptoGetInfoResponse_AccountInfo::ledger_id() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.AccountInfo.ledger_id)
  return _internal_ledger_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CryptoGetInfoResponse_AccountInfo::set_ledger_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ledger_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.CryptoGetInfoResponse.AccountInfo.ledger_id)
}
inline std::string* CryptoGetInfoResponse_AccountInfo::mutable_ledger_id() {
  std::string* _s = _internal_mutable_ledger_id();
  // @@protoc_insertion_point(field_mutable:proto.CryptoGetInfoResponse.AccountInfo.ledger_id)
  return _s;
}
inline const std::string& CryptoGetInfoResponse_AccountInfo::_internal_ledger_id() const {
  return _impl_.ledger_id_.Get();
}
inline void CryptoGetInfoResponse_AccountInfo::_internal_set_ledger_id(const std::string& value) {
  
  _impl_.ledger_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CryptoGetInfoResponse_AccountInfo::_internal_mutable_ledger_id() {
  
  return _impl_.ledger_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CryptoGetInfoResponse_AccountInfo::release_ledger_id() {
  // @@protoc_insertion_point(field_release:proto.CryptoGetInfoResponse.AccountInfo.ledger_id)
  return _impl_.ledger_id_.Release();
}
inline void CryptoGetInfoResponse_AccountInfo::set_allocated_ledger_id(std::string* ledger_id) {
  if (ledger_id != nullptr) {
    
  } else {
    
  }
  _impl_.ledger_id_.SetAllocated(ledger_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ledger_id_.IsDefault()) {
    _impl_.ledger_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.CryptoGetInfoResponse.AccountInfo.ledger_id)
}

// int64 ethereum_nonce = 21;
inline void CryptoGetInfoResponse_AccountInfo::clear_ethereum_nonce() {
  _impl_.ethereum_nonce_ = int64_t{0};
}
inline int64_t CryptoGetInfoResponse_AccountInfo::_internal_ethereum_nonce() const {
  return _impl_.ethereum_nonce_;
}
inline int64_t CryptoGetInfoResponse_AccountInfo::ethereum_nonce() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.AccountInfo.ethereum_nonce)
  return _internal_ethereum_nonce();
}
inline void CryptoGetInfoResponse_AccountInfo::_internal_set_ethereum_nonce(int64_t value) {
  
  _impl_.ethereum_nonce_ = value;
}
inline void CryptoGetInfoResponse_AccountInfo::set_ethereum_nonce(int64_t value) {
  _internal_set_ethereum_nonce(value);
  // @@protoc_insertion_point(field_set:proto.CryptoGetInfoResponse.AccountInfo.ethereum_nonce)
}

// .proto.StakingInfo staking_info = 22;
inline bool CryptoGetInfoResponse_AccountInfo::_internal_has_staking_info() const {
  return this != internal_default_instance() && _impl_.staking_info_ != nullptr;
}
inline bool CryptoGetInfoResponse_AccountInfo::has_staking_info() const {
  return _internal_has_staking_info();
}
inline const ::proto::StakingInfo& CryptoGetInfoResponse_AccountInfo::_internal_staking_info() const {
  const ::proto::StakingInfo* p = _impl_.staking_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::StakingInfo&>(
      ::proto::_StakingInfo_default_instance_);
}
inline const ::proto::StakingInfo& CryptoGetInfoResponse_AccountInfo::staking_info() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.AccountInfo.staking_info)
  return _internal_staking_info();
}
inline void CryptoGetInfoResponse_AccountInfo::unsafe_arena_set_allocated_staking_info(
    ::proto::StakingInfo* staking_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.staking_info_);
  }
  _impl_.staking_info_ = staking_info;
  if (staking_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.CryptoGetInfoResponse.AccountInfo.staking_info)
}
inline ::proto::StakingInfo* CryptoGetInfoResponse_AccountInfo::release_staking_info() {
  
  ::proto::StakingInfo* temp = _impl_.staking_info_;
  _impl_.staking_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::StakingInfo* CryptoGetInfoResponse_AccountInfo::unsafe_arena_release_staking_info() {
  // @@protoc_insertion_point(field_release:proto.CryptoGetInfoResponse.AccountInfo.staking_info)
  
  ::proto::StakingInfo* temp = _impl_.staking_info_;
  _impl_.staking_info_ = nullptr;
  return temp;
}
inline ::proto::StakingInfo* CryptoGetInfoResponse_AccountInfo::_internal_mutable_staking_info() {
  
  if (_impl_.staking_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::StakingInfo>(GetArenaForAllocation());
    _impl_.staking_info_ = p;
  }
  return _impl_.staking_info_;
}
inline ::proto::StakingInfo* CryptoGetInfoResponse_AccountInfo::mutable_staking_info() {
  ::proto::StakingInfo* _msg = _internal_mutable_staking_info();
  // @@protoc_insertion_point(field_mutable:proto.CryptoGetInfoResponse.AccountInfo.staking_info)
  return _msg;
}
inline void CryptoGetInfoResponse_AccountInfo::set_allocated_staking_info(::proto::StakingInfo* staking_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.staking_info_);
  }
  if (staking_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(staking_info));
    if (message_arena != submessage_arena) {
      staking_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, staking_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.staking_info_ = staking_info;
  // @@protoc_insertion_point(field_set_allocated:proto.CryptoGetInfoResponse.AccountInfo.staking_info)
}

// -------------------------------------------------------------------

// CryptoGetInfoResponse

// .proto.ResponseHeader header = 1;
inline bool CryptoGetInfoResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool CryptoGetInfoResponse::has_header() const {
  return _internal_has_header();
}
inline const ::proto::ResponseHeader& CryptoGetInfoResponse::_internal_header() const {
  const ::proto::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ResponseHeader&>(
      ::proto::_ResponseHeader_default_instance_);
}
inline const ::proto::ResponseHeader& CryptoGetInfoResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.header)
  return _internal_header();
}
inline void CryptoGetInfoResponse::unsafe_arena_set_allocated_header(
    ::proto::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.CryptoGetInfoResponse.header)
}
inline ::proto::ResponseHeader* CryptoGetInfoResponse::release_header() {
  
  ::proto::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ResponseHeader* CryptoGetInfoResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:proto.CryptoGetInfoResponse.header)
  
  ::proto::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::proto::ResponseHeader* CryptoGetInfoResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::proto::ResponseHeader* CryptoGetInfoResponse::mutable_header() {
  ::proto::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:proto.CryptoGetInfoResponse.header)
  return _msg;
}
inline void CryptoGetInfoResponse::set_allocated_header(::proto::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:proto.CryptoGetInfoResponse.header)
}

// .proto.CryptoGetInfoResponse.AccountInfo accountInfo = 2;
inline bool CryptoGetInfoResponse::_internal_has_accountinfo() const {
  return this != internal_default_instance() && _impl_.accountinfo_ != nullptr;
}
inline bool CryptoGetInfoResponse::has_accountinfo() const {
  return _internal_has_accountinfo();
}
inline void CryptoGetInfoResponse::clear_accountinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.accountinfo_ != nullptr) {
    delete _impl_.accountinfo_;
  }
  _impl_.accountinfo_ = nullptr;
}
inline const ::proto::CryptoGetInfoResponse_AccountInfo& CryptoGetInfoResponse::_internal_accountinfo() const {
  const ::proto::CryptoGetInfoResponse_AccountInfo* p = _impl_.accountinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::CryptoGetInfoResponse_AccountInfo&>(
      ::proto::_CryptoGetInfoResponse_AccountInfo_default_instance_);
}
inline const ::proto::CryptoGetInfoResponse_AccountInfo& CryptoGetInfoResponse::accountinfo() const {
  // @@protoc_insertion_point(field_get:proto.CryptoGetInfoResponse.accountInfo)
  return _internal_accountinfo();
}
inline void CryptoGetInfoResponse::unsafe_arena_set_allocated_accountinfo(
    ::proto::CryptoGetInfoResponse_AccountInfo* accountinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.accountinfo_);
  }
  _impl_.accountinfo_ = accountinfo;
  if (accountinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.CryptoGetInfoResponse.accountInfo)
}
inline ::proto::CryptoGetInfoResponse_AccountInfo* CryptoGetInfoResponse::release_accountinfo() {
  
  ::proto::CryptoGetInfoResponse_AccountInfo* temp = _impl_.accountinfo_;
  _impl_.accountinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::CryptoGetInfoResponse_AccountInfo* CryptoGetInfoResponse::unsafe_arena_release_accountinfo() {
  // @@protoc_insertion_point(field_release:proto.CryptoGetInfoResponse.accountInfo)
  
  ::proto::CryptoGetInfoResponse_AccountInfo* temp = _impl_.accountinfo_;
  _impl_.accountinfo_ = nullptr;
  return temp;
}
inline ::proto::CryptoGetInfoResponse_AccountInfo* CryptoGetInfoResponse::_internal_mutable_accountinfo() {
  
  if (_impl_.accountinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::CryptoGetInfoResponse_AccountInfo>(GetArenaForAllocation());
    _impl_.accountinfo_ = p;
  }
  return _impl_.accountinfo_;
}
inline ::proto::CryptoGetInfoResponse_AccountInfo* CryptoGetInfoResponse::mutable_accountinfo() {
  ::proto::CryptoGetInfoResponse_AccountInfo* _msg = _internal_mutable_accountinfo();
  // @@protoc_insertion_point(field_mutable:proto.CryptoGetInfoResponse.accountInfo)
  return _msg;
}
inline void CryptoGetInfoResponse::set_allocated_accountinfo(::proto::CryptoGetInfoResponse_AccountInfo* accountinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.accountinfo_;
  }
  if (accountinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(accountinfo);
    if (message_arena != submessage_arena) {
      accountinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, accountinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.accountinfo_ = accountinfo;
  // @@protoc_insertion_point(field_set_allocated:proto.CryptoGetInfoResponse.accountInfo)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_crypto_5fget_5finfo_2eproto
