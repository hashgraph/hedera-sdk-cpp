// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: contract_call_local.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_contract_5fcall_5flocal_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_contract_5fcall_5flocal_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "basic_types.pb.h"
#include "query_header.pb.h"
#include "response_header.pb.h"
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_contract_5fcall_5flocal_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_contract_5fcall_5flocal_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_contract_5fcall_5flocal_2eproto;
namespace proto {
class ContractCallLocalQuery;
struct ContractCallLocalQueryDefaultTypeInternal;
extern ContractCallLocalQueryDefaultTypeInternal _ContractCallLocalQuery_default_instance_;
class ContractCallLocalResponse;
struct ContractCallLocalResponseDefaultTypeInternal;
extern ContractCallLocalResponseDefaultTypeInternal _ContractCallLocalResponse_default_instance_;
class ContractFunctionResult;
struct ContractFunctionResultDefaultTypeInternal;
extern ContractFunctionResultDefaultTypeInternal _ContractFunctionResult_default_instance_;
class ContractLoginfo;
struct ContractLoginfoDefaultTypeInternal;
extern ContractLoginfoDefaultTypeInternal _ContractLoginfo_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::ContractCallLocalQuery* Arena::CreateMaybeMessage<::proto::ContractCallLocalQuery>(Arena*);
template<> ::proto::ContractCallLocalResponse* Arena::CreateMaybeMessage<::proto::ContractCallLocalResponse>(Arena*);
template<> ::proto::ContractFunctionResult* Arena::CreateMaybeMessage<::proto::ContractFunctionResult>(Arena*);
template<> ::proto::ContractLoginfo* Arena::CreateMaybeMessage<::proto::ContractLoginfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

// ===================================================================

class ContractLoginfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ContractLoginfo) */ {
 public:
  inline ContractLoginfo() : ContractLoginfo(nullptr) {}
  ~ContractLoginfo() override;
  explicit PROTOBUF_CONSTEXPR ContractLoginfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractLoginfo(const ContractLoginfo& from);
  ContractLoginfo(ContractLoginfo&& from) noexcept
    : ContractLoginfo() {
    *this = ::std::move(from);
  }

  inline ContractLoginfo& operator=(const ContractLoginfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractLoginfo& operator=(ContractLoginfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractLoginfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractLoginfo* internal_default_instance() {
    return reinterpret_cast<const ContractLoginfo*>(
               &_ContractLoginfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ContractLoginfo& a, ContractLoginfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractLoginfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractLoginfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractLoginfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractLoginfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractLoginfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContractLoginfo& from) {
    ContractLoginfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractLoginfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ContractLoginfo";
  }
  protected:
  explicit ContractLoginfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 3,
    kBloomFieldNumber = 2,
    kDataFieldNumber = 4,
    kContractIDFieldNumber = 1,
  };
  // repeated bytes topic = 3;
  int topic_size() const;
  private:
  int _internal_topic_size() const;
  public:
  void clear_topic();
  const std::string& topic(int index) const;
  std::string* mutable_topic(int index);
  void set_topic(int index, const std::string& value);
  void set_topic(int index, std::string&& value);
  void set_topic(int index, const char* value);
  void set_topic(int index, const void* value, size_t size);
  std::string* add_topic();
  void add_topic(const std::string& value);
  void add_topic(std::string&& value);
  void add_topic(const char* value);
  void add_topic(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& topic() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_topic();
  private:
  const std::string& _internal_topic(int index) const;
  std::string* _internal_add_topic();
  public:

  // bytes bloom = 2;
  void clear_bloom();
  const std::string& bloom() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bloom(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bloom();
  PROTOBUF_NODISCARD std::string* release_bloom();
  void set_allocated_bloom(std::string* bloom);
  private:
  const std::string& _internal_bloom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bloom(const std::string& value);
  std::string* _internal_mutable_bloom();
  public:

  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .proto.ContractID contractID = 1;
  bool has_contractid() const;
  private:
  bool _internal_has_contractid() const;
  public:
  void clear_contractid();
  const ::proto::ContractID& contractid() const;
  PROTOBUF_NODISCARD ::proto::ContractID* release_contractid();
  ::proto::ContractID* mutable_contractid();
  void set_allocated_contractid(::proto::ContractID* contractid);
  private:
  const ::proto::ContractID& _internal_contractid() const;
  ::proto::ContractID* _internal_mutable_contractid();
  public:
  void unsafe_arena_set_allocated_contractid(
      ::proto::ContractID* contractid);
  ::proto::ContractID* unsafe_arena_release_contractid();

  // @@protoc_insertion_point(class_scope:proto.ContractLoginfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> topic_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bloom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::proto::ContractID* contractid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_contract_5fcall_5flocal_2eproto;
};
// -------------------------------------------------------------------

class ContractFunctionResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ContractFunctionResult) */ {
 public:
  inline ContractFunctionResult() : ContractFunctionResult(nullptr) {}
  ~ContractFunctionResult() override;
  explicit PROTOBUF_CONSTEXPR ContractFunctionResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractFunctionResult(const ContractFunctionResult& from);
  ContractFunctionResult(ContractFunctionResult&& from) noexcept
    : ContractFunctionResult() {
    *this = ::std::move(from);
  }

  inline ContractFunctionResult& operator=(const ContractFunctionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractFunctionResult& operator=(ContractFunctionResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractFunctionResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractFunctionResult* internal_default_instance() {
    return reinterpret_cast<const ContractFunctionResult*>(
               &_ContractFunctionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ContractFunctionResult& a, ContractFunctionResult& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractFunctionResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractFunctionResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractFunctionResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractFunctionResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractFunctionResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContractFunctionResult& from) {
    ContractFunctionResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractFunctionResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ContractFunctionResult";
  }
  protected:
  explicit ContractFunctionResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogInfoFieldNumber = 6,
    kCreatedContractIDsFieldNumber = 7,
    kContractCallResultFieldNumber = 2,
    kErrorMessageFieldNumber = 3,
    kBloomFieldNumber = 4,
    kFunctionParametersFieldNumber = 12,
    kContractIDFieldNumber = 1,
    kEvmAddressFieldNumber = 9,
    kSenderIdFieldNumber = 13,
    kGasUsedFieldNumber = 5,
    kGasFieldNumber = 10,
    kAmountFieldNumber = 11,
  };
  // repeated .proto.ContractLoginfo logInfo = 6;
  int loginfo_size() const;
  private:
  int _internal_loginfo_size() const;
  public:
  void clear_loginfo();
  ::proto::ContractLoginfo* mutable_loginfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ContractLoginfo >*
      mutable_loginfo();
  private:
  const ::proto::ContractLoginfo& _internal_loginfo(int index) const;
  ::proto::ContractLoginfo* _internal_add_loginfo();
  public:
  const ::proto::ContractLoginfo& loginfo(int index) const;
  ::proto::ContractLoginfo* add_loginfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ContractLoginfo >&
      loginfo() const;

  // repeated .proto.ContractID createdContractIDs = 7 [deprecated = true];
  PROTOBUF_DEPRECATED int createdcontractids_size() const;
  private:
  int _internal_createdcontractids_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_createdcontractids();
  PROTOBUF_DEPRECATED ::proto::ContractID* mutable_createdcontractids(int index);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ContractID >*
      mutable_createdcontractids();
  private:
  const ::proto::ContractID& _internal_createdcontractids(int index) const;
  ::proto::ContractID* _internal_add_createdcontractids();
  public:
  PROTOBUF_DEPRECATED const ::proto::ContractID& createdcontractids(int index) const;
  PROTOBUF_DEPRECATED ::proto::ContractID* add_createdcontractids();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ContractID >&
      createdcontractids() const;

  // bytes contractCallResult = 2;
  void clear_contractcallresult();
  const std::string& contractcallresult() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contractcallresult(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contractcallresult();
  PROTOBUF_NODISCARD std::string* release_contractcallresult();
  void set_allocated_contractcallresult(std::string* contractcallresult);
  private:
  const std::string& _internal_contractcallresult() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contractcallresult(const std::string& value);
  std::string* _internal_mutable_contractcallresult();
  public:

  // string errorMessage = 3;
  void clear_errormessage();
  const std::string& errormessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormessage();
  PROTOBUF_NODISCARD std::string* release_errormessage();
  void set_allocated_errormessage(std::string* errormessage);
  private:
  const std::string& _internal_errormessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormessage(const std::string& value);
  std::string* _internal_mutable_errormessage();
  public:

  // bytes bloom = 4;
  void clear_bloom();
  const std::string& bloom() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bloom(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bloom();
  PROTOBUF_NODISCARD std::string* release_bloom();
  void set_allocated_bloom(std::string* bloom);
  private:
  const std::string& _internal_bloom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bloom(const std::string& value);
  std::string* _internal_mutable_bloom();
  public:

  // bytes functionParameters = 12;
  void clear_functionparameters();
  const std::string& functionparameters() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_functionparameters(ArgT0&& arg0, ArgT... args);
  std::string* mutable_functionparameters();
  PROTOBUF_NODISCARD std::string* release_functionparameters();
  void set_allocated_functionparameters(std::string* functionparameters);
  private:
  const std::string& _internal_functionparameters() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_functionparameters(const std::string& value);
  std::string* _internal_mutable_functionparameters();
  public:

  // .proto.ContractID contractID = 1;
  bool has_contractid() const;
  private:
  bool _internal_has_contractid() const;
  public:
  void clear_contractid();
  const ::proto::ContractID& contractid() const;
  PROTOBUF_NODISCARD ::proto::ContractID* release_contractid();
  ::proto::ContractID* mutable_contractid();
  void set_allocated_contractid(::proto::ContractID* contractid);
  private:
  const ::proto::ContractID& _internal_contractid() const;
  ::proto::ContractID* _internal_mutable_contractid();
  public:
  void unsafe_arena_set_allocated_contractid(
      ::proto::ContractID* contractid);
  ::proto::ContractID* unsafe_arena_release_contractid();

  // .google.protobuf.BytesValue evm_address = 9;
  bool has_evm_address() const;
  private:
  bool _internal_has_evm_address() const;
  public:
  void clear_evm_address();
  const ::PROTOBUF_NAMESPACE_ID::BytesValue& evm_address() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BytesValue* release_evm_address();
  ::PROTOBUF_NAMESPACE_ID::BytesValue* mutable_evm_address();
  void set_allocated_evm_address(::PROTOBUF_NAMESPACE_ID::BytesValue* evm_address);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BytesValue& _internal_evm_address() const;
  ::PROTOBUF_NAMESPACE_ID::BytesValue* _internal_mutable_evm_address();
  public:
  void unsafe_arena_set_allocated_evm_address(
      ::PROTOBUF_NAMESPACE_ID::BytesValue* evm_address);
  ::PROTOBUF_NAMESPACE_ID::BytesValue* unsafe_arena_release_evm_address();

  // .proto.AccountID sender_id = 13;
  bool has_sender_id() const;
  private:
  bool _internal_has_sender_id() const;
  public:
  void clear_sender_id();
  const ::proto::AccountID& sender_id() const;
  PROTOBUF_NODISCARD ::proto::AccountID* release_sender_id();
  ::proto::AccountID* mutable_sender_id();
  void set_allocated_sender_id(::proto::AccountID* sender_id);
  private:
  const ::proto::AccountID& _internal_sender_id() const;
  ::proto::AccountID* _internal_mutable_sender_id();
  public:
  void unsafe_arena_set_allocated_sender_id(
      ::proto::AccountID* sender_id);
  ::proto::AccountID* unsafe_arena_release_sender_id();

  // uint64 gasUsed = 5;
  void clear_gasused();
  uint64_t gasused() const;
  void set_gasused(uint64_t value);
  private:
  uint64_t _internal_gasused() const;
  void _internal_set_gasused(uint64_t value);
  public:

  // int64 gas = 10;
  void clear_gas();
  int64_t gas() const;
  void set_gas(int64_t value);
  private:
  int64_t _internal_gas() const;
  void _internal_set_gas(int64_t value);
  public:

  // int64 amount = 11;
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ContractFunctionResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ContractLoginfo > loginfo_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ContractID > createdcontractids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contractcallresult_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormessage_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bloom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr functionparameters_;
    ::proto::ContractID* contractid_;
    ::PROTOBUF_NAMESPACE_ID::BytesValue* evm_address_;
    ::proto::AccountID* sender_id_;
    uint64_t gasused_;
    int64_t gas_;
    int64_t amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_contract_5fcall_5flocal_2eproto;
};
// -------------------------------------------------------------------

class ContractCallLocalQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ContractCallLocalQuery) */ {
 public:
  inline ContractCallLocalQuery() : ContractCallLocalQuery(nullptr) {}
  ~ContractCallLocalQuery() override;
  explicit PROTOBUF_CONSTEXPR ContractCallLocalQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractCallLocalQuery(const ContractCallLocalQuery& from);
  ContractCallLocalQuery(ContractCallLocalQuery&& from) noexcept
    : ContractCallLocalQuery() {
    *this = ::std::move(from);
  }

  inline ContractCallLocalQuery& operator=(const ContractCallLocalQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractCallLocalQuery& operator=(ContractCallLocalQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractCallLocalQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractCallLocalQuery* internal_default_instance() {
    return reinterpret_cast<const ContractCallLocalQuery*>(
               &_ContractCallLocalQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ContractCallLocalQuery& a, ContractCallLocalQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractCallLocalQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractCallLocalQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractCallLocalQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractCallLocalQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractCallLocalQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContractCallLocalQuery& from) {
    ContractCallLocalQuery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractCallLocalQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ContractCallLocalQuery";
  }
  protected:
  explicit ContractCallLocalQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFunctionParametersFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kContractIDFieldNumber = 2,
    kSenderIdFieldNumber = 6,
    kGasFieldNumber = 3,
    kMaxResultSizeFieldNumber = 5,
  };
  // bytes functionParameters = 4;
  void clear_functionparameters();
  const std::string& functionparameters() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_functionparameters(ArgT0&& arg0, ArgT... args);
  std::string* mutable_functionparameters();
  PROTOBUF_NODISCARD std::string* release_functionparameters();
  void set_allocated_functionparameters(std::string* functionparameters);
  private:
  const std::string& _internal_functionparameters() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_functionparameters(const std::string& value);
  std::string* _internal_mutable_functionparameters();
  public:

  // .proto.QueryHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::proto::QueryHeader& header() const;
  PROTOBUF_NODISCARD ::proto::QueryHeader* release_header();
  ::proto::QueryHeader* mutable_header();
  void set_allocated_header(::proto::QueryHeader* header);
  private:
  const ::proto::QueryHeader& _internal_header() const;
  ::proto::QueryHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::proto::QueryHeader* header);
  ::proto::QueryHeader* unsafe_arena_release_header();

  // .proto.ContractID contractID = 2;
  bool has_contractid() const;
  private:
  bool _internal_has_contractid() const;
  public:
  void clear_contractid();
  const ::proto::ContractID& contractid() const;
  PROTOBUF_NODISCARD ::proto::ContractID* release_contractid();
  ::proto::ContractID* mutable_contractid();
  void set_allocated_contractid(::proto::ContractID* contractid);
  private:
  const ::proto::ContractID& _internal_contractid() const;
  ::proto::ContractID* _internal_mutable_contractid();
  public:
  void unsafe_arena_set_allocated_contractid(
      ::proto::ContractID* contractid);
  ::proto::ContractID* unsafe_arena_release_contractid();

  // .proto.AccountID sender_id = 6;
  bool has_sender_id() const;
  private:
  bool _internal_has_sender_id() const;
  public:
  void clear_sender_id();
  const ::proto::AccountID& sender_id() const;
  PROTOBUF_NODISCARD ::proto::AccountID* release_sender_id();
  ::proto::AccountID* mutable_sender_id();
  void set_allocated_sender_id(::proto::AccountID* sender_id);
  private:
  const ::proto::AccountID& _internal_sender_id() const;
  ::proto::AccountID* _internal_mutable_sender_id();
  public:
  void unsafe_arena_set_allocated_sender_id(
      ::proto::AccountID* sender_id);
  ::proto::AccountID* unsafe_arena_release_sender_id();

  // int64 gas = 3;
  void clear_gas();
  int64_t gas() const;
  void set_gas(int64_t value);
  private:
  int64_t _internal_gas() const;
  void _internal_set_gas(int64_t value);
  public:

  // int64 maxResultSize = 5 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_maxresultsize();
  PROTOBUF_DEPRECATED int64_t maxresultsize() const;
  PROTOBUF_DEPRECATED void set_maxresultsize(int64_t value);
  private:
  int64_t _internal_maxresultsize() const;
  void _internal_set_maxresultsize(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ContractCallLocalQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr functionparameters_;
    ::proto::QueryHeader* header_;
    ::proto::ContractID* contractid_;
    ::proto::AccountID* sender_id_;
    int64_t gas_;
    int64_t maxresultsize_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_contract_5fcall_5flocal_2eproto;
};
// -------------------------------------------------------------------

class ContractCallLocalResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ContractCallLocalResponse) */ {
 public:
  inline ContractCallLocalResponse() : ContractCallLocalResponse(nullptr) {}
  ~ContractCallLocalResponse() override;
  explicit PROTOBUF_CONSTEXPR ContractCallLocalResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractCallLocalResponse(const ContractCallLocalResponse& from);
  ContractCallLocalResponse(ContractCallLocalResponse&& from) noexcept
    : ContractCallLocalResponse() {
    *this = ::std::move(from);
  }

  inline ContractCallLocalResponse& operator=(const ContractCallLocalResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractCallLocalResponse& operator=(ContractCallLocalResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractCallLocalResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractCallLocalResponse* internal_default_instance() {
    return reinterpret_cast<const ContractCallLocalResponse*>(
               &_ContractCallLocalResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ContractCallLocalResponse& a, ContractCallLocalResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractCallLocalResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractCallLocalResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractCallLocalResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractCallLocalResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractCallLocalResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContractCallLocalResponse& from) {
    ContractCallLocalResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractCallLocalResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ContractCallLocalResponse";
  }
  protected:
  explicit ContractCallLocalResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kFunctionResultFieldNumber = 2,
  };
  // .proto.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::proto::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::proto::ResponseHeader* release_header();
  ::proto::ResponseHeader* mutable_header();
  void set_allocated_header(::proto::ResponseHeader* header);
  private:
  const ::proto::ResponseHeader& _internal_header() const;
  ::proto::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::proto::ResponseHeader* header);
  ::proto::ResponseHeader* unsafe_arena_release_header();

  // .proto.ContractFunctionResult functionResult = 2;
  bool has_functionresult() const;
  private:
  bool _internal_has_functionresult() const;
  public:
  void clear_functionresult();
  const ::proto::ContractFunctionResult& functionresult() const;
  PROTOBUF_NODISCARD ::proto::ContractFunctionResult* release_functionresult();
  ::proto::ContractFunctionResult* mutable_functionresult();
  void set_allocated_functionresult(::proto::ContractFunctionResult* functionresult);
  private:
  const ::proto::ContractFunctionResult& _internal_functionresult() const;
  ::proto::ContractFunctionResult* _internal_mutable_functionresult();
  public:
  void unsafe_arena_set_allocated_functionresult(
      ::proto::ContractFunctionResult* functionresult);
  ::proto::ContractFunctionResult* unsafe_arena_release_functionresult();

  // @@protoc_insertion_point(class_scope:proto.ContractCallLocalResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::ResponseHeader* header_;
    ::proto::ContractFunctionResult* functionresult_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_contract_5fcall_5flocal_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ContractLoginfo

// .proto.ContractID contractID = 1;
inline bool ContractLoginfo::_internal_has_contractid() const {
  return this != internal_default_instance() && _impl_.contractid_ != nullptr;
}
inline bool ContractLoginfo::has_contractid() const {
  return _internal_has_contractid();
}
inline const ::proto::ContractID& ContractLoginfo::_internal_contractid() const {
  const ::proto::ContractID* p = _impl_.contractid_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContractID&>(
      ::proto::_ContractID_default_instance_);
}
inline const ::proto::ContractID& ContractLoginfo::contractid() const {
  // @@protoc_insertion_point(field_get:proto.ContractLoginfo.contractID)
  return _internal_contractid();
}
inline void ContractLoginfo::unsafe_arena_set_allocated_contractid(
    ::proto::ContractID* contractid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contractid_);
  }
  _impl_.contractid_ = contractid;
  if (contractid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ContractLoginfo.contractID)
}
inline ::proto::ContractID* ContractLoginfo::release_contractid() {
  
  ::proto::ContractID* temp = _impl_.contractid_;
  _impl_.contractid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContractID* ContractLoginfo::unsafe_arena_release_contractid() {
  // @@protoc_insertion_point(field_release:proto.ContractLoginfo.contractID)
  
  ::proto::ContractID* temp = _impl_.contractid_;
  _impl_.contractid_ = nullptr;
  return temp;
}
inline ::proto::ContractID* ContractLoginfo::_internal_mutable_contractid() {
  
  if (_impl_.contractid_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContractID>(GetArenaForAllocation());
    _impl_.contractid_ = p;
  }
  return _impl_.contractid_;
}
inline ::proto::ContractID* ContractLoginfo::mutable_contractid() {
  ::proto::ContractID* _msg = _internal_mutable_contractid();
  // @@protoc_insertion_point(field_mutable:proto.ContractLoginfo.contractID)
  return _msg;
}
inline void ContractLoginfo::set_allocated_contractid(::proto::ContractID* contractid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contractid_);
  }
  if (contractid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contractid));
    if (message_arena != submessage_arena) {
      contractid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contractid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.contractid_ = contractid;
  // @@protoc_insertion_point(field_set_allocated:proto.ContractLoginfo.contractID)
}

// bytes bloom = 2;
inline void ContractLoginfo::clear_bloom() {
  _impl_.bloom_.ClearToEmpty();
}
inline const std::string& ContractLoginfo::bloom() const {
  // @@protoc_insertion_point(field_get:proto.ContractLoginfo.bloom)
  return _internal_bloom();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractLoginfo::set_bloom(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bloom_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ContractLoginfo.bloom)
}
inline std::string* ContractLoginfo::mutable_bloom() {
  std::string* _s = _internal_mutable_bloom();
  // @@protoc_insertion_point(field_mutable:proto.ContractLoginfo.bloom)
  return _s;
}
inline const std::string& ContractLoginfo::_internal_bloom() const {
  return _impl_.bloom_.Get();
}
inline void ContractLoginfo::_internal_set_bloom(const std::string& value) {
  
  _impl_.bloom_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractLoginfo::_internal_mutable_bloom() {
  
  return _impl_.bloom_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractLoginfo::release_bloom() {
  // @@protoc_insertion_point(field_release:proto.ContractLoginfo.bloom)
  return _impl_.bloom_.Release();
}
inline void ContractLoginfo::set_allocated_bloom(std::string* bloom) {
  if (bloom != nullptr) {
    
  } else {
    
  }
  _impl_.bloom_.SetAllocated(bloom, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bloom_.IsDefault()) {
    _impl_.bloom_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ContractLoginfo.bloom)
}

// repeated bytes topic = 3;
inline int ContractLoginfo::_internal_topic_size() const {
  return _impl_.topic_.size();
}
inline int ContractLoginfo::topic_size() const {
  return _internal_topic_size();
}
inline void ContractLoginfo::clear_topic() {
  _impl_.topic_.Clear();
}
inline std::string* ContractLoginfo::add_topic() {
  std::string* _s = _internal_add_topic();
  // @@protoc_insertion_point(field_add_mutable:proto.ContractLoginfo.topic)
  return _s;
}
inline const std::string& ContractLoginfo::_internal_topic(int index) const {
  return _impl_.topic_.Get(index);
}
inline const std::string& ContractLoginfo::topic(int index) const {
  // @@protoc_insertion_point(field_get:proto.ContractLoginfo.topic)
  return _internal_topic(index);
}
inline std::string* ContractLoginfo::mutable_topic(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ContractLoginfo.topic)
  return _impl_.topic_.Mutable(index);
}
inline void ContractLoginfo::set_topic(int index, const std::string& value) {
  _impl_.topic_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:proto.ContractLoginfo.topic)
}
inline void ContractLoginfo::set_topic(int index, std::string&& value) {
  _impl_.topic_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:proto.ContractLoginfo.topic)
}
inline void ContractLoginfo::set_topic(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.topic_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.ContractLoginfo.topic)
}
inline void ContractLoginfo::set_topic(int index, const void* value, size_t size) {
  _impl_.topic_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.ContractLoginfo.topic)
}
inline std::string* ContractLoginfo::_internal_add_topic() {
  return _impl_.topic_.Add();
}
inline void ContractLoginfo::add_topic(const std::string& value) {
  _impl_.topic_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.ContractLoginfo.topic)
}
inline void ContractLoginfo::add_topic(std::string&& value) {
  _impl_.topic_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.ContractLoginfo.topic)
}
inline void ContractLoginfo::add_topic(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.topic_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.ContractLoginfo.topic)
}
inline void ContractLoginfo::add_topic(const void* value, size_t size) {
  _impl_.topic_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.ContractLoginfo.topic)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ContractLoginfo::topic() const {
  // @@protoc_insertion_point(field_list:proto.ContractLoginfo.topic)
  return _impl_.topic_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ContractLoginfo::mutable_topic() {
  // @@protoc_insertion_point(field_mutable_list:proto.ContractLoginfo.topic)
  return &_impl_.topic_;
}

// bytes data = 4;
inline void ContractLoginfo::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& ContractLoginfo::data() const {
  // @@protoc_insertion_point(field_get:proto.ContractLoginfo.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractLoginfo::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ContractLoginfo.data)
}
inline std::string* ContractLoginfo::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:proto.ContractLoginfo.data)
  return _s;
}
inline const std::string& ContractLoginfo::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ContractLoginfo::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractLoginfo::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractLoginfo::release_data() {
  // @@protoc_insertion_point(field_release:proto.ContractLoginfo.data)
  return _impl_.data_.Release();
}
inline void ContractLoginfo::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ContractLoginfo.data)
}

// -------------------------------------------------------------------

// ContractFunctionResult

// .proto.ContractID contractID = 1;
inline bool ContractFunctionResult::_internal_has_contractid() const {
  return this != internal_default_instance() && _impl_.contractid_ != nullptr;
}
inline bool ContractFunctionResult::has_contractid() const {
  return _internal_has_contractid();
}
inline const ::proto::ContractID& ContractFunctionResult::_internal_contractid() const {
  const ::proto::ContractID* p = _impl_.contractid_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContractID&>(
      ::proto::_ContractID_default_instance_);
}
inline const ::proto::ContractID& ContractFunctionResult::contractid() const {
  // @@protoc_insertion_point(field_get:proto.ContractFunctionResult.contractID)
  return _internal_contractid();
}
inline void ContractFunctionResult::unsafe_arena_set_allocated_contractid(
    ::proto::ContractID* contractid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contractid_);
  }
  _impl_.contractid_ = contractid;
  if (contractid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ContractFunctionResult.contractID)
}
inline ::proto::ContractID* ContractFunctionResult::release_contractid() {
  
  ::proto::ContractID* temp = _impl_.contractid_;
  _impl_.contractid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContractID* ContractFunctionResult::unsafe_arena_release_contractid() {
  // @@protoc_insertion_point(field_release:proto.ContractFunctionResult.contractID)
  
  ::proto::ContractID* temp = _impl_.contractid_;
  _impl_.contractid_ = nullptr;
  return temp;
}
inline ::proto::ContractID* ContractFunctionResult::_internal_mutable_contractid() {
  
  if (_impl_.contractid_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContractID>(GetArenaForAllocation());
    _impl_.contractid_ = p;
  }
  return _impl_.contractid_;
}
inline ::proto::ContractID* ContractFunctionResult::mutable_contractid() {
  ::proto::ContractID* _msg = _internal_mutable_contractid();
  // @@protoc_insertion_point(field_mutable:proto.ContractFunctionResult.contractID)
  return _msg;
}
inline void ContractFunctionResult::set_allocated_contractid(::proto::ContractID* contractid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contractid_);
  }
  if (contractid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contractid));
    if (message_arena != submessage_arena) {
      contractid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contractid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.contractid_ = contractid;
  // @@protoc_insertion_point(field_set_allocated:proto.ContractFunctionResult.contractID)
}

// bytes contractCallResult = 2;
inline void ContractFunctionResult::clear_contractcallresult() {
  _impl_.contractcallresult_.ClearToEmpty();
}
inline const std::string& ContractFunctionResult::contractcallresult() const {
  // @@protoc_insertion_point(field_get:proto.ContractFunctionResult.contractCallResult)
  return _internal_contractcallresult();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractFunctionResult::set_contractcallresult(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contractcallresult_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ContractFunctionResult.contractCallResult)
}
inline std::string* ContractFunctionResult::mutable_contractcallresult() {
  std::string* _s = _internal_mutable_contractcallresult();
  // @@protoc_insertion_point(field_mutable:proto.ContractFunctionResult.contractCallResult)
  return _s;
}
inline const std::string& ContractFunctionResult::_internal_contractcallresult() const {
  return _impl_.contractcallresult_.Get();
}
inline void ContractFunctionResult::_internal_set_contractcallresult(const std::string& value) {
  
  _impl_.contractcallresult_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractFunctionResult::_internal_mutable_contractcallresult() {
  
  return _impl_.contractcallresult_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractFunctionResult::release_contractcallresult() {
  // @@protoc_insertion_point(field_release:proto.ContractFunctionResult.contractCallResult)
  return _impl_.contractcallresult_.Release();
}
inline void ContractFunctionResult::set_allocated_contractcallresult(std::string* contractcallresult) {
  if (contractcallresult != nullptr) {
    
  } else {
    
  }
  _impl_.contractcallresult_.SetAllocated(contractcallresult, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contractcallresult_.IsDefault()) {
    _impl_.contractcallresult_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ContractFunctionResult.contractCallResult)
}

// string errorMessage = 3;
inline void ContractFunctionResult::clear_errormessage() {
  _impl_.errormessage_.ClearToEmpty();
}
inline const std::string& ContractFunctionResult::errormessage() const {
  // @@protoc_insertion_point(field_get:proto.ContractFunctionResult.errorMessage)
  return _internal_errormessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractFunctionResult::set_errormessage(ArgT0&& arg0, ArgT... args) {
 
 _impl_.errormessage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ContractFunctionResult.errorMessage)
}
inline std::string* ContractFunctionResult::mutable_errormessage() {
  std::string* _s = _internal_mutable_errormessage();
  // @@protoc_insertion_point(field_mutable:proto.ContractFunctionResult.errorMessage)
  return _s;
}
inline const std::string& ContractFunctionResult::_internal_errormessage() const {
  return _impl_.errormessage_.Get();
}
inline void ContractFunctionResult::_internal_set_errormessage(const std::string& value) {
  
  _impl_.errormessage_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractFunctionResult::_internal_mutable_errormessage() {
  
  return _impl_.errormessage_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractFunctionResult::release_errormessage() {
  // @@protoc_insertion_point(field_release:proto.ContractFunctionResult.errorMessage)
  return _impl_.errormessage_.Release();
}
inline void ContractFunctionResult::set_allocated_errormessage(std::string* errormessage) {
  if (errormessage != nullptr) {
    
  } else {
    
  }
  _impl_.errormessage_.SetAllocated(errormessage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormessage_.IsDefault()) {
    _impl_.errormessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ContractFunctionResult.errorMessage)
}

// bytes bloom = 4;
inline void ContractFunctionResult::clear_bloom() {
  _impl_.bloom_.ClearToEmpty();
}
inline const std::string& ContractFunctionResult::bloom() const {
  // @@protoc_insertion_point(field_get:proto.ContractFunctionResult.bloom)
  return _internal_bloom();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractFunctionResult::set_bloom(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bloom_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ContractFunctionResult.bloom)
}
inline std::string* ContractFunctionResult::mutable_bloom() {
  std::string* _s = _internal_mutable_bloom();
  // @@protoc_insertion_point(field_mutable:proto.ContractFunctionResult.bloom)
  return _s;
}
inline const std::string& ContractFunctionResult::_internal_bloom() const {
  return _impl_.bloom_.Get();
}
inline void ContractFunctionResult::_internal_set_bloom(const std::string& value) {
  
  _impl_.bloom_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractFunctionResult::_internal_mutable_bloom() {
  
  return _impl_.bloom_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractFunctionResult::release_bloom() {
  // @@protoc_insertion_point(field_release:proto.ContractFunctionResult.bloom)
  return _impl_.bloom_.Release();
}
inline void ContractFunctionResult::set_allocated_bloom(std::string* bloom) {
  if (bloom != nullptr) {
    
  } else {
    
  }
  _impl_.bloom_.SetAllocated(bloom, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bloom_.IsDefault()) {
    _impl_.bloom_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ContractFunctionResult.bloom)
}

// uint64 gasUsed = 5;
inline void ContractFunctionResult::clear_gasused() {
  _impl_.gasused_ = uint64_t{0u};
}
inline uint64_t ContractFunctionResult::_internal_gasused() const {
  return _impl_.gasused_;
}
inline uint64_t ContractFunctionResult::gasused() const {
  // @@protoc_insertion_point(field_get:proto.ContractFunctionResult.gasUsed)
  return _internal_gasused();
}
inline void ContractFunctionResult::_internal_set_gasused(uint64_t value) {
  
  _impl_.gasused_ = value;
}
inline void ContractFunctionResult::set_gasused(uint64_t value) {
  _internal_set_gasused(value);
  // @@protoc_insertion_point(field_set:proto.ContractFunctionResult.gasUsed)
}

// repeated .proto.ContractLoginfo logInfo = 6;
inline int ContractFunctionResult::_internal_loginfo_size() const {
  return _impl_.loginfo_.size();
}
inline int ContractFunctionResult::loginfo_size() const {
  return _internal_loginfo_size();
}
inline void ContractFunctionResult::clear_loginfo() {
  _impl_.loginfo_.Clear();
}
inline ::proto::ContractLoginfo* ContractFunctionResult::mutable_loginfo(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ContractFunctionResult.logInfo)
  return _impl_.loginfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ContractLoginfo >*
ContractFunctionResult::mutable_loginfo() {
  // @@protoc_insertion_point(field_mutable_list:proto.ContractFunctionResult.logInfo)
  return &_impl_.loginfo_;
}
inline const ::proto::ContractLoginfo& ContractFunctionResult::_internal_loginfo(int index) const {
  return _impl_.loginfo_.Get(index);
}
inline const ::proto::ContractLoginfo& ContractFunctionResult::loginfo(int index) const {
  // @@protoc_insertion_point(field_get:proto.ContractFunctionResult.logInfo)
  return _internal_loginfo(index);
}
inline ::proto::ContractLoginfo* ContractFunctionResult::_internal_add_loginfo() {
  return _impl_.loginfo_.Add();
}
inline ::proto::ContractLoginfo* ContractFunctionResult::add_loginfo() {
  ::proto::ContractLoginfo* _add = _internal_add_loginfo();
  // @@protoc_insertion_point(field_add:proto.ContractFunctionResult.logInfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ContractLoginfo >&
ContractFunctionResult::loginfo() const {
  // @@protoc_insertion_point(field_list:proto.ContractFunctionResult.logInfo)
  return _impl_.loginfo_;
}

// repeated .proto.ContractID createdContractIDs = 7 [deprecated = true];
inline int ContractFunctionResult::_internal_createdcontractids_size() const {
  return _impl_.createdcontractids_.size();
}
inline int ContractFunctionResult::createdcontractids_size() const {
  return _internal_createdcontractids_size();
}
inline ::proto::ContractID* ContractFunctionResult::mutable_createdcontractids(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ContractFunctionResult.createdContractIDs)
  return _impl_.createdcontractids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ContractID >*
ContractFunctionResult::mutable_createdcontractids() {
  // @@protoc_insertion_point(field_mutable_list:proto.ContractFunctionResult.createdContractIDs)
  return &_impl_.createdcontractids_;
}
inline const ::proto::ContractID& ContractFunctionResult::_internal_createdcontractids(int index) const {
  return _impl_.createdcontractids_.Get(index);
}
inline const ::proto::ContractID& ContractFunctionResult::createdcontractids(int index) const {
  // @@protoc_insertion_point(field_get:proto.ContractFunctionResult.createdContractIDs)
  return _internal_createdcontractids(index);
}
inline ::proto::ContractID* ContractFunctionResult::_internal_add_createdcontractids() {
  return _impl_.createdcontractids_.Add();
}
inline ::proto::ContractID* ContractFunctionResult::add_createdcontractids() {
  ::proto::ContractID* _add = _internal_add_createdcontractids();
  // @@protoc_insertion_point(field_add:proto.ContractFunctionResult.createdContractIDs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ContractID >&
ContractFunctionResult::createdcontractids() const {
  // @@protoc_insertion_point(field_list:proto.ContractFunctionResult.createdContractIDs)
  return _impl_.createdcontractids_;
}

// .google.protobuf.BytesValue evm_address = 9;
inline bool ContractFunctionResult::_internal_has_evm_address() const {
  return this != internal_default_instance() && _impl_.evm_address_ != nullptr;
}
inline bool ContractFunctionResult::has_evm_address() const {
  return _internal_has_evm_address();
}
inline const ::PROTOBUF_NAMESPACE_ID::BytesValue& ContractFunctionResult::_internal_evm_address() const {
  const ::PROTOBUF_NAMESPACE_ID::BytesValue* p = _impl_.evm_address_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BytesValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BytesValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BytesValue& ContractFunctionResult::evm_address() const {
  // @@protoc_insertion_point(field_get:proto.ContractFunctionResult.evm_address)
  return _internal_evm_address();
}
inline void ContractFunctionResult::unsafe_arena_set_allocated_evm_address(
    ::PROTOBUF_NAMESPACE_ID::BytesValue* evm_address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.evm_address_);
  }
  _impl_.evm_address_ = evm_address;
  if (evm_address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ContractFunctionResult.evm_address)
}
inline ::PROTOBUF_NAMESPACE_ID::BytesValue* ContractFunctionResult::release_evm_address() {
  
  ::PROTOBUF_NAMESPACE_ID::BytesValue* temp = _impl_.evm_address_;
  _impl_.evm_address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BytesValue* ContractFunctionResult::unsafe_arena_release_evm_address() {
  // @@protoc_insertion_point(field_release:proto.ContractFunctionResult.evm_address)
  
  ::PROTOBUF_NAMESPACE_ID::BytesValue* temp = _impl_.evm_address_;
  _impl_.evm_address_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BytesValue* ContractFunctionResult::_internal_mutable_evm_address() {
  
  if (_impl_.evm_address_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BytesValue>(GetArenaForAllocation());
    _impl_.evm_address_ = p;
  }
  return _impl_.evm_address_;
}
inline ::PROTOBUF_NAMESPACE_ID::BytesValue* ContractFunctionResult::mutable_evm_address() {
  ::PROTOBUF_NAMESPACE_ID::BytesValue* _msg = _internal_mutable_evm_address();
  // @@protoc_insertion_point(field_mutable:proto.ContractFunctionResult.evm_address)
  return _msg;
}
inline void ContractFunctionResult::set_allocated_evm_address(::PROTOBUF_NAMESPACE_ID::BytesValue* evm_address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.evm_address_);
  }
  if (evm_address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(evm_address));
    if (message_arena != submessage_arena) {
      evm_address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, evm_address, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.evm_address_ = evm_address;
  // @@protoc_insertion_point(field_set_allocated:proto.ContractFunctionResult.evm_address)
}

// int64 gas = 10;
inline void ContractFunctionResult::clear_gas() {
  _impl_.gas_ = int64_t{0};
}
inline int64_t ContractFunctionResult::_internal_gas() const {
  return _impl_.gas_;
}
inline int64_t ContractFunctionResult::gas() const {
  // @@protoc_insertion_point(field_get:proto.ContractFunctionResult.gas)
  return _internal_gas();
}
inline void ContractFunctionResult::_internal_set_gas(int64_t value) {
  
  _impl_.gas_ = value;
}
inline void ContractFunctionResult::set_gas(int64_t value) {
  _internal_set_gas(value);
  // @@protoc_insertion_point(field_set:proto.ContractFunctionResult.gas)
}

// int64 amount = 11;
inline void ContractFunctionResult::clear_amount() {
  _impl_.amount_ = int64_t{0};
}
inline int64_t ContractFunctionResult::_internal_amount() const {
  return _impl_.amount_;
}
inline int64_t ContractFunctionResult::amount() const {
  // @@protoc_insertion_point(field_get:proto.ContractFunctionResult.amount)
  return _internal_amount();
}
inline void ContractFunctionResult::_internal_set_amount(int64_t value) {
  
  _impl_.amount_ = value;
}
inline void ContractFunctionResult::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:proto.ContractFunctionResult.amount)
}

// bytes functionParameters = 12;
inline void ContractFunctionResult::clear_functionparameters() {
  _impl_.functionparameters_.ClearToEmpty();
}
inline const std::string& ContractFunctionResult::functionparameters() const {
  // @@protoc_insertion_point(field_get:proto.ContractFunctionResult.functionParameters)
  return _internal_functionparameters();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractFunctionResult::set_functionparameters(ArgT0&& arg0, ArgT... args) {
 
 _impl_.functionparameters_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ContractFunctionResult.functionParameters)
}
inline std::string* ContractFunctionResult::mutable_functionparameters() {
  std::string* _s = _internal_mutable_functionparameters();
  // @@protoc_insertion_point(field_mutable:proto.ContractFunctionResult.functionParameters)
  return _s;
}
inline const std::string& ContractFunctionResult::_internal_functionparameters() const {
  return _impl_.functionparameters_.Get();
}
inline void ContractFunctionResult::_internal_set_functionparameters(const std::string& value) {
  
  _impl_.functionparameters_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractFunctionResult::_internal_mutable_functionparameters() {
  
  return _impl_.functionparameters_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractFunctionResult::release_functionparameters() {
  // @@protoc_insertion_point(field_release:proto.ContractFunctionResult.functionParameters)
  return _impl_.functionparameters_.Release();
}
inline void ContractFunctionResult::set_allocated_functionparameters(std::string* functionparameters) {
  if (functionparameters != nullptr) {
    
  } else {
    
  }
  _impl_.functionparameters_.SetAllocated(functionparameters, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.functionparameters_.IsDefault()) {
    _impl_.functionparameters_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ContractFunctionResult.functionParameters)
}

// .proto.AccountID sender_id = 13;
inline bool ContractFunctionResult::_internal_has_sender_id() const {
  return this != internal_default_instance() && _impl_.sender_id_ != nullptr;
}
inline bool ContractFunctionResult::has_sender_id() const {
  return _internal_has_sender_id();
}
inline const ::proto::AccountID& ContractFunctionResult::_internal_sender_id() const {
  const ::proto::AccountID* p = _impl_.sender_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AccountID&>(
      ::proto::_AccountID_default_instance_);
}
inline const ::proto::AccountID& ContractFunctionResult::sender_id() const {
  // @@protoc_insertion_point(field_get:proto.ContractFunctionResult.sender_id)
  return _internal_sender_id();
}
inline void ContractFunctionResult::unsafe_arena_set_allocated_sender_id(
    ::proto::AccountID* sender_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sender_id_);
  }
  _impl_.sender_id_ = sender_id;
  if (sender_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ContractFunctionResult.sender_id)
}
inline ::proto::AccountID* ContractFunctionResult::release_sender_id() {
  
  ::proto::AccountID* temp = _impl_.sender_id_;
  _impl_.sender_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AccountID* ContractFunctionResult::unsafe_arena_release_sender_id() {
  // @@protoc_insertion_point(field_release:proto.ContractFunctionResult.sender_id)
  
  ::proto::AccountID* temp = _impl_.sender_id_;
  _impl_.sender_id_ = nullptr;
  return temp;
}
inline ::proto::AccountID* ContractFunctionResult::_internal_mutable_sender_id() {
  
  if (_impl_.sender_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AccountID>(GetArenaForAllocation());
    _impl_.sender_id_ = p;
  }
  return _impl_.sender_id_;
}
inline ::proto::AccountID* ContractFunctionResult::mutable_sender_id() {
  ::proto::AccountID* _msg = _internal_mutable_sender_id();
  // @@protoc_insertion_point(field_mutable:proto.ContractFunctionResult.sender_id)
  return _msg;
}
inline void ContractFunctionResult::set_allocated_sender_id(::proto::AccountID* sender_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sender_id_);
  }
  if (sender_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sender_id));
    if (message_arena != submessage_arena) {
      sender_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sender_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sender_id_ = sender_id;
  // @@protoc_insertion_point(field_set_allocated:proto.ContractFunctionResult.sender_id)
}

// -------------------------------------------------------------------

// ContractCallLocalQuery

// .proto.QueryHeader header = 1;
inline bool ContractCallLocalQuery::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ContractCallLocalQuery::has_header() const {
  return _internal_has_header();
}
inline const ::proto::QueryHeader& ContractCallLocalQuery::_internal_header() const {
  const ::proto::QueryHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::QueryHeader&>(
      ::proto::_QueryHeader_default_instance_);
}
inline const ::proto::QueryHeader& ContractCallLocalQuery::header() const {
  // @@protoc_insertion_point(field_get:proto.ContractCallLocalQuery.header)
  return _internal_header();
}
inline void ContractCallLocalQuery::unsafe_arena_set_allocated_header(
    ::proto::QueryHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ContractCallLocalQuery.header)
}
inline ::proto::QueryHeader* ContractCallLocalQuery::release_header() {
  
  ::proto::QueryHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::QueryHeader* ContractCallLocalQuery::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:proto.ContractCallLocalQuery.header)
  
  ::proto::QueryHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::proto::QueryHeader* ContractCallLocalQuery::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::QueryHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::proto::QueryHeader* ContractCallLocalQuery::mutable_header() {
  ::proto::QueryHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:proto.ContractCallLocalQuery.header)
  return _msg;
}
inline void ContractCallLocalQuery::set_allocated_header(::proto::QueryHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:proto.ContractCallLocalQuery.header)
}

// .proto.ContractID contractID = 2;
inline bool ContractCallLocalQuery::_internal_has_contractid() const {
  return this != internal_default_instance() && _impl_.contractid_ != nullptr;
}
inline bool ContractCallLocalQuery::has_contractid() const {
  return _internal_has_contractid();
}
inline const ::proto::ContractID& ContractCallLocalQuery::_internal_contractid() const {
  const ::proto::ContractID* p = _impl_.contractid_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContractID&>(
      ::proto::_ContractID_default_instance_);
}
inline const ::proto::ContractID& ContractCallLocalQuery::contractid() const {
  // @@protoc_insertion_point(field_get:proto.ContractCallLocalQuery.contractID)
  return _internal_contractid();
}
inline void ContractCallLocalQuery::unsafe_arena_set_allocated_contractid(
    ::proto::ContractID* contractid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contractid_);
  }
  _impl_.contractid_ = contractid;
  if (contractid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ContractCallLocalQuery.contractID)
}
inline ::proto::ContractID* ContractCallLocalQuery::release_contractid() {
  
  ::proto::ContractID* temp = _impl_.contractid_;
  _impl_.contractid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContractID* ContractCallLocalQuery::unsafe_arena_release_contractid() {
  // @@protoc_insertion_point(field_release:proto.ContractCallLocalQuery.contractID)
  
  ::proto::ContractID* temp = _impl_.contractid_;
  _impl_.contractid_ = nullptr;
  return temp;
}
inline ::proto::ContractID* ContractCallLocalQuery::_internal_mutable_contractid() {
  
  if (_impl_.contractid_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContractID>(GetArenaForAllocation());
    _impl_.contractid_ = p;
  }
  return _impl_.contractid_;
}
inline ::proto::ContractID* ContractCallLocalQuery::mutable_contractid() {
  ::proto::ContractID* _msg = _internal_mutable_contractid();
  // @@protoc_insertion_point(field_mutable:proto.ContractCallLocalQuery.contractID)
  return _msg;
}
inline void ContractCallLocalQuery::set_allocated_contractid(::proto::ContractID* contractid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contractid_);
  }
  if (contractid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contractid));
    if (message_arena != submessage_arena) {
      contractid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contractid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.contractid_ = contractid;
  // @@protoc_insertion_point(field_set_allocated:proto.ContractCallLocalQuery.contractID)
}

// int64 gas = 3;
inline void ContractCallLocalQuery::clear_gas() {
  _impl_.gas_ = int64_t{0};
}
inline int64_t ContractCallLocalQuery::_internal_gas() const {
  return _impl_.gas_;
}
inline int64_t ContractCallLocalQuery::gas() const {
  // @@protoc_insertion_point(field_get:proto.ContractCallLocalQuery.gas)
  return _internal_gas();
}
inline void ContractCallLocalQuery::_internal_set_gas(int64_t value) {
  
  _impl_.gas_ = value;
}
inline void ContractCallLocalQuery::set_gas(int64_t value) {
  _internal_set_gas(value);
  // @@protoc_insertion_point(field_set:proto.ContractCallLocalQuery.gas)
}

// bytes functionParameters = 4;
inline void ContractCallLocalQuery::clear_functionparameters() {
  _impl_.functionparameters_.ClearToEmpty();
}
inline const std::string& ContractCallLocalQuery::functionparameters() const {
  // @@protoc_insertion_point(field_get:proto.ContractCallLocalQuery.functionParameters)
  return _internal_functionparameters();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractCallLocalQuery::set_functionparameters(ArgT0&& arg0, ArgT... args) {
 
 _impl_.functionparameters_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.ContractCallLocalQuery.functionParameters)
}
inline std::string* ContractCallLocalQuery::mutable_functionparameters() {
  std::string* _s = _internal_mutable_functionparameters();
  // @@protoc_insertion_point(field_mutable:proto.ContractCallLocalQuery.functionParameters)
  return _s;
}
inline const std::string& ContractCallLocalQuery::_internal_functionparameters() const {
  return _impl_.functionparameters_.Get();
}
inline void ContractCallLocalQuery::_internal_set_functionparameters(const std::string& value) {
  
  _impl_.functionparameters_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractCallLocalQuery::_internal_mutable_functionparameters() {
  
  return _impl_.functionparameters_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractCallLocalQuery::release_functionparameters() {
  // @@protoc_insertion_point(field_release:proto.ContractCallLocalQuery.functionParameters)
  return _impl_.functionparameters_.Release();
}
inline void ContractCallLocalQuery::set_allocated_functionparameters(std::string* functionparameters) {
  if (functionparameters != nullptr) {
    
  } else {
    
  }
  _impl_.functionparameters_.SetAllocated(functionparameters, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.functionparameters_.IsDefault()) {
    _impl_.functionparameters_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.ContractCallLocalQuery.functionParameters)
}

// int64 maxResultSize = 5 [deprecated = true];
inline void ContractCallLocalQuery::clear_maxresultsize() {
  _impl_.maxresultsize_ = int64_t{0};
}
inline int64_t ContractCallLocalQuery::_internal_maxresultsize() const {
  return _impl_.maxresultsize_;
}
inline int64_t ContractCallLocalQuery::maxresultsize() const {
  // @@protoc_insertion_point(field_get:proto.ContractCallLocalQuery.maxResultSize)
  return _internal_maxresultsize();
}
inline void ContractCallLocalQuery::_internal_set_maxresultsize(int64_t value) {
  
  _impl_.maxresultsize_ = value;
}
inline void ContractCallLocalQuery::set_maxresultsize(int64_t value) {
  _internal_set_maxresultsize(value);
  // @@protoc_insertion_point(field_set:proto.ContractCallLocalQuery.maxResultSize)
}

// .proto.AccountID sender_id = 6;
inline bool ContractCallLocalQuery::_internal_has_sender_id() const {
  return this != internal_default_instance() && _impl_.sender_id_ != nullptr;
}
inline bool ContractCallLocalQuery::has_sender_id() const {
  return _internal_has_sender_id();
}
inline const ::proto::AccountID& ContractCallLocalQuery::_internal_sender_id() const {
  const ::proto::AccountID* p = _impl_.sender_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AccountID&>(
      ::proto::_AccountID_default_instance_);
}
inline const ::proto::AccountID& ContractCallLocalQuery::sender_id() const {
  // @@protoc_insertion_point(field_get:proto.ContractCallLocalQuery.sender_id)
  return _internal_sender_id();
}
inline void ContractCallLocalQuery::unsafe_arena_set_allocated_sender_id(
    ::proto::AccountID* sender_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sender_id_);
  }
  _impl_.sender_id_ = sender_id;
  if (sender_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ContractCallLocalQuery.sender_id)
}
inline ::proto::AccountID* ContractCallLocalQuery::release_sender_id() {
  
  ::proto::AccountID* temp = _impl_.sender_id_;
  _impl_.sender_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AccountID* ContractCallLocalQuery::unsafe_arena_release_sender_id() {
  // @@protoc_insertion_point(field_release:proto.ContractCallLocalQuery.sender_id)
  
  ::proto::AccountID* temp = _impl_.sender_id_;
  _impl_.sender_id_ = nullptr;
  return temp;
}
inline ::proto::AccountID* ContractCallLocalQuery::_internal_mutable_sender_id() {
  
  if (_impl_.sender_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AccountID>(GetArenaForAllocation());
    _impl_.sender_id_ = p;
  }
  return _impl_.sender_id_;
}
inline ::proto::AccountID* ContractCallLocalQuery::mutable_sender_id() {
  ::proto::AccountID* _msg = _internal_mutable_sender_id();
  // @@protoc_insertion_point(field_mutable:proto.ContractCallLocalQuery.sender_id)
  return _msg;
}
inline void ContractCallLocalQuery::set_allocated_sender_id(::proto::AccountID* sender_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sender_id_);
  }
  if (sender_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sender_id));
    if (message_arena != submessage_arena) {
      sender_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sender_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sender_id_ = sender_id;
  // @@protoc_insertion_point(field_set_allocated:proto.ContractCallLocalQuery.sender_id)
}

// -------------------------------------------------------------------

// ContractCallLocalResponse

// .proto.ResponseHeader header = 1;
inline bool ContractCallLocalResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ContractCallLocalResponse::has_header() const {
  return _internal_has_header();
}
inline const ::proto::ResponseHeader& ContractCallLocalResponse::_internal_header() const {
  const ::proto::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ResponseHeader&>(
      ::proto::_ResponseHeader_default_instance_);
}
inline const ::proto::ResponseHeader& ContractCallLocalResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.ContractCallLocalResponse.header)
  return _internal_header();
}
inline void ContractCallLocalResponse::unsafe_arena_set_allocated_header(
    ::proto::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ContractCallLocalResponse.header)
}
inline ::proto::ResponseHeader* ContractCallLocalResponse::release_header() {
  
  ::proto::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ResponseHeader* ContractCallLocalResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:proto.ContractCallLocalResponse.header)
  
  ::proto::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::proto::ResponseHeader* ContractCallLocalResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::proto::ResponseHeader* ContractCallLocalResponse::mutable_header() {
  ::proto::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:proto.ContractCallLocalResponse.header)
  return _msg;
}
inline void ContractCallLocalResponse::set_allocated_header(::proto::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:proto.ContractCallLocalResponse.header)
}

// .proto.ContractFunctionResult functionResult = 2;
inline bool ContractCallLocalResponse::_internal_has_functionresult() const {
  return this != internal_default_instance() && _impl_.functionresult_ != nullptr;
}
inline bool ContractCallLocalResponse::has_functionresult() const {
  return _internal_has_functionresult();
}
inline void ContractCallLocalResponse::clear_functionresult() {
  if (GetArenaForAllocation() == nullptr && _impl_.functionresult_ != nullptr) {
    delete _impl_.functionresult_;
  }
  _impl_.functionresult_ = nullptr;
}
inline const ::proto::ContractFunctionResult& ContractCallLocalResponse::_internal_functionresult() const {
  const ::proto::ContractFunctionResult* p = _impl_.functionresult_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ContractFunctionResult&>(
      ::proto::_ContractFunctionResult_default_instance_);
}
inline const ::proto::ContractFunctionResult& ContractCallLocalResponse::functionresult() const {
  // @@protoc_insertion_point(field_get:proto.ContractCallLocalResponse.functionResult)
  return _internal_functionresult();
}
inline void ContractCallLocalResponse::unsafe_arena_set_allocated_functionresult(
    ::proto::ContractFunctionResult* functionresult) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.functionresult_);
  }
  _impl_.functionresult_ = functionresult;
  if (functionresult) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ContractCallLocalResponse.functionResult)
}
inline ::proto::ContractFunctionResult* ContractCallLocalResponse::release_functionresult() {
  
  ::proto::ContractFunctionResult* temp = _impl_.functionresult_;
  _impl_.functionresult_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ContractFunctionResult* ContractCallLocalResponse::unsafe_arena_release_functionresult() {
  // @@protoc_insertion_point(field_release:proto.ContractCallLocalResponse.functionResult)
  
  ::proto::ContractFunctionResult* temp = _impl_.functionresult_;
  _impl_.functionresult_ = nullptr;
  return temp;
}
inline ::proto::ContractFunctionResult* ContractCallLocalResponse::_internal_mutable_functionresult() {
  
  if (_impl_.functionresult_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ContractFunctionResult>(GetArenaForAllocation());
    _impl_.functionresult_ = p;
  }
  return _impl_.functionresult_;
}
inline ::proto::ContractFunctionResult* ContractCallLocalResponse::mutable_functionresult() {
  ::proto::ContractFunctionResult* _msg = _internal_mutable_functionresult();
  // @@protoc_insertion_point(field_mutable:proto.ContractCallLocalResponse.functionResult)
  return _msg;
}
inline void ContractCallLocalResponse::set_allocated_functionresult(::proto::ContractFunctionResult* functionresult) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.functionresult_;
  }
  if (functionresult) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(functionresult);
    if (message_arena != submessage_arena) {
      functionresult = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, functionresult, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.functionresult_ = functionresult;
  // @@protoc_insertion_point(field_set_allocated:proto.ContractCallLocalResponse.functionResult)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_contract_5fcall_5flocal_2eproto
