// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: response.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_response_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_response_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "get_by_key.pb.h"
#include "get_by_solidity_id.pb.h"
#include "contract_call_local.pb.h"
#include "contract_get_bytecode.pb.h"
#include "contract_get_info.pb.h"
#include "contract_get_records.pb.h"
#include "crypto_get_account_balance.pb.h"
#include "crypto_get_account_records.pb.h"
#include "crypto_get_info.pb.h"
#include "crypto_get_live_hash.pb.h"
#include "crypto_get_stakers.pb.h"
#include "file_get_contents.pb.h"
#include "file_get_info.pb.h"
#include "transaction_get_receipt.pb.h"
#include "transaction_get_record.pb.h"
#include "transaction_get_fast_record.pb.h"
#include "consensus_get_topic_info.pb.h"
#include "network_get_version_info.pb.h"
#include "network_get_execution_time.pb.h"
#include "token_get_account_nft_infos.pb.h"
#include "token_get_info.pb.h"
#include "token_get_nft_info.pb.h"
#include "token_get_nft_infos.pb.h"
#include "schedule_get_info.pb.h"
#include "get_account_details.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_response_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_response_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_response_2eproto;
namespace proto {
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::Response* Arena::CreateMaybeMessage<::proto::Response>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

// ===================================================================

class Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  explicit PROTOBUF_CONSTEXPR Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kGetByKey = 1,
    kGetBySolidityID = 2,
    kContractCallLocal = 3,
    kContractGetBytecodeResponse = 5,
    kContractGetInfo = 4,
    kContractGetRecordsResponse = 6,
    kCryptogetAccountBalance = 7,
    kCryptoGetAccountRecords = 8,
    kCryptoGetInfo = 9,
    kCryptoGetLiveHash = 10,
    kCryptoGetProxyStakers = 11,
    kFileGetContents = 12,
    kFileGetInfo = 13,
    kTransactionGetReceipt = 14,
    kTransactionGetRecord = 15,
    kTransactionGetFastRecord = 16,
    kConsensusGetTopicInfo = 150,
    kNetworkGetVersionInfo = 151,
    kTokenGetInfo = 152,
    kScheduleGetInfo = 153,
    kTokenGetAccountNftInfos = 154,
    kTokenGetNftInfo = 155,
    kTokenGetNftInfos = 156,
    kNetworkGetExecutionTime = 157,
    kAccountDetails = 158,
    RESPONSE_NOT_SET = 0,
  };

  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Response& from) {
    Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGetByKeyFieldNumber = 1,
    kGetBySolidityIDFieldNumber = 2,
    kContractCallLocalFieldNumber = 3,
    kContractGetBytecodeResponseFieldNumber = 5,
    kContractGetInfoFieldNumber = 4,
    kContractGetRecordsResponseFieldNumber = 6,
    kCryptogetAccountBalanceFieldNumber = 7,
    kCryptoGetAccountRecordsFieldNumber = 8,
    kCryptoGetInfoFieldNumber = 9,
    kCryptoGetLiveHashFieldNumber = 10,
    kCryptoGetProxyStakersFieldNumber = 11,
    kFileGetContentsFieldNumber = 12,
    kFileGetInfoFieldNumber = 13,
    kTransactionGetReceiptFieldNumber = 14,
    kTransactionGetRecordFieldNumber = 15,
    kTransactionGetFastRecordFieldNumber = 16,
    kConsensusGetTopicInfoFieldNumber = 150,
    kNetworkGetVersionInfoFieldNumber = 151,
    kTokenGetInfoFieldNumber = 152,
    kScheduleGetInfoFieldNumber = 153,
    kTokenGetAccountNftInfosFieldNumber = 154,
    kTokenGetNftInfoFieldNumber = 155,
    kTokenGetNftInfosFieldNumber = 156,
    kNetworkGetExecutionTimeFieldNumber = 157,
    kAccountDetailsFieldNumber = 158,
  };
  // .proto.GetByKeyResponse getByKey = 1;
  bool has_getbykey() const;
  private:
  bool _internal_has_getbykey() const;
  public:
  void clear_getbykey();
  const ::proto::GetByKeyResponse& getbykey() const;
  PROTOBUF_NODISCARD ::proto::GetByKeyResponse* release_getbykey();
  ::proto::GetByKeyResponse* mutable_getbykey();
  void set_allocated_getbykey(::proto::GetByKeyResponse* getbykey);
  private:
  const ::proto::GetByKeyResponse& _internal_getbykey() const;
  ::proto::GetByKeyResponse* _internal_mutable_getbykey();
  public:
  void unsafe_arena_set_allocated_getbykey(
      ::proto::GetByKeyResponse* getbykey);
  ::proto::GetByKeyResponse* unsafe_arena_release_getbykey();

  // .proto.GetBySolidityIDResponse getBySolidityID = 2;
  bool has_getbysolidityid() const;
  private:
  bool _internal_has_getbysolidityid() const;
  public:
  void clear_getbysolidityid();
  const ::proto::GetBySolidityIDResponse& getbysolidityid() const;
  PROTOBUF_NODISCARD ::proto::GetBySolidityIDResponse* release_getbysolidityid();
  ::proto::GetBySolidityIDResponse* mutable_getbysolidityid();
  void set_allocated_getbysolidityid(::proto::GetBySolidityIDResponse* getbysolidityid);
  private:
  const ::proto::GetBySolidityIDResponse& _internal_getbysolidityid() const;
  ::proto::GetBySolidityIDResponse* _internal_mutable_getbysolidityid();
  public:
  void unsafe_arena_set_allocated_getbysolidityid(
      ::proto::GetBySolidityIDResponse* getbysolidityid);
  ::proto::GetBySolidityIDResponse* unsafe_arena_release_getbysolidityid();

  // .proto.ContractCallLocalResponse contractCallLocal = 3;
  bool has_contractcalllocal() const;
  private:
  bool _internal_has_contractcalllocal() const;
  public:
  void clear_contractcalllocal();
  const ::proto::ContractCallLocalResponse& contractcalllocal() const;
  PROTOBUF_NODISCARD ::proto::ContractCallLocalResponse* release_contractcalllocal();
  ::proto::ContractCallLocalResponse* mutable_contractcalllocal();
  void set_allocated_contractcalllocal(::proto::ContractCallLocalResponse* contractcalllocal);
  private:
  const ::proto::ContractCallLocalResponse& _internal_contractcalllocal() const;
  ::proto::ContractCallLocalResponse* _internal_mutable_contractcalllocal();
  public:
  void unsafe_arena_set_allocated_contractcalllocal(
      ::proto::ContractCallLocalResponse* contractcalllocal);
  ::proto::ContractCallLocalResponse* unsafe_arena_release_contractcalllocal();

  // .proto.ContractGetBytecodeResponse contractGetBytecodeResponse = 5;
  bool has_contractgetbytecoderesponse() const;
  private:
  bool _internal_has_contractgetbytecoderesponse() const;
  public:
  void clear_contractgetbytecoderesponse();
  const ::proto::ContractGetBytecodeResponse& contractgetbytecoderesponse() const;
  PROTOBUF_NODISCARD ::proto::ContractGetBytecodeResponse* release_contractgetbytecoderesponse();
  ::proto::ContractGetBytecodeResponse* mutable_contractgetbytecoderesponse();
  void set_allocated_contractgetbytecoderesponse(::proto::ContractGetBytecodeResponse* contractgetbytecoderesponse);
  private:
  const ::proto::ContractGetBytecodeResponse& _internal_contractgetbytecoderesponse() const;
  ::proto::ContractGetBytecodeResponse* _internal_mutable_contractgetbytecoderesponse();
  public:
  void unsafe_arena_set_allocated_contractgetbytecoderesponse(
      ::proto::ContractGetBytecodeResponse* contractgetbytecoderesponse);
  ::proto::ContractGetBytecodeResponse* unsafe_arena_release_contractgetbytecoderesponse();

  // .proto.ContractGetInfoResponse contractGetInfo = 4;
  bool has_contractgetinfo() const;
  private:
  bool _internal_has_contractgetinfo() const;
  public:
  void clear_contractgetinfo();
  const ::proto::ContractGetInfoResponse& contractgetinfo() const;
  PROTOBUF_NODISCARD ::proto::ContractGetInfoResponse* release_contractgetinfo();
  ::proto::ContractGetInfoResponse* mutable_contractgetinfo();
  void set_allocated_contractgetinfo(::proto::ContractGetInfoResponse* contractgetinfo);
  private:
  const ::proto::ContractGetInfoResponse& _internal_contractgetinfo() const;
  ::proto::ContractGetInfoResponse* _internal_mutable_contractgetinfo();
  public:
  void unsafe_arena_set_allocated_contractgetinfo(
      ::proto::ContractGetInfoResponse* contractgetinfo);
  ::proto::ContractGetInfoResponse* unsafe_arena_release_contractgetinfo();

  // .proto.ContractGetRecordsResponse contractGetRecordsResponse = 6;
  bool has_contractgetrecordsresponse() const;
  private:
  bool _internal_has_contractgetrecordsresponse() const;
  public:
  void clear_contractgetrecordsresponse();
  const ::proto::ContractGetRecordsResponse& contractgetrecordsresponse() const;
  PROTOBUF_NODISCARD ::proto::ContractGetRecordsResponse* release_contractgetrecordsresponse();
  ::proto::ContractGetRecordsResponse* mutable_contractgetrecordsresponse();
  void set_allocated_contractgetrecordsresponse(::proto::ContractGetRecordsResponse* contractgetrecordsresponse);
  private:
  const ::proto::ContractGetRecordsResponse& _internal_contractgetrecordsresponse() const;
  ::proto::ContractGetRecordsResponse* _internal_mutable_contractgetrecordsresponse();
  public:
  void unsafe_arena_set_allocated_contractgetrecordsresponse(
      ::proto::ContractGetRecordsResponse* contractgetrecordsresponse);
  ::proto::ContractGetRecordsResponse* unsafe_arena_release_contractgetrecordsresponse();

  // .proto.CryptoGetAccountBalanceResponse cryptogetAccountBalance = 7;
  bool has_cryptogetaccountbalance() const;
  private:
  bool _internal_has_cryptogetaccountbalance() const;
  public:
  void clear_cryptogetaccountbalance();
  const ::proto::CryptoGetAccountBalanceResponse& cryptogetaccountbalance() const;
  PROTOBUF_NODISCARD ::proto::CryptoGetAccountBalanceResponse* release_cryptogetaccountbalance();
  ::proto::CryptoGetAccountBalanceResponse* mutable_cryptogetaccountbalance();
  void set_allocated_cryptogetaccountbalance(::proto::CryptoGetAccountBalanceResponse* cryptogetaccountbalance);
  private:
  const ::proto::CryptoGetAccountBalanceResponse& _internal_cryptogetaccountbalance() const;
  ::proto::CryptoGetAccountBalanceResponse* _internal_mutable_cryptogetaccountbalance();
  public:
  void unsafe_arena_set_allocated_cryptogetaccountbalance(
      ::proto::CryptoGetAccountBalanceResponse* cryptogetaccountbalance);
  ::proto::CryptoGetAccountBalanceResponse* unsafe_arena_release_cryptogetaccountbalance();

  // .proto.CryptoGetAccountRecordsResponse cryptoGetAccountRecords = 8;
  bool has_cryptogetaccountrecords() const;
  private:
  bool _internal_has_cryptogetaccountrecords() const;
  public:
  void clear_cryptogetaccountrecords();
  const ::proto::CryptoGetAccountRecordsResponse& cryptogetaccountrecords() const;
  PROTOBUF_NODISCARD ::proto::CryptoGetAccountRecordsResponse* release_cryptogetaccountrecords();
  ::proto::CryptoGetAccountRecordsResponse* mutable_cryptogetaccountrecords();
  void set_allocated_cryptogetaccountrecords(::proto::CryptoGetAccountRecordsResponse* cryptogetaccountrecords);
  private:
  const ::proto::CryptoGetAccountRecordsResponse& _internal_cryptogetaccountrecords() const;
  ::proto::CryptoGetAccountRecordsResponse* _internal_mutable_cryptogetaccountrecords();
  public:
  void unsafe_arena_set_allocated_cryptogetaccountrecords(
      ::proto::CryptoGetAccountRecordsResponse* cryptogetaccountrecords);
  ::proto::CryptoGetAccountRecordsResponse* unsafe_arena_release_cryptogetaccountrecords();

  // .proto.CryptoGetInfoResponse cryptoGetInfo = 9;
  bool has_cryptogetinfo() const;
  private:
  bool _internal_has_cryptogetinfo() const;
  public:
  void clear_cryptogetinfo();
  const ::proto::CryptoGetInfoResponse& cryptogetinfo() const;
  PROTOBUF_NODISCARD ::proto::CryptoGetInfoResponse* release_cryptogetinfo();
  ::proto::CryptoGetInfoResponse* mutable_cryptogetinfo();
  void set_allocated_cryptogetinfo(::proto::CryptoGetInfoResponse* cryptogetinfo);
  private:
  const ::proto::CryptoGetInfoResponse& _internal_cryptogetinfo() const;
  ::proto::CryptoGetInfoResponse* _internal_mutable_cryptogetinfo();
  public:
  void unsafe_arena_set_allocated_cryptogetinfo(
      ::proto::CryptoGetInfoResponse* cryptogetinfo);
  ::proto::CryptoGetInfoResponse* unsafe_arena_release_cryptogetinfo();

  // .proto.CryptoGetLiveHashResponse cryptoGetLiveHash = 10;
  bool has_cryptogetlivehash() const;
  private:
  bool _internal_has_cryptogetlivehash() const;
  public:
  void clear_cryptogetlivehash();
  const ::proto::CryptoGetLiveHashResponse& cryptogetlivehash() const;
  PROTOBUF_NODISCARD ::proto::CryptoGetLiveHashResponse* release_cryptogetlivehash();
  ::proto::CryptoGetLiveHashResponse* mutable_cryptogetlivehash();
  void set_allocated_cryptogetlivehash(::proto::CryptoGetLiveHashResponse* cryptogetlivehash);
  private:
  const ::proto::CryptoGetLiveHashResponse& _internal_cryptogetlivehash() const;
  ::proto::CryptoGetLiveHashResponse* _internal_mutable_cryptogetlivehash();
  public:
  void unsafe_arena_set_allocated_cryptogetlivehash(
      ::proto::CryptoGetLiveHashResponse* cryptogetlivehash);
  ::proto::CryptoGetLiveHashResponse* unsafe_arena_release_cryptogetlivehash();

  // .proto.CryptoGetStakersResponse cryptoGetProxyStakers = 11;
  bool has_cryptogetproxystakers() const;
  private:
  bool _internal_has_cryptogetproxystakers() const;
  public:
  void clear_cryptogetproxystakers();
  const ::proto::CryptoGetStakersResponse& cryptogetproxystakers() const;
  PROTOBUF_NODISCARD ::proto::CryptoGetStakersResponse* release_cryptogetproxystakers();
  ::proto::CryptoGetStakersResponse* mutable_cryptogetproxystakers();
  void set_allocated_cryptogetproxystakers(::proto::CryptoGetStakersResponse* cryptogetproxystakers);
  private:
  const ::proto::CryptoGetStakersResponse& _internal_cryptogetproxystakers() const;
  ::proto::CryptoGetStakersResponse* _internal_mutable_cryptogetproxystakers();
  public:
  void unsafe_arena_set_allocated_cryptogetproxystakers(
      ::proto::CryptoGetStakersResponse* cryptogetproxystakers);
  ::proto::CryptoGetStakersResponse* unsafe_arena_release_cryptogetproxystakers();

  // .proto.FileGetContentsResponse fileGetContents = 12;
  bool has_filegetcontents() const;
  private:
  bool _internal_has_filegetcontents() const;
  public:
  void clear_filegetcontents();
  const ::proto::FileGetContentsResponse& filegetcontents() const;
  PROTOBUF_NODISCARD ::proto::FileGetContentsResponse* release_filegetcontents();
  ::proto::FileGetContentsResponse* mutable_filegetcontents();
  void set_allocated_filegetcontents(::proto::FileGetContentsResponse* filegetcontents);
  private:
  const ::proto::FileGetContentsResponse& _internal_filegetcontents() const;
  ::proto::FileGetContentsResponse* _internal_mutable_filegetcontents();
  public:
  void unsafe_arena_set_allocated_filegetcontents(
      ::proto::FileGetContentsResponse* filegetcontents);
  ::proto::FileGetContentsResponse* unsafe_arena_release_filegetcontents();

  // .proto.FileGetInfoResponse fileGetInfo = 13;
  bool has_filegetinfo() const;
  private:
  bool _internal_has_filegetinfo() const;
  public:
  void clear_filegetinfo();
  const ::proto::FileGetInfoResponse& filegetinfo() const;
  PROTOBUF_NODISCARD ::proto::FileGetInfoResponse* release_filegetinfo();
  ::proto::FileGetInfoResponse* mutable_filegetinfo();
  void set_allocated_filegetinfo(::proto::FileGetInfoResponse* filegetinfo);
  private:
  const ::proto::FileGetInfoResponse& _internal_filegetinfo() const;
  ::proto::FileGetInfoResponse* _internal_mutable_filegetinfo();
  public:
  void unsafe_arena_set_allocated_filegetinfo(
      ::proto::FileGetInfoResponse* filegetinfo);
  ::proto::FileGetInfoResponse* unsafe_arena_release_filegetinfo();

  // .proto.TransactionGetReceiptResponse transactionGetReceipt = 14;
  bool has_transactiongetreceipt() const;
  private:
  bool _internal_has_transactiongetreceipt() const;
  public:
  void clear_transactiongetreceipt();
  const ::proto::TransactionGetReceiptResponse& transactiongetreceipt() const;
  PROTOBUF_NODISCARD ::proto::TransactionGetReceiptResponse* release_transactiongetreceipt();
  ::proto::TransactionGetReceiptResponse* mutable_transactiongetreceipt();
  void set_allocated_transactiongetreceipt(::proto::TransactionGetReceiptResponse* transactiongetreceipt);
  private:
  const ::proto::TransactionGetReceiptResponse& _internal_transactiongetreceipt() const;
  ::proto::TransactionGetReceiptResponse* _internal_mutable_transactiongetreceipt();
  public:
  void unsafe_arena_set_allocated_transactiongetreceipt(
      ::proto::TransactionGetReceiptResponse* transactiongetreceipt);
  ::proto::TransactionGetReceiptResponse* unsafe_arena_release_transactiongetreceipt();

  // .proto.TransactionGetRecordResponse transactionGetRecord = 15;
  bool has_transactiongetrecord() const;
  private:
  bool _internal_has_transactiongetrecord() const;
  public:
  void clear_transactiongetrecord();
  const ::proto::TransactionGetRecordResponse& transactiongetrecord() const;
  PROTOBUF_NODISCARD ::proto::TransactionGetRecordResponse* release_transactiongetrecord();
  ::proto::TransactionGetRecordResponse* mutable_transactiongetrecord();
  void set_allocated_transactiongetrecord(::proto::TransactionGetRecordResponse* transactiongetrecord);
  private:
  const ::proto::TransactionGetRecordResponse& _internal_transactiongetrecord() const;
  ::proto::TransactionGetRecordResponse* _internal_mutable_transactiongetrecord();
  public:
  void unsafe_arena_set_allocated_transactiongetrecord(
      ::proto::TransactionGetRecordResponse* transactiongetrecord);
  ::proto::TransactionGetRecordResponse* unsafe_arena_release_transactiongetrecord();

  // .proto.TransactionGetFastRecordResponse transactionGetFastRecord = 16;
  bool has_transactiongetfastrecord() const;
  private:
  bool _internal_has_transactiongetfastrecord() const;
  public:
  void clear_transactiongetfastrecord();
  const ::proto::TransactionGetFastRecordResponse& transactiongetfastrecord() const;
  PROTOBUF_NODISCARD ::proto::TransactionGetFastRecordResponse* release_transactiongetfastrecord();
  ::proto::TransactionGetFastRecordResponse* mutable_transactiongetfastrecord();
  void set_allocated_transactiongetfastrecord(::proto::TransactionGetFastRecordResponse* transactiongetfastrecord);
  private:
  const ::proto::TransactionGetFastRecordResponse& _internal_transactiongetfastrecord() const;
  ::proto::TransactionGetFastRecordResponse* _internal_mutable_transactiongetfastrecord();
  public:
  void unsafe_arena_set_allocated_transactiongetfastrecord(
      ::proto::TransactionGetFastRecordResponse* transactiongetfastrecord);
  ::proto::TransactionGetFastRecordResponse* unsafe_arena_release_transactiongetfastrecord();

  // .proto.ConsensusGetTopicInfoResponse consensusGetTopicInfo = 150;
  bool has_consensusgettopicinfo() const;
  private:
  bool _internal_has_consensusgettopicinfo() const;
  public:
  void clear_consensusgettopicinfo();
  const ::proto::ConsensusGetTopicInfoResponse& consensusgettopicinfo() const;
  PROTOBUF_NODISCARD ::proto::ConsensusGetTopicInfoResponse* release_consensusgettopicinfo();
  ::proto::ConsensusGetTopicInfoResponse* mutable_consensusgettopicinfo();
  void set_allocated_consensusgettopicinfo(::proto::ConsensusGetTopicInfoResponse* consensusgettopicinfo);
  private:
  const ::proto::ConsensusGetTopicInfoResponse& _internal_consensusgettopicinfo() const;
  ::proto::ConsensusGetTopicInfoResponse* _internal_mutable_consensusgettopicinfo();
  public:
  void unsafe_arena_set_allocated_consensusgettopicinfo(
      ::proto::ConsensusGetTopicInfoResponse* consensusgettopicinfo);
  ::proto::ConsensusGetTopicInfoResponse* unsafe_arena_release_consensusgettopicinfo();

  // .proto.NetworkGetVersionInfoResponse networkGetVersionInfo = 151;
  bool has_networkgetversioninfo() const;
  private:
  bool _internal_has_networkgetversioninfo() const;
  public:
  void clear_networkgetversioninfo();
  const ::proto::NetworkGetVersionInfoResponse& networkgetversioninfo() const;
  PROTOBUF_NODISCARD ::proto::NetworkGetVersionInfoResponse* release_networkgetversioninfo();
  ::proto::NetworkGetVersionInfoResponse* mutable_networkgetversioninfo();
  void set_allocated_networkgetversioninfo(::proto::NetworkGetVersionInfoResponse* networkgetversioninfo);
  private:
  const ::proto::NetworkGetVersionInfoResponse& _internal_networkgetversioninfo() const;
  ::proto::NetworkGetVersionInfoResponse* _internal_mutable_networkgetversioninfo();
  public:
  void unsafe_arena_set_allocated_networkgetversioninfo(
      ::proto::NetworkGetVersionInfoResponse* networkgetversioninfo);
  ::proto::NetworkGetVersionInfoResponse* unsafe_arena_release_networkgetversioninfo();

  // .proto.TokenGetInfoResponse tokenGetInfo = 152;
  bool has_tokengetinfo() const;
  private:
  bool _internal_has_tokengetinfo() const;
  public:
  void clear_tokengetinfo();
  const ::proto::TokenGetInfoResponse& tokengetinfo() const;
  PROTOBUF_NODISCARD ::proto::TokenGetInfoResponse* release_tokengetinfo();
  ::proto::TokenGetInfoResponse* mutable_tokengetinfo();
  void set_allocated_tokengetinfo(::proto::TokenGetInfoResponse* tokengetinfo);
  private:
  const ::proto::TokenGetInfoResponse& _internal_tokengetinfo() const;
  ::proto::TokenGetInfoResponse* _internal_mutable_tokengetinfo();
  public:
  void unsafe_arena_set_allocated_tokengetinfo(
      ::proto::TokenGetInfoResponse* tokengetinfo);
  ::proto::TokenGetInfoResponse* unsafe_arena_release_tokengetinfo();

  // .proto.ScheduleGetInfoResponse scheduleGetInfo = 153;
  bool has_schedulegetinfo() const;
  private:
  bool _internal_has_schedulegetinfo() const;
  public:
  void clear_schedulegetinfo();
  const ::proto::ScheduleGetInfoResponse& schedulegetinfo() const;
  PROTOBUF_NODISCARD ::proto::ScheduleGetInfoResponse* release_schedulegetinfo();
  ::proto::ScheduleGetInfoResponse* mutable_schedulegetinfo();
  void set_allocated_schedulegetinfo(::proto::ScheduleGetInfoResponse* schedulegetinfo);
  private:
  const ::proto::ScheduleGetInfoResponse& _internal_schedulegetinfo() const;
  ::proto::ScheduleGetInfoResponse* _internal_mutable_schedulegetinfo();
  public:
  void unsafe_arena_set_allocated_schedulegetinfo(
      ::proto::ScheduleGetInfoResponse* schedulegetinfo);
  ::proto::ScheduleGetInfoResponse* unsafe_arena_release_schedulegetinfo();

  // .proto.TokenGetAccountNftInfosResponse tokenGetAccountNftInfos = 154;
  bool has_tokengetaccountnftinfos() const;
  private:
  bool _internal_has_tokengetaccountnftinfos() const;
  public:
  void clear_tokengetaccountnftinfos();
  const ::proto::TokenGetAccountNftInfosResponse& tokengetaccountnftinfos() const;
  PROTOBUF_NODISCARD ::proto::TokenGetAccountNftInfosResponse* release_tokengetaccountnftinfos();
  ::proto::TokenGetAccountNftInfosResponse* mutable_tokengetaccountnftinfos();
  void set_allocated_tokengetaccountnftinfos(::proto::TokenGetAccountNftInfosResponse* tokengetaccountnftinfos);
  private:
  const ::proto::TokenGetAccountNftInfosResponse& _internal_tokengetaccountnftinfos() const;
  ::proto::TokenGetAccountNftInfosResponse* _internal_mutable_tokengetaccountnftinfos();
  public:
  void unsafe_arena_set_allocated_tokengetaccountnftinfos(
      ::proto::TokenGetAccountNftInfosResponse* tokengetaccountnftinfos);
  ::proto::TokenGetAccountNftInfosResponse* unsafe_arena_release_tokengetaccountnftinfos();

  // .proto.TokenGetNftInfoResponse tokenGetNftInfo = 155;
  bool has_tokengetnftinfo() const;
  private:
  bool _internal_has_tokengetnftinfo() const;
  public:
  void clear_tokengetnftinfo();
  const ::proto::TokenGetNftInfoResponse& tokengetnftinfo() const;
  PROTOBUF_NODISCARD ::proto::TokenGetNftInfoResponse* release_tokengetnftinfo();
  ::proto::TokenGetNftInfoResponse* mutable_tokengetnftinfo();
  void set_allocated_tokengetnftinfo(::proto::TokenGetNftInfoResponse* tokengetnftinfo);
  private:
  const ::proto::TokenGetNftInfoResponse& _internal_tokengetnftinfo() const;
  ::proto::TokenGetNftInfoResponse* _internal_mutable_tokengetnftinfo();
  public:
  void unsafe_arena_set_allocated_tokengetnftinfo(
      ::proto::TokenGetNftInfoResponse* tokengetnftinfo);
  ::proto::TokenGetNftInfoResponse* unsafe_arena_release_tokengetnftinfo();

  // .proto.TokenGetNftInfosResponse tokenGetNftInfos = 156;
  bool has_tokengetnftinfos() const;
  private:
  bool _internal_has_tokengetnftinfos() const;
  public:
  void clear_tokengetnftinfos();
  const ::proto::TokenGetNftInfosResponse& tokengetnftinfos() const;
  PROTOBUF_NODISCARD ::proto::TokenGetNftInfosResponse* release_tokengetnftinfos();
  ::proto::TokenGetNftInfosResponse* mutable_tokengetnftinfos();
  void set_allocated_tokengetnftinfos(::proto::TokenGetNftInfosResponse* tokengetnftinfos);
  private:
  const ::proto::TokenGetNftInfosResponse& _internal_tokengetnftinfos() const;
  ::proto::TokenGetNftInfosResponse* _internal_mutable_tokengetnftinfos();
  public:
  void unsafe_arena_set_allocated_tokengetnftinfos(
      ::proto::TokenGetNftInfosResponse* tokengetnftinfos);
  ::proto::TokenGetNftInfosResponse* unsafe_arena_release_tokengetnftinfos();

  // .proto.NetworkGetExecutionTimeResponse networkGetExecutionTime = 157;
  bool has_networkgetexecutiontime() const;
  private:
  bool _internal_has_networkgetexecutiontime() const;
  public:
  void clear_networkgetexecutiontime();
  const ::proto::NetworkGetExecutionTimeResponse& networkgetexecutiontime() const;
  PROTOBUF_NODISCARD ::proto::NetworkGetExecutionTimeResponse* release_networkgetexecutiontime();
  ::proto::NetworkGetExecutionTimeResponse* mutable_networkgetexecutiontime();
  void set_allocated_networkgetexecutiontime(::proto::NetworkGetExecutionTimeResponse* networkgetexecutiontime);
  private:
  const ::proto::NetworkGetExecutionTimeResponse& _internal_networkgetexecutiontime() const;
  ::proto::NetworkGetExecutionTimeResponse* _internal_mutable_networkgetexecutiontime();
  public:
  void unsafe_arena_set_allocated_networkgetexecutiontime(
      ::proto::NetworkGetExecutionTimeResponse* networkgetexecutiontime);
  ::proto::NetworkGetExecutionTimeResponse* unsafe_arena_release_networkgetexecutiontime();

  // .proto.GetAccountDetailsResponse accountDetails = 158;
  bool has_accountdetails() const;
  private:
  bool _internal_has_accountdetails() const;
  public:
  void clear_accountdetails();
  const ::proto::GetAccountDetailsResponse& accountdetails() const;
  PROTOBUF_NODISCARD ::proto::GetAccountDetailsResponse* release_accountdetails();
  ::proto::GetAccountDetailsResponse* mutable_accountdetails();
  void set_allocated_accountdetails(::proto::GetAccountDetailsResponse* accountdetails);
  private:
  const ::proto::GetAccountDetailsResponse& _internal_accountdetails() const;
  ::proto::GetAccountDetailsResponse* _internal_mutable_accountdetails();
  public:
  void unsafe_arena_set_allocated_accountdetails(
      ::proto::GetAccountDetailsResponse* accountdetails);
  ::proto::GetAccountDetailsResponse* unsafe_arena_release_accountdetails();

  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:proto.Response)
 private:
  class _Internal;
  void set_has_getbykey();
  void set_has_getbysolidityid();
  void set_has_contractcalllocal();
  void set_has_contractgetbytecoderesponse();
  void set_has_contractgetinfo();
  void set_has_contractgetrecordsresponse();
  void set_has_cryptogetaccountbalance();
  void set_has_cryptogetaccountrecords();
  void set_has_cryptogetinfo();
  void set_has_cryptogetlivehash();
  void set_has_cryptogetproxystakers();
  void set_has_filegetcontents();
  void set_has_filegetinfo();
  void set_has_transactiongetreceipt();
  void set_has_transactiongetrecord();
  void set_has_transactiongetfastrecord();
  void set_has_consensusgettopicinfo();
  void set_has_networkgetversioninfo();
  void set_has_tokengetinfo();
  void set_has_schedulegetinfo();
  void set_has_tokengetaccountnftinfos();
  void set_has_tokengetnftinfo();
  void set_has_tokengetnftinfos();
  void set_has_networkgetexecutiontime();
  void set_has_accountdetails();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResponseUnion {
      constexpr ResponseUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::proto::GetByKeyResponse* getbykey_;
      ::proto::GetBySolidityIDResponse* getbysolidityid_;
      ::proto::ContractCallLocalResponse* contractcalllocal_;
      ::proto::ContractGetBytecodeResponse* contractgetbytecoderesponse_;
      ::proto::ContractGetInfoResponse* contractgetinfo_;
      ::proto::ContractGetRecordsResponse* contractgetrecordsresponse_;
      ::proto::CryptoGetAccountBalanceResponse* cryptogetaccountbalance_;
      ::proto::CryptoGetAccountRecordsResponse* cryptogetaccountrecords_;
      ::proto::CryptoGetInfoResponse* cryptogetinfo_;
      ::proto::CryptoGetLiveHashResponse* cryptogetlivehash_;
      ::proto::CryptoGetStakersResponse* cryptogetproxystakers_;
      ::proto::FileGetContentsResponse* filegetcontents_;
      ::proto::FileGetInfoResponse* filegetinfo_;
      ::proto::TransactionGetReceiptResponse* transactiongetreceipt_;
      ::proto::TransactionGetRecordResponse* transactiongetrecord_;
      ::proto::TransactionGetFastRecordResponse* transactiongetfastrecord_;
      ::proto::ConsensusGetTopicInfoResponse* consensusgettopicinfo_;
      ::proto::NetworkGetVersionInfoResponse* networkgetversioninfo_;
      ::proto::TokenGetInfoResponse* tokengetinfo_;
      ::proto::ScheduleGetInfoResponse* schedulegetinfo_;
      ::proto::TokenGetAccountNftInfosResponse* tokengetaccountnftinfos_;
      ::proto::TokenGetNftInfoResponse* tokengetnftinfo_;
      ::proto::TokenGetNftInfosResponse* tokengetnftinfos_;
      ::proto::NetworkGetExecutionTimeResponse* networkgetexecutiontime_;
      ::proto::GetAccountDetailsResponse* accountdetails_;
    } response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_response_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Response

// .proto.GetByKeyResponse getByKey = 1;
inline bool Response::_internal_has_getbykey() const {
  return response_case() == kGetByKey;
}
inline bool Response::has_getbykey() const {
  return _internal_has_getbykey();
}
inline void Response::set_has_getbykey() {
  _impl_._oneof_case_[0] = kGetByKey;
}
inline ::proto::GetByKeyResponse* Response::release_getbykey() {
  // @@protoc_insertion_point(field_release:proto.Response.getByKey)
  if (_internal_has_getbykey()) {
    clear_has_response();
    ::proto::GetByKeyResponse* temp = _impl_.response_.getbykey_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.getbykey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::GetByKeyResponse& Response::_internal_getbykey() const {
  return _internal_has_getbykey()
      ? *_impl_.response_.getbykey_
      : reinterpret_cast< ::proto::GetByKeyResponse&>(::proto::_GetByKeyResponse_default_instance_);
}
inline const ::proto::GetByKeyResponse& Response::getbykey() const {
  // @@protoc_insertion_point(field_get:proto.Response.getByKey)
  return _internal_getbykey();
}
inline ::proto::GetByKeyResponse* Response::unsafe_arena_release_getbykey() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.getByKey)
  if (_internal_has_getbykey()) {
    clear_has_response();
    ::proto::GetByKeyResponse* temp = _impl_.response_.getbykey_;
    _impl_.response_.getbykey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_getbykey(::proto::GetByKeyResponse* getbykey) {
  clear_response();
  if (getbykey) {
    set_has_getbykey();
    _impl_.response_.getbykey_ = getbykey;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.getByKey)
}
inline ::proto::GetByKeyResponse* Response::_internal_mutable_getbykey() {
  if (!_internal_has_getbykey()) {
    clear_response();
    set_has_getbykey();
    _impl_.response_.getbykey_ = CreateMaybeMessage< ::proto::GetByKeyResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.getbykey_;
}
inline ::proto::GetByKeyResponse* Response::mutable_getbykey() {
  ::proto::GetByKeyResponse* _msg = _internal_mutable_getbykey();
  // @@protoc_insertion_point(field_mutable:proto.Response.getByKey)
  return _msg;
}

// .proto.GetBySolidityIDResponse getBySolidityID = 2;
inline bool Response::_internal_has_getbysolidityid() const {
  return response_case() == kGetBySolidityID;
}
inline bool Response::has_getbysolidityid() const {
  return _internal_has_getbysolidityid();
}
inline void Response::set_has_getbysolidityid() {
  _impl_._oneof_case_[0] = kGetBySolidityID;
}
inline ::proto::GetBySolidityIDResponse* Response::release_getbysolidityid() {
  // @@protoc_insertion_point(field_release:proto.Response.getBySolidityID)
  if (_internal_has_getbysolidityid()) {
    clear_has_response();
    ::proto::GetBySolidityIDResponse* temp = _impl_.response_.getbysolidityid_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.getbysolidityid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::GetBySolidityIDResponse& Response::_internal_getbysolidityid() const {
  return _internal_has_getbysolidityid()
      ? *_impl_.response_.getbysolidityid_
      : reinterpret_cast< ::proto::GetBySolidityIDResponse&>(::proto::_GetBySolidityIDResponse_default_instance_);
}
inline const ::proto::GetBySolidityIDResponse& Response::getbysolidityid() const {
  // @@protoc_insertion_point(field_get:proto.Response.getBySolidityID)
  return _internal_getbysolidityid();
}
inline ::proto::GetBySolidityIDResponse* Response::unsafe_arena_release_getbysolidityid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.getBySolidityID)
  if (_internal_has_getbysolidityid()) {
    clear_has_response();
    ::proto::GetBySolidityIDResponse* temp = _impl_.response_.getbysolidityid_;
    _impl_.response_.getbysolidityid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_getbysolidityid(::proto::GetBySolidityIDResponse* getbysolidityid) {
  clear_response();
  if (getbysolidityid) {
    set_has_getbysolidityid();
    _impl_.response_.getbysolidityid_ = getbysolidityid;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.getBySolidityID)
}
inline ::proto::GetBySolidityIDResponse* Response::_internal_mutable_getbysolidityid() {
  if (!_internal_has_getbysolidityid()) {
    clear_response();
    set_has_getbysolidityid();
    _impl_.response_.getbysolidityid_ = CreateMaybeMessage< ::proto::GetBySolidityIDResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.getbysolidityid_;
}
inline ::proto::GetBySolidityIDResponse* Response::mutable_getbysolidityid() {
  ::proto::GetBySolidityIDResponse* _msg = _internal_mutable_getbysolidityid();
  // @@protoc_insertion_point(field_mutable:proto.Response.getBySolidityID)
  return _msg;
}

// .proto.ContractCallLocalResponse contractCallLocal = 3;
inline bool Response::_internal_has_contractcalllocal() const {
  return response_case() == kContractCallLocal;
}
inline bool Response::has_contractcalllocal() const {
  return _internal_has_contractcalllocal();
}
inline void Response::set_has_contractcalllocal() {
  _impl_._oneof_case_[0] = kContractCallLocal;
}
inline ::proto::ContractCallLocalResponse* Response::release_contractcalllocal() {
  // @@protoc_insertion_point(field_release:proto.Response.contractCallLocal)
  if (_internal_has_contractcalllocal()) {
    clear_has_response();
    ::proto::ContractCallLocalResponse* temp = _impl_.response_.contractcalllocal_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.contractcalllocal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ContractCallLocalResponse& Response::_internal_contractcalllocal() const {
  return _internal_has_contractcalllocal()
      ? *_impl_.response_.contractcalllocal_
      : reinterpret_cast< ::proto::ContractCallLocalResponse&>(::proto::_ContractCallLocalResponse_default_instance_);
}
inline const ::proto::ContractCallLocalResponse& Response::contractcalllocal() const {
  // @@protoc_insertion_point(field_get:proto.Response.contractCallLocal)
  return _internal_contractcalllocal();
}
inline ::proto::ContractCallLocalResponse* Response::unsafe_arena_release_contractcalllocal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.contractCallLocal)
  if (_internal_has_contractcalllocal()) {
    clear_has_response();
    ::proto::ContractCallLocalResponse* temp = _impl_.response_.contractcalllocal_;
    _impl_.response_.contractcalllocal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_contractcalllocal(::proto::ContractCallLocalResponse* contractcalllocal) {
  clear_response();
  if (contractcalllocal) {
    set_has_contractcalllocal();
    _impl_.response_.contractcalllocal_ = contractcalllocal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.contractCallLocal)
}
inline ::proto::ContractCallLocalResponse* Response::_internal_mutable_contractcalllocal() {
  if (!_internal_has_contractcalllocal()) {
    clear_response();
    set_has_contractcalllocal();
    _impl_.response_.contractcalllocal_ = CreateMaybeMessage< ::proto::ContractCallLocalResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.contractcalllocal_;
}
inline ::proto::ContractCallLocalResponse* Response::mutable_contractcalllocal() {
  ::proto::ContractCallLocalResponse* _msg = _internal_mutable_contractcalllocal();
  // @@protoc_insertion_point(field_mutable:proto.Response.contractCallLocal)
  return _msg;
}

// .proto.ContractGetBytecodeResponse contractGetBytecodeResponse = 5;
inline bool Response::_internal_has_contractgetbytecoderesponse() const {
  return response_case() == kContractGetBytecodeResponse;
}
inline bool Response::has_contractgetbytecoderesponse() const {
  return _internal_has_contractgetbytecoderesponse();
}
inline void Response::set_has_contractgetbytecoderesponse() {
  _impl_._oneof_case_[0] = kContractGetBytecodeResponse;
}
inline ::proto::ContractGetBytecodeResponse* Response::release_contractgetbytecoderesponse() {
  // @@protoc_insertion_point(field_release:proto.Response.contractGetBytecodeResponse)
  if (_internal_has_contractgetbytecoderesponse()) {
    clear_has_response();
    ::proto::ContractGetBytecodeResponse* temp = _impl_.response_.contractgetbytecoderesponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.contractgetbytecoderesponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ContractGetBytecodeResponse& Response::_internal_contractgetbytecoderesponse() const {
  return _internal_has_contractgetbytecoderesponse()
      ? *_impl_.response_.contractgetbytecoderesponse_
      : reinterpret_cast< ::proto::ContractGetBytecodeResponse&>(::proto::_ContractGetBytecodeResponse_default_instance_);
}
inline const ::proto::ContractGetBytecodeResponse& Response::contractgetbytecoderesponse() const {
  // @@protoc_insertion_point(field_get:proto.Response.contractGetBytecodeResponse)
  return _internal_contractgetbytecoderesponse();
}
inline ::proto::ContractGetBytecodeResponse* Response::unsafe_arena_release_contractgetbytecoderesponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.contractGetBytecodeResponse)
  if (_internal_has_contractgetbytecoderesponse()) {
    clear_has_response();
    ::proto::ContractGetBytecodeResponse* temp = _impl_.response_.contractgetbytecoderesponse_;
    _impl_.response_.contractgetbytecoderesponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_contractgetbytecoderesponse(::proto::ContractGetBytecodeResponse* contractgetbytecoderesponse) {
  clear_response();
  if (contractgetbytecoderesponse) {
    set_has_contractgetbytecoderesponse();
    _impl_.response_.contractgetbytecoderesponse_ = contractgetbytecoderesponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.contractGetBytecodeResponse)
}
inline ::proto::ContractGetBytecodeResponse* Response::_internal_mutable_contractgetbytecoderesponse() {
  if (!_internal_has_contractgetbytecoderesponse()) {
    clear_response();
    set_has_contractgetbytecoderesponse();
    _impl_.response_.contractgetbytecoderesponse_ = CreateMaybeMessage< ::proto::ContractGetBytecodeResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.contractgetbytecoderesponse_;
}
inline ::proto::ContractGetBytecodeResponse* Response::mutable_contractgetbytecoderesponse() {
  ::proto::ContractGetBytecodeResponse* _msg = _internal_mutable_contractgetbytecoderesponse();
  // @@protoc_insertion_point(field_mutable:proto.Response.contractGetBytecodeResponse)
  return _msg;
}

// .proto.ContractGetInfoResponse contractGetInfo = 4;
inline bool Response::_internal_has_contractgetinfo() const {
  return response_case() == kContractGetInfo;
}
inline bool Response::has_contractgetinfo() const {
  return _internal_has_contractgetinfo();
}
inline void Response::set_has_contractgetinfo() {
  _impl_._oneof_case_[0] = kContractGetInfo;
}
inline ::proto::ContractGetInfoResponse* Response::release_contractgetinfo() {
  // @@protoc_insertion_point(field_release:proto.Response.contractGetInfo)
  if (_internal_has_contractgetinfo()) {
    clear_has_response();
    ::proto::ContractGetInfoResponse* temp = _impl_.response_.contractgetinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.contractgetinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ContractGetInfoResponse& Response::_internal_contractgetinfo() const {
  return _internal_has_contractgetinfo()
      ? *_impl_.response_.contractgetinfo_
      : reinterpret_cast< ::proto::ContractGetInfoResponse&>(::proto::_ContractGetInfoResponse_default_instance_);
}
inline const ::proto::ContractGetInfoResponse& Response::contractgetinfo() const {
  // @@protoc_insertion_point(field_get:proto.Response.contractGetInfo)
  return _internal_contractgetinfo();
}
inline ::proto::ContractGetInfoResponse* Response::unsafe_arena_release_contractgetinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.contractGetInfo)
  if (_internal_has_contractgetinfo()) {
    clear_has_response();
    ::proto::ContractGetInfoResponse* temp = _impl_.response_.contractgetinfo_;
    _impl_.response_.contractgetinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_contractgetinfo(::proto::ContractGetInfoResponse* contractgetinfo) {
  clear_response();
  if (contractgetinfo) {
    set_has_contractgetinfo();
    _impl_.response_.contractgetinfo_ = contractgetinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.contractGetInfo)
}
inline ::proto::ContractGetInfoResponse* Response::_internal_mutable_contractgetinfo() {
  if (!_internal_has_contractgetinfo()) {
    clear_response();
    set_has_contractgetinfo();
    _impl_.response_.contractgetinfo_ = CreateMaybeMessage< ::proto::ContractGetInfoResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.contractgetinfo_;
}
inline ::proto::ContractGetInfoResponse* Response::mutable_contractgetinfo() {
  ::proto::ContractGetInfoResponse* _msg = _internal_mutable_contractgetinfo();
  // @@protoc_insertion_point(field_mutable:proto.Response.contractGetInfo)
  return _msg;
}

// .proto.ContractGetRecordsResponse contractGetRecordsResponse = 6;
inline bool Response::_internal_has_contractgetrecordsresponse() const {
  return response_case() == kContractGetRecordsResponse;
}
inline bool Response::has_contractgetrecordsresponse() const {
  return _internal_has_contractgetrecordsresponse();
}
inline void Response::set_has_contractgetrecordsresponse() {
  _impl_._oneof_case_[0] = kContractGetRecordsResponse;
}
inline ::proto::ContractGetRecordsResponse* Response::release_contractgetrecordsresponse() {
  // @@protoc_insertion_point(field_release:proto.Response.contractGetRecordsResponse)
  if (_internal_has_contractgetrecordsresponse()) {
    clear_has_response();
    ::proto::ContractGetRecordsResponse* temp = _impl_.response_.contractgetrecordsresponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.contractgetrecordsresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ContractGetRecordsResponse& Response::_internal_contractgetrecordsresponse() const {
  return _internal_has_contractgetrecordsresponse()
      ? *_impl_.response_.contractgetrecordsresponse_
      : reinterpret_cast< ::proto::ContractGetRecordsResponse&>(::proto::_ContractGetRecordsResponse_default_instance_);
}
inline const ::proto::ContractGetRecordsResponse& Response::contractgetrecordsresponse() const {
  // @@protoc_insertion_point(field_get:proto.Response.contractGetRecordsResponse)
  return _internal_contractgetrecordsresponse();
}
inline ::proto::ContractGetRecordsResponse* Response::unsafe_arena_release_contractgetrecordsresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.contractGetRecordsResponse)
  if (_internal_has_contractgetrecordsresponse()) {
    clear_has_response();
    ::proto::ContractGetRecordsResponse* temp = _impl_.response_.contractgetrecordsresponse_;
    _impl_.response_.contractgetrecordsresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_contractgetrecordsresponse(::proto::ContractGetRecordsResponse* contractgetrecordsresponse) {
  clear_response();
  if (contractgetrecordsresponse) {
    set_has_contractgetrecordsresponse();
    _impl_.response_.contractgetrecordsresponse_ = contractgetrecordsresponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.contractGetRecordsResponse)
}
inline ::proto::ContractGetRecordsResponse* Response::_internal_mutable_contractgetrecordsresponse() {
  if (!_internal_has_contractgetrecordsresponse()) {
    clear_response();
    set_has_contractgetrecordsresponse();
    _impl_.response_.contractgetrecordsresponse_ = CreateMaybeMessage< ::proto::ContractGetRecordsResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.contractgetrecordsresponse_;
}
inline ::proto::ContractGetRecordsResponse* Response::mutable_contractgetrecordsresponse() {
  ::proto::ContractGetRecordsResponse* _msg = _internal_mutable_contractgetrecordsresponse();
  // @@protoc_insertion_point(field_mutable:proto.Response.contractGetRecordsResponse)
  return _msg;
}

// .proto.CryptoGetAccountBalanceResponse cryptogetAccountBalance = 7;
inline bool Response::_internal_has_cryptogetaccountbalance() const {
  return response_case() == kCryptogetAccountBalance;
}
inline bool Response::has_cryptogetaccountbalance() const {
  return _internal_has_cryptogetaccountbalance();
}
inline void Response::set_has_cryptogetaccountbalance() {
  _impl_._oneof_case_[0] = kCryptogetAccountBalance;
}
inline ::proto::CryptoGetAccountBalanceResponse* Response::release_cryptogetaccountbalance() {
  // @@protoc_insertion_point(field_release:proto.Response.cryptogetAccountBalance)
  if (_internal_has_cryptogetaccountbalance()) {
    clear_has_response();
    ::proto::CryptoGetAccountBalanceResponse* temp = _impl_.response_.cryptogetaccountbalance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.cryptogetaccountbalance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::CryptoGetAccountBalanceResponse& Response::_internal_cryptogetaccountbalance() const {
  return _internal_has_cryptogetaccountbalance()
      ? *_impl_.response_.cryptogetaccountbalance_
      : reinterpret_cast< ::proto::CryptoGetAccountBalanceResponse&>(::proto::_CryptoGetAccountBalanceResponse_default_instance_);
}
inline const ::proto::CryptoGetAccountBalanceResponse& Response::cryptogetaccountbalance() const {
  // @@protoc_insertion_point(field_get:proto.Response.cryptogetAccountBalance)
  return _internal_cryptogetaccountbalance();
}
inline ::proto::CryptoGetAccountBalanceResponse* Response::unsafe_arena_release_cryptogetaccountbalance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.cryptogetAccountBalance)
  if (_internal_has_cryptogetaccountbalance()) {
    clear_has_response();
    ::proto::CryptoGetAccountBalanceResponse* temp = _impl_.response_.cryptogetaccountbalance_;
    _impl_.response_.cryptogetaccountbalance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_cryptogetaccountbalance(::proto::CryptoGetAccountBalanceResponse* cryptogetaccountbalance) {
  clear_response();
  if (cryptogetaccountbalance) {
    set_has_cryptogetaccountbalance();
    _impl_.response_.cryptogetaccountbalance_ = cryptogetaccountbalance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.cryptogetAccountBalance)
}
inline ::proto::CryptoGetAccountBalanceResponse* Response::_internal_mutable_cryptogetaccountbalance() {
  if (!_internal_has_cryptogetaccountbalance()) {
    clear_response();
    set_has_cryptogetaccountbalance();
    _impl_.response_.cryptogetaccountbalance_ = CreateMaybeMessage< ::proto::CryptoGetAccountBalanceResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.cryptogetaccountbalance_;
}
inline ::proto::CryptoGetAccountBalanceResponse* Response::mutable_cryptogetaccountbalance() {
  ::proto::CryptoGetAccountBalanceResponse* _msg = _internal_mutable_cryptogetaccountbalance();
  // @@protoc_insertion_point(field_mutable:proto.Response.cryptogetAccountBalance)
  return _msg;
}

// .proto.CryptoGetAccountRecordsResponse cryptoGetAccountRecords = 8;
inline bool Response::_internal_has_cryptogetaccountrecords() const {
  return response_case() == kCryptoGetAccountRecords;
}
inline bool Response::has_cryptogetaccountrecords() const {
  return _internal_has_cryptogetaccountrecords();
}
inline void Response::set_has_cryptogetaccountrecords() {
  _impl_._oneof_case_[0] = kCryptoGetAccountRecords;
}
inline ::proto::CryptoGetAccountRecordsResponse* Response::release_cryptogetaccountrecords() {
  // @@protoc_insertion_point(field_release:proto.Response.cryptoGetAccountRecords)
  if (_internal_has_cryptogetaccountrecords()) {
    clear_has_response();
    ::proto::CryptoGetAccountRecordsResponse* temp = _impl_.response_.cryptogetaccountrecords_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.cryptogetaccountrecords_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::CryptoGetAccountRecordsResponse& Response::_internal_cryptogetaccountrecords() const {
  return _internal_has_cryptogetaccountrecords()
      ? *_impl_.response_.cryptogetaccountrecords_
      : reinterpret_cast< ::proto::CryptoGetAccountRecordsResponse&>(::proto::_CryptoGetAccountRecordsResponse_default_instance_);
}
inline const ::proto::CryptoGetAccountRecordsResponse& Response::cryptogetaccountrecords() const {
  // @@protoc_insertion_point(field_get:proto.Response.cryptoGetAccountRecords)
  return _internal_cryptogetaccountrecords();
}
inline ::proto::CryptoGetAccountRecordsResponse* Response::unsafe_arena_release_cryptogetaccountrecords() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.cryptoGetAccountRecords)
  if (_internal_has_cryptogetaccountrecords()) {
    clear_has_response();
    ::proto::CryptoGetAccountRecordsResponse* temp = _impl_.response_.cryptogetaccountrecords_;
    _impl_.response_.cryptogetaccountrecords_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_cryptogetaccountrecords(::proto::CryptoGetAccountRecordsResponse* cryptogetaccountrecords) {
  clear_response();
  if (cryptogetaccountrecords) {
    set_has_cryptogetaccountrecords();
    _impl_.response_.cryptogetaccountrecords_ = cryptogetaccountrecords;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.cryptoGetAccountRecords)
}
inline ::proto::CryptoGetAccountRecordsResponse* Response::_internal_mutable_cryptogetaccountrecords() {
  if (!_internal_has_cryptogetaccountrecords()) {
    clear_response();
    set_has_cryptogetaccountrecords();
    _impl_.response_.cryptogetaccountrecords_ = CreateMaybeMessage< ::proto::CryptoGetAccountRecordsResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.cryptogetaccountrecords_;
}
inline ::proto::CryptoGetAccountRecordsResponse* Response::mutable_cryptogetaccountrecords() {
  ::proto::CryptoGetAccountRecordsResponse* _msg = _internal_mutable_cryptogetaccountrecords();
  // @@protoc_insertion_point(field_mutable:proto.Response.cryptoGetAccountRecords)
  return _msg;
}

// .proto.CryptoGetInfoResponse cryptoGetInfo = 9;
inline bool Response::_internal_has_cryptogetinfo() const {
  return response_case() == kCryptoGetInfo;
}
inline bool Response::has_cryptogetinfo() const {
  return _internal_has_cryptogetinfo();
}
inline void Response::set_has_cryptogetinfo() {
  _impl_._oneof_case_[0] = kCryptoGetInfo;
}
inline ::proto::CryptoGetInfoResponse* Response::release_cryptogetinfo() {
  // @@protoc_insertion_point(field_release:proto.Response.cryptoGetInfo)
  if (_internal_has_cryptogetinfo()) {
    clear_has_response();
    ::proto::CryptoGetInfoResponse* temp = _impl_.response_.cryptogetinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.cryptogetinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::CryptoGetInfoResponse& Response::_internal_cryptogetinfo() const {
  return _internal_has_cryptogetinfo()
      ? *_impl_.response_.cryptogetinfo_
      : reinterpret_cast< ::proto::CryptoGetInfoResponse&>(::proto::_CryptoGetInfoResponse_default_instance_);
}
inline const ::proto::CryptoGetInfoResponse& Response::cryptogetinfo() const {
  // @@protoc_insertion_point(field_get:proto.Response.cryptoGetInfo)
  return _internal_cryptogetinfo();
}
inline ::proto::CryptoGetInfoResponse* Response::unsafe_arena_release_cryptogetinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.cryptoGetInfo)
  if (_internal_has_cryptogetinfo()) {
    clear_has_response();
    ::proto::CryptoGetInfoResponse* temp = _impl_.response_.cryptogetinfo_;
    _impl_.response_.cryptogetinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_cryptogetinfo(::proto::CryptoGetInfoResponse* cryptogetinfo) {
  clear_response();
  if (cryptogetinfo) {
    set_has_cryptogetinfo();
    _impl_.response_.cryptogetinfo_ = cryptogetinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.cryptoGetInfo)
}
inline ::proto::CryptoGetInfoResponse* Response::_internal_mutable_cryptogetinfo() {
  if (!_internal_has_cryptogetinfo()) {
    clear_response();
    set_has_cryptogetinfo();
    _impl_.response_.cryptogetinfo_ = CreateMaybeMessage< ::proto::CryptoGetInfoResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.cryptogetinfo_;
}
inline ::proto::CryptoGetInfoResponse* Response::mutable_cryptogetinfo() {
  ::proto::CryptoGetInfoResponse* _msg = _internal_mutable_cryptogetinfo();
  // @@protoc_insertion_point(field_mutable:proto.Response.cryptoGetInfo)
  return _msg;
}

// .proto.CryptoGetLiveHashResponse cryptoGetLiveHash = 10;
inline bool Response::_internal_has_cryptogetlivehash() const {
  return response_case() == kCryptoGetLiveHash;
}
inline bool Response::has_cryptogetlivehash() const {
  return _internal_has_cryptogetlivehash();
}
inline void Response::set_has_cryptogetlivehash() {
  _impl_._oneof_case_[0] = kCryptoGetLiveHash;
}
inline ::proto::CryptoGetLiveHashResponse* Response::release_cryptogetlivehash() {
  // @@protoc_insertion_point(field_release:proto.Response.cryptoGetLiveHash)
  if (_internal_has_cryptogetlivehash()) {
    clear_has_response();
    ::proto::CryptoGetLiveHashResponse* temp = _impl_.response_.cryptogetlivehash_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.cryptogetlivehash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::CryptoGetLiveHashResponse& Response::_internal_cryptogetlivehash() const {
  return _internal_has_cryptogetlivehash()
      ? *_impl_.response_.cryptogetlivehash_
      : reinterpret_cast< ::proto::CryptoGetLiveHashResponse&>(::proto::_CryptoGetLiveHashResponse_default_instance_);
}
inline const ::proto::CryptoGetLiveHashResponse& Response::cryptogetlivehash() const {
  // @@protoc_insertion_point(field_get:proto.Response.cryptoGetLiveHash)
  return _internal_cryptogetlivehash();
}
inline ::proto::CryptoGetLiveHashResponse* Response::unsafe_arena_release_cryptogetlivehash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.cryptoGetLiveHash)
  if (_internal_has_cryptogetlivehash()) {
    clear_has_response();
    ::proto::CryptoGetLiveHashResponse* temp = _impl_.response_.cryptogetlivehash_;
    _impl_.response_.cryptogetlivehash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_cryptogetlivehash(::proto::CryptoGetLiveHashResponse* cryptogetlivehash) {
  clear_response();
  if (cryptogetlivehash) {
    set_has_cryptogetlivehash();
    _impl_.response_.cryptogetlivehash_ = cryptogetlivehash;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.cryptoGetLiveHash)
}
inline ::proto::CryptoGetLiveHashResponse* Response::_internal_mutable_cryptogetlivehash() {
  if (!_internal_has_cryptogetlivehash()) {
    clear_response();
    set_has_cryptogetlivehash();
    _impl_.response_.cryptogetlivehash_ = CreateMaybeMessage< ::proto::CryptoGetLiveHashResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.cryptogetlivehash_;
}
inline ::proto::CryptoGetLiveHashResponse* Response::mutable_cryptogetlivehash() {
  ::proto::CryptoGetLiveHashResponse* _msg = _internal_mutable_cryptogetlivehash();
  // @@protoc_insertion_point(field_mutable:proto.Response.cryptoGetLiveHash)
  return _msg;
}

// .proto.CryptoGetStakersResponse cryptoGetProxyStakers = 11;
inline bool Response::_internal_has_cryptogetproxystakers() const {
  return response_case() == kCryptoGetProxyStakers;
}
inline bool Response::has_cryptogetproxystakers() const {
  return _internal_has_cryptogetproxystakers();
}
inline void Response::set_has_cryptogetproxystakers() {
  _impl_._oneof_case_[0] = kCryptoGetProxyStakers;
}
inline ::proto::CryptoGetStakersResponse* Response::release_cryptogetproxystakers() {
  // @@protoc_insertion_point(field_release:proto.Response.cryptoGetProxyStakers)
  if (_internal_has_cryptogetproxystakers()) {
    clear_has_response();
    ::proto::CryptoGetStakersResponse* temp = _impl_.response_.cryptogetproxystakers_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.cryptogetproxystakers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::CryptoGetStakersResponse& Response::_internal_cryptogetproxystakers() const {
  return _internal_has_cryptogetproxystakers()
      ? *_impl_.response_.cryptogetproxystakers_
      : reinterpret_cast< ::proto::CryptoGetStakersResponse&>(::proto::_CryptoGetStakersResponse_default_instance_);
}
inline const ::proto::CryptoGetStakersResponse& Response::cryptogetproxystakers() const {
  // @@protoc_insertion_point(field_get:proto.Response.cryptoGetProxyStakers)
  return _internal_cryptogetproxystakers();
}
inline ::proto::CryptoGetStakersResponse* Response::unsafe_arena_release_cryptogetproxystakers() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.cryptoGetProxyStakers)
  if (_internal_has_cryptogetproxystakers()) {
    clear_has_response();
    ::proto::CryptoGetStakersResponse* temp = _impl_.response_.cryptogetproxystakers_;
    _impl_.response_.cryptogetproxystakers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_cryptogetproxystakers(::proto::CryptoGetStakersResponse* cryptogetproxystakers) {
  clear_response();
  if (cryptogetproxystakers) {
    set_has_cryptogetproxystakers();
    _impl_.response_.cryptogetproxystakers_ = cryptogetproxystakers;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.cryptoGetProxyStakers)
}
inline ::proto::CryptoGetStakersResponse* Response::_internal_mutable_cryptogetproxystakers() {
  if (!_internal_has_cryptogetproxystakers()) {
    clear_response();
    set_has_cryptogetproxystakers();
    _impl_.response_.cryptogetproxystakers_ = CreateMaybeMessage< ::proto::CryptoGetStakersResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.cryptogetproxystakers_;
}
inline ::proto::CryptoGetStakersResponse* Response::mutable_cryptogetproxystakers() {
  ::proto::CryptoGetStakersResponse* _msg = _internal_mutable_cryptogetproxystakers();
  // @@protoc_insertion_point(field_mutable:proto.Response.cryptoGetProxyStakers)
  return _msg;
}

// .proto.FileGetContentsResponse fileGetContents = 12;
inline bool Response::_internal_has_filegetcontents() const {
  return response_case() == kFileGetContents;
}
inline bool Response::has_filegetcontents() const {
  return _internal_has_filegetcontents();
}
inline void Response::set_has_filegetcontents() {
  _impl_._oneof_case_[0] = kFileGetContents;
}
inline ::proto::FileGetContentsResponse* Response::release_filegetcontents() {
  // @@protoc_insertion_point(field_release:proto.Response.fileGetContents)
  if (_internal_has_filegetcontents()) {
    clear_has_response();
    ::proto::FileGetContentsResponse* temp = _impl_.response_.filegetcontents_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.filegetcontents_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::FileGetContentsResponse& Response::_internal_filegetcontents() const {
  return _internal_has_filegetcontents()
      ? *_impl_.response_.filegetcontents_
      : reinterpret_cast< ::proto::FileGetContentsResponse&>(::proto::_FileGetContentsResponse_default_instance_);
}
inline const ::proto::FileGetContentsResponse& Response::filegetcontents() const {
  // @@protoc_insertion_point(field_get:proto.Response.fileGetContents)
  return _internal_filegetcontents();
}
inline ::proto::FileGetContentsResponse* Response::unsafe_arena_release_filegetcontents() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.fileGetContents)
  if (_internal_has_filegetcontents()) {
    clear_has_response();
    ::proto::FileGetContentsResponse* temp = _impl_.response_.filegetcontents_;
    _impl_.response_.filegetcontents_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_filegetcontents(::proto::FileGetContentsResponse* filegetcontents) {
  clear_response();
  if (filegetcontents) {
    set_has_filegetcontents();
    _impl_.response_.filegetcontents_ = filegetcontents;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.fileGetContents)
}
inline ::proto::FileGetContentsResponse* Response::_internal_mutable_filegetcontents() {
  if (!_internal_has_filegetcontents()) {
    clear_response();
    set_has_filegetcontents();
    _impl_.response_.filegetcontents_ = CreateMaybeMessage< ::proto::FileGetContentsResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.filegetcontents_;
}
inline ::proto::FileGetContentsResponse* Response::mutable_filegetcontents() {
  ::proto::FileGetContentsResponse* _msg = _internal_mutable_filegetcontents();
  // @@protoc_insertion_point(field_mutable:proto.Response.fileGetContents)
  return _msg;
}

// .proto.FileGetInfoResponse fileGetInfo = 13;
inline bool Response::_internal_has_filegetinfo() const {
  return response_case() == kFileGetInfo;
}
inline bool Response::has_filegetinfo() const {
  return _internal_has_filegetinfo();
}
inline void Response::set_has_filegetinfo() {
  _impl_._oneof_case_[0] = kFileGetInfo;
}
inline ::proto::FileGetInfoResponse* Response::release_filegetinfo() {
  // @@protoc_insertion_point(field_release:proto.Response.fileGetInfo)
  if (_internal_has_filegetinfo()) {
    clear_has_response();
    ::proto::FileGetInfoResponse* temp = _impl_.response_.filegetinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.filegetinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::FileGetInfoResponse& Response::_internal_filegetinfo() const {
  return _internal_has_filegetinfo()
      ? *_impl_.response_.filegetinfo_
      : reinterpret_cast< ::proto::FileGetInfoResponse&>(::proto::_FileGetInfoResponse_default_instance_);
}
inline const ::proto::FileGetInfoResponse& Response::filegetinfo() const {
  // @@protoc_insertion_point(field_get:proto.Response.fileGetInfo)
  return _internal_filegetinfo();
}
inline ::proto::FileGetInfoResponse* Response::unsafe_arena_release_filegetinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.fileGetInfo)
  if (_internal_has_filegetinfo()) {
    clear_has_response();
    ::proto::FileGetInfoResponse* temp = _impl_.response_.filegetinfo_;
    _impl_.response_.filegetinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_filegetinfo(::proto::FileGetInfoResponse* filegetinfo) {
  clear_response();
  if (filegetinfo) {
    set_has_filegetinfo();
    _impl_.response_.filegetinfo_ = filegetinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.fileGetInfo)
}
inline ::proto::FileGetInfoResponse* Response::_internal_mutable_filegetinfo() {
  if (!_internal_has_filegetinfo()) {
    clear_response();
    set_has_filegetinfo();
    _impl_.response_.filegetinfo_ = CreateMaybeMessage< ::proto::FileGetInfoResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.filegetinfo_;
}
inline ::proto::FileGetInfoResponse* Response::mutable_filegetinfo() {
  ::proto::FileGetInfoResponse* _msg = _internal_mutable_filegetinfo();
  // @@protoc_insertion_point(field_mutable:proto.Response.fileGetInfo)
  return _msg;
}

// .proto.TransactionGetReceiptResponse transactionGetReceipt = 14;
inline bool Response::_internal_has_transactiongetreceipt() const {
  return response_case() == kTransactionGetReceipt;
}
inline bool Response::has_transactiongetreceipt() const {
  return _internal_has_transactiongetreceipt();
}
inline void Response::set_has_transactiongetreceipt() {
  _impl_._oneof_case_[0] = kTransactionGetReceipt;
}
inline ::proto::TransactionGetReceiptResponse* Response::release_transactiongetreceipt() {
  // @@protoc_insertion_point(field_release:proto.Response.transactionGetReceipt)
  if (_internal_has_transactiongetreceipt()) {
    clear_has_response();
    ::proto::TransactionGetReceiptResponse* temp = _impl_.response_.transactiongetreceipt_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.transactiongetreceipt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TransactionGetReceiptResponse& Response::_internal_transactiongetreceipt() const {
  return _internal_has_transactiongetreceipt()
      ? *_impl_.response_.transactiongetreceipt_
      : reinterpret_cast< ::proto::TransactionGetReceiptResponse&>(::proto::_TransactionGetReceiptResponse_default_instance_);
}
inline const ::proto::TransactionGetReceiptResponse& Response::transactiongetreceipt() const {
  // @@protoc_insertion_point(field_get:proto.Response.transactionGetReceipt)
  return _internal_transactiongetreceipt();
}
inline ::proto::TransactionGetReceiptResponse* Response::unsafe_arena_release_transactiongetreceipt() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.transactionGetReceipt)
  if (_internal_has_transactiongetreceipt()) {
    clear_has_response();
    ::proto::TransactionGetReceiptResponse* temp = _impl_.response_.transactiongetreceipt_;
    _impl_.response_.transactiongetreceipt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_transactiongetreceipt(::proto::TransactionGetReceiptResponse* transactiongetreceipt) {
  clear_response();
  if (transactiongetreceipt) {
    set_has_transactiongetreceipt();
    _impl_.response_.transactiongetreceipt_ = transactiongetreceipt;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.transactionGetReceipt)
}
inline ::proto::TransactionGetReceiptResponse* Response::_internal_mutable_transactiongetreceipt() {
  if (!_internal_has_transactiongetreceipt()) {
    clear_response();
    set_has_transactiongetreceipt();
    _impl_.response_.transactiongetreceipt_ = CreateMaybeMessage< ::proto::TransactionGetReceiptResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.transactiongetreceipt_;
}
inline ::proto::TransactionGetReceiptResponse* Response::mutable_transactiongetreceipt() {
  ::proto::TransactionGetReceiptResponse* _msg = _internal_mutable_transactiongetreceipt();
  // @@protoc_insertion_point(field_mutable:proto.Response.transactionGetReceipt)
  return _msg;
}

// .proto.TransactionGetRecordResponse transactionGetRecord = 15;
inline bool Response::_internal_has_transactiongetrecord() const {
  return response_case() == kTransactionGetRecord;
}
inline bool Response::has_transactiongetrecord() const {
  return _internal_has_transactiongetrecord();
}
inline void Response::set_has_transactiongetrecord() {
  _impl_._oneof_case_[0] = kTransactionGetRecord;
}
inline ::proto::TransactionGetRecordResponse* Response::release_transactiongetrecord() {
  // @@protoc_insertion_point(field_release:proto.Response.transactionGetRecord)
  if (_internal_has_transactiongetrecord()) {
    clear_has_response();
    ::proto::TransactionGetRecordResponse* temp = _impl_.response_.transactiongetrecord_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.transactiongetrecord_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TransactionGetRecordResponse& Response::_internal_transactiongetrecord() const {
  return _internal_has_transactiongetrecord()
      ? *_impl_.response_.transactiongetrecord_
      : reinterpret_cast< ::proto::TransactionGetRecordResponse&>(::proto::_TransactionGetRecordResponse_default_instance_);
}
inline const ::proto::TransactionGetRecordResponse& Response::transactiongetrecord() const {
  // @@protoc_insertion_point(field_get:proto.Response.transactionGetRecord)
  return _internal_transactiongetrecord();
}
inline ::proto::TransactionGetRecordResponse* Response::unsafe_arena_release_transactiongetrecord() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.transactionGetRecord)
  if (_internal_has_transactiongetrecord()) {
    clear_has_response();
    ::proto::TransactionGetRecordResponse* temp = _impl_.response_.transactiongetrecord_;
    _impl_.response_.transactiongetrecord_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_transactiongetrecord(::proto::TransactionGetRecordResponse* transactiongetrecord) {
  clear_response();
  if (transactiongetrecord) {
    set_has_transactiongetrecord();
    _impl_.response_.transactiongetrecord_ = transactiongetrecord;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.transactionGetRecord)
}
inline ::proto::TransactionGetRecordResponse* Response::_internal_mutable_transactiongetrecord() {
  if (!_internal_has_transactiongetrecord()) {
    clear_response();
    set_has_transactiongetrecord();
    _impl_.response_.transactiongetrecord_ = CreateMaybeMessage< ::proto::TransactionGetRecordResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.transactiongetrecord_;
}
inline ::proto::TransactionGetRecordResponse* Response::mutable_transactiongetrecord() {
  ::proto::TransactionGetRecordResponse* _msg = _internal_mutable_transactiongetrecord();
  // @@protoc_insertion_point(field_mutable:proto.Response.transactionGetRecord)
  return _msg;
}

// .proto.TransactionGetFastRecordResponse transactionGetFastRecord = 16;
inline bool Response::_internal_has_transactiongetfastrecord() const {
  return response_case() == kTransactionGetFastRecord;
}
inline bool Response::has_transactiongetfastrecord() const {
  return _internal_has_transactiongetfastrecord();
}
inline void Response::set_has_transactiongetfastrecord() {
  _impl_._oneof_case_[0] = kTransactionGetFastRecord;
}
inline ::proto::TransactionGetFastRecordResponse* Response::release_transactiongetfastrecord() {
  // @@protoc_insertion_point(field_release:proto.Response.transactionGetFastRecord)
  if (_internal_has_transactiongetfastrecord()) {
    clear_has_response();
    ::proto::TransactionGetFastRecordResponse* temp = _impl_.response_.transactiongetfastrecord_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.transactiongetfastrecord_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TransactionGetFastRecordResponse& Response::_internal_transactiongetfastrecord() const {
  return _internal_has_transactiongetfastrecord()
      ? *_impl_.response_.transactiongetfastrecord_
      : reinterpret_cast< ::proto::TransactionGetFastRecordResponse&>(::proto::_TransactionGetFastRecordResponse_default_instance_);
}
inline const ::proto::TransactionGetFastRecordResponse& Response::transactiongetfastrecord() const {
  // @@protoc_insertion_point(field_get:proto.Response.transactionGetFastRecord)
  return _internal_transactiongetfastrecord();
}
inline ::proto::TransactionGetFastRecordResponse* Response::unsafe_arena_release_transactiongetfastrecord() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.transactionGetFastRecord)
  if (_internal_has_transactiongetfastrecord()) {
    clear_has_response();
    ::proto::TransactionGetFastRecordResponse* temp = _impl_.response_.transactiongetfastrecord_;
    _impl_.response_.transactiongetfastrecord_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_transactiongetfastrecord(::proto::TransactionGetFastRecordResponse* transactiongetfastrecord) {
  clear_response();
  if (transactiongetfastrecord) {
    set_has_transactiongetfastrecord();
    _impl_.response_.transactiongetfastrecord_ = transactiongetfastrecord;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.transactionGetFastRecord)
}
inline ::proto::TransactionGetFastRecordResponse* Response::_internal_mutable_transactiongetfastrecord() {
  if (!_internal_has_transactiongetfastrecord()) {
    clear_response();
    set_has_transactiongetfastrecord();
    _impl_.response_.transactiongetfastrecord_ = CreateMaybeMessage< ::proto::TransactionGetFastRecordResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.transactiongetfastrecord_;
}
inline ::proto::TransactionGetFastRecordResponse* Response::mutable_transactiongetfastrecord() {
  ::proto::TransactionGetFastRecordResponse* _msg = _internal_mutable_transactiongetfastrecord();
  // @@protoc_insertion_point(field_mutable:proto.Response.transactionGetFastRecord)
  return _msg;
}

// .proto.ConsensusGetTopicInfoResponse consensusGetTopicInfo = 150;
inline bool Response::_internal_has_consensusgettopicinfo() const {
  return response_case() == kConsensusGetTopicInfo;
}
inline bool Response::has_consensusgettopicinfo() const {
  return _internal_has_consensusgettopicinfo();
}
inline void Response::set_has_consensusgettopicinfo() {
  _impl_._oneof_case_[0] = kConsensusGetTopicInfo;
}
inline ::proto::ConsensusGetTopicInfoResponse* Response::release_consensusgettopicinfo() {
  // @@protoc_insertion_point(field_release:proto.Response.consensusGetTopicInfo)
  if (_internal_has_consensusgettopicinfo()) {
    clear_has_response();
    ::proto::ConsensusGetTopicInfoResponse* temp = _impl_.response_.consensusgettopicinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.consensusgettopicinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ConsensusGetTopicInfoResponse& Response::_internal_consensusgettopicinfo() const {
  return _internal_has_consensusgettopicinfo()
      ? *_impl_.response_.consensusgettopicinfo_
      : reinterpret_cast< ::proto::ConsensusGetTopicInfoResponse&>(::proto::_ConsensusGetTopicInfoResponse_default_instance_);
}
inline const ::proto::ConsensusGetTopicInfoResponse& Response::consensusgettopicinfo() const {
  // @@protoc_insertion_point(field_get:proto.Response.consensusGetTopicInfo)
  return _internal_consensusgettopicinfo();
}
inline ::proto::ConsensusGetTopicInfoResponse* Response::unsafe_arena_release_consensusgettopicinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.consensusGetTopicInfo)
  if (_internal_has_consensusgettopicinfo()) {
    clear_has_response();
    ::proto::ConsensusGetTopicInfoResponse* temp = _impl_.response_.consensusgettopicinfo_;
    _impl_.response_.consensusgettopicinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_consensusgettopicinfo(::proto::ConsensusGetTopicInfoResponse* consensusgettopicinfo) {
  clear_response();
  if (consensusgettopicinfo) {
    set_has_consensusgettopicinfo();
    _impl_.response_.consensusgettopicinfo_ = consensusgettopicinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.consensusGetTopicInfo)
}
inline ::proto::ConsensusGetTopicInfoResponse* Response::_internal_mutable_consensusgettopicinfo() {
  if (!_internal_has_consensusgettopicinfo()) {
    clear_response();
    set_has_consensusgettopicinfo();
    _impl_.response_.consensusgettopicinfo_ = CreateMaybeMessage< ::proto::ConsensusGetTopicInfoResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.consensusgettopicinfo_;
}
inline ::proto::ConsensusGetTopicInfoResponse* Response::mutable_consensusgettopicinfo() {
  ::proto::ConsensusGetTopicInfoResponse* _msg = _internal_mutable_consensusgettopicinfo();
  // @@protoc_insertion_point(field_mutable:proto.Response.consensusGetTopicInfo)
  return _msg;
}

// .proto.NetworkGetVersionInfoResponse networkGetVersionInfo = 151;
inline bool Response::_internal_has_networkgetversioninfo() const {
  return response_case() == kNetworkGetVersionInfo;
}
inline bool Response::has_networkgetversioninfo() const {
  return _internal_has_networkgetversioninfo();
}
inline void Response::set_has_networkgetversioninfo() {
  _impl_._oneof_case_[0] = kNetworkGetVersionInfo;
}
inline ::proto::NetworkGetVersionInfoResponse* Response::release_networkgetversioninfo() {
  // @@protoc_insertion_point(field_release:proto.Response.networkGetVersionInfo)
  if (_internal_has_networkgetversioninfo()) {
    clear_has_response();
    ::proto::NetworkGetVersionInfoResponse* temp = _impl_.response_.networkgetversioninfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.networkgetversioninfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::NetworkGetVersionInfoResponse& Response::_internal_networkgetversioninfo() const {
  return _internal_has_networkgetversioninfo()
      ? *_impl_.response_.networkgetversioninfo_
      : reinterpret_cast< ::proto::NetworkGetVersionInfoResponse&>(::proto::_NetworkGetVersionInfoResponse_default_instance_);
}
inline const ::proto::NetworkGetVersionInfoResponse& Response::networkgetversioninfo() const {
  // @@protoc_insertion_point(field_get:proto.Response.networkGetVersionInfo)
  return _internal_networkgetversioninfo();
}
inline ::proto::NetworkGetVersionInfoResponse* Response::unsafe_arena_release_networkgetversioninfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.networkGetVersionInfo)
  if (_internal_has_networkgetversioninfo()) {
    clear_has_response();
    ::proto::NetworkGetVersionInfoResponse* temp = _impl_.response_.networkgetversioninfo_;
    _impl_.response_.networkgetversioninfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_networkgetversioninfo(::proto::NetworkGetVersionInfoResponse* networkgetversioninfo) {
  clear_response();
  if (networkgetversioninfo) {
    set_has_networkgetversioninfo();
    _impl_.response_.networkgetversioninfo_ = networkgetversioninfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.networkGetVersionInfo)
}
inline ::proto::NetworkGetVersionInfoResponse* Response::_internal_mutable_networkgetversioninfo() {
  if (!_internal_has_networkgetversioninfo()) {
    clear_response();
    set_has_networkgetversioninfo();
    _impl_.response_.networkgetversioninfo_ = CreateMaybeMessage< ::proto::NetworkGetVersionInfoResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.networkgetversioninfo_;
}
inline ::proto::NetworkGetVersionInfoResponse* Response::mutable_networkgetversioninfo() {
  ::proto::NetworkGetVersionInfoResponse* _msg = _internal_mutable_networkgetversioninfo();
  // @@protoc_insertion_point(field_mutable:proto.Response.networkGetVersionInfo)
  return _msg;
}

// .proto.TokenGetInfoResponse tokenGetInfo = 152;
inline bool Response::_internal_has_tokengetinfo() const {
  return response_case() == kTokenGetInfo;
}
inline bool Response::has_tokengetinfo() const {
  return _internal_has_tokengetinfo();
}
inline void Response::set_has_tokengetinfo() {
  _impl_._oneof_case_[0] = kTokenGetInfo;
}
inline ::proto::TokenGetInfoResponse* Response::release_tokengetinfo() {
  // @@protoc_insertion_point(field_release:proto.Response.tokenGetInfo)
  if (_internal_has_tokengetinfo()) {
    clear_has_response();
    ::proto::TokenGetInfoResponse* temp = _impl_.response_.tokengetinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.tokengetinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenGetInfoResponse& Response::_internal_tokengetinfo() const {
  return _internal_has_tokengetinfo()
      ? *_impl_.response_.tokengetinfo_
      : reinterpret_cast< ::proto::TokenGetInfoResponse&>(::proto::_TokenGetInfoResponse_default_instance_);
}
inline const ::proto::TokenGetInfoResponse& Response::tokengetinfo() const {
  // @@protoc_insertion_point(field_get:proto.Response.tokenGetInfo)
  return _internal_tokengetinfo();
}
inline ::proto::TokenGetInfoResponse* Response::unsafe_arena_release_tokengetinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.tokenGetInfo)
  if (_internal_has_tokengetinfo()) {
    clear_has_response();
    ::proto::TokenGetInfoResponse* temp = _impl_.response_.tokengetinfo_;
    _impl_.response_.tokengetinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_tokengetinfo(::proto::TokenGetInfoResponse* tokengetinfo) {
  clear_response();
  if (tokengetinfo) {
    set_has_tokengetinfo();
    _impl_.response_.tokengetinfo_ = tokengetinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.tokenGetInfo)
}
inline ::proto::TokenGetInfoResponse* Response::_internal_mutable_tokengetinfo() {
  if (!_internal_has_tokengetinfo()) {
    clear_response();
    set_has_tokengetinfo();
    _impl_.response_.tokengetinfo_ = CreateMaybeMessage< ::proto::TokenGetInfoResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.tokengetinfo_;
}
inline ::proto::TokenGetInfoResponse* Response::mutable_tokengetinfo() {
  ::proto::TokenGetInfoResponse* _msg = _internal_mutable_tokengetinfo();
  // @@protoc_insertion_point(field_mutable:proto.Response.tokenGetInfo)
  return _msg;
}

// .proto.ScheduleGetInfoResponse scheduleGetInfo = 153;
inline bool Response::_internal_has_schedulegetinfo() const {
  return response_case() == kScheduleGetInfo;
}
inline bool Response::has_schedulegetinfo() const {
  return _internal_has_schedulegetinfo();
}
inline void Response::set_has_schedulegetinfo() {
  _impl_._oneof_case_[0] = kScheduleGetInfo;
}
inline ::proto::ScheduleGetInfoResponse* Response::release_schedulegetinfo() {
  // @@protoc_insertion_point(field_release:proto.Response.scheduleGetInfo)
  if (_internal_has_schedulegetinfo()) {
    clear_has_response();
    ::proto::ScheduleGetInfoResponse* temp = _impl_.response_.schedulegetinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.schedulegetinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ScheduleGetInfoResponse& Response::_internal_schedulegetinfo() const {
  return _internal_has_schedulegetinfo()
      ? *_impl_.response_.schedulegetinfo_
      : reinterpret_cast< ::proto::ScheduleGetInfoResponse&>(::proto::_ScheduleGetInfoResponse_default_instance_);
}
inline const ::proto::ScheduleGetInfoResponse& Response::schedulegetinfo() const {
  // @@protoc_insertion_point(field_get:proto.Response.scheduleGetInfo)
  return _internal_schedulegetinfo();
}
inline ::proto::ScheduleGetInfoResponse* Response::unsafe_arena_release_schedulegetinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.scheduleGetInfo)
  if (_internal_has_schedulegetinfo()) {
    clear_has_response();
    ::proto::ScheduleGetInfoResponse* temp = _impl_.response_.schedulegetinfo_;
    _impl_.response_.schedulegetinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_schedulegetinfo(::proto::ScheduleGetInfoResponse* schedulegetinfo) {
  clear_response();
  if (schedulegetinfo) {
    set_has_schedulegetinfo();
    _impl_.response_.schedulegetinfo_ = schedulegetinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.scheduleGetInfo)
}
inline ::proto::ScheduleGetInfoResponse* Response::_internal_mutable_schedulegetinfo() {
  if (!_internal_has_schedulegetinfo()) {
    clear_response();
    set_has_schedulegetinfo();
    _impl_.response_.schedulegetinfo_ = CreateMaybeMessage< ::proto::ScheduleGetInfoResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.schedulegetinfo_;
}
inline ::proto::ScheduleGetInfoResponse* Response::mutable_schedulegetinfo() {
  ::proto::ScheduleGetInfoResponse* _msg = _internal_mutable_schedulegetinfo();
  // @@protoc_insertion_point(field_mutable:proto.Response.scheduleGetInfo)
  return _msg;
}

// .proto.TokenGetAccountNftInfosResponse tokenGetAccountNftInfos = 154;
inline bool Response::_internal_has_tokengetaccountnftinfos() const {
  return response_case() == kTokenGetAccountNftInfos;
}
inline bool Response::has_tokengetaccountnftinfos() const {
  return _internal_has_tokengetaccountnftinfos();
}
inline void Response::set_has_tokengetaccountnftinfos() {
  _impl_._oneof_case_[0] = kTokenGetAccountNftInfos;
}
inline ::proto::TokenGetAccountNftInfosResponse* Response::release_tokengetaccountnftinfos() {
  // @@protoc_insertion_point(field_release:proto.Response.tokenGetAccountNftInfos)
  if (_internal_has_tokengetaccountnftinfos()) {
    clear_has_response();
    ::proto::TokenGetAccountNftInfosResponse* temp = _impl_.response_.tokengetaccountnftinfos_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.tokengetaccountnftinfos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenGetAccountNftInfosResponse& Response::_internal_tokengetaccountnftinfos() const {
  return _internal_has_tokengetaccountnftinfos()
      ? *_impl_.response_.tokengetaccountnftinfos_
      : reinterpret_cast< ::proto::TokenGetAccountNftInfosResponse&>(::proto::_TokenGetAccountNftInfosResponse_default_instance_);
}
inline const ::proto::TokenGetAccountNftInfosResponse& Response::tokengetaccountnftinfos() const {
  // @@protoc_insertion_point(field_get:proto.Response.tokenGetAccountNftInfos)
  return _internal_tokengetaccountnftinfos();
}
inline ::proto::TokenGetAccountNftInfosResponse* Response::unsafe_arena_release_tokengetaccountnftinfos() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.tokenGetAccountNftInfos)
  if (_internal_has_tokengetaccountnftinfos()) {
    clear_has_response();
    ::proto::TokenGetAccountNftInfosResponse* temp = _impl_.response_.tokengetaccountnftinfos_;
    _impl_.response_.tokengetaccountnftinfos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_tokengetaccountnftinfos(::proto::TokenGetAccountNftInfosResponse* tokengetaccountnftinfos) {
  clear_response();
  if (tokengetaccountnftinfos) {
    set_has_tokengetaccountnftinfos();
    _impl_.response_.tokengetaccountnftinfos_ = tokengetaccountnftinfos;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.tokenGetAccountNftInfos)
}
inline ::proto::TokenGetAccountNftInfosResponse* Response::_internal_mutable_tokengetaccountnftinfos() {
  if (!_internal_has_tokengetaccountnftinfos()) {
    clear_response();
    set_has_tokengetaccountnftinfos();
    _impl_.response_.tokengetaccountnftinfos_ = CreateMaybeMessage< ::proto::TokenGetAccountNftInfosResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.tokengetaccountnftinfos_;
}
inline ::proto::TokenGetAccountNftInfosResponse* Response::mutable_tokengetaccountnftinfos() {
  ::proto::TokenGetAccountNftInfosResponse* _msg = _internal_mutable_tokengetaccountnftinfos();
  // @@protoc_insertion_point(field_mutable:proto.Response.tokenGetAccountNftInfos)
  return _msg;
}

// .proto.TokenGetNftInfoResponse tokenGetNftInfo = 155;
inline bool Response::_internal_has_tokengetnftinfo() const {
  return response_case() == kTokenGetNftInfo;
}
inline bool Response::has_tokengetnftinfo() const {
  return _internal_has_tokengetnftinfo();
}
inline void Response::set_has_tokengetnftinfo() {
  _impl_._oneof_case_[0] = kTokenGetNftInfo;
}
inline ::proto::TokenGetNftInfoResponse* Response::release_tokengetnftinfo() {
  // @@protoc_insertion_point(field_release:proto.Response.tokenGetNftInfo)
  if (_internal_has_tokengetnftinfo()) {
    clear_has_response();
    ::proto::TokenGetNftInfoResponse* temp = _impl_.response_.tokengetnftinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.tokengetnftinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenGetNftInfoResponse& Response::_internal_tokengetnftinfo() const {
  return _internal_has_tokengetnftinfo()
      ? *_impl_.response_.tokengetnftinfo_
      : reinterpret_cast< ::proto::TokenGetNftInfoResponse&>(::proto::_TokenGetNftInfoResponse_default_instance_);
}
inline const ::proto::TokenGetNftInfoResponse& Response::tokengetnftinfo() const {
  // @@protoc_insertion_point(field_get:proto.Response.tokenGetNftInfo)
  return _internal_tokengetnftinfo();
}
inline ::proto::TokenGetNftInfoResponse* Response::unsafe_arena_release_tokengetnftinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.tokenGetNftInfo)
  if (_internal_has_tokengetnftinfo()) {
    clear_has_response();
    ::proto::TokenGetNftInfoResponse* temp = _impl_.response_.tokengetnftinfo_;
    _impl_.response_.tokengetnftinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_tokengetnftinfo(::proto::TokenGetNftInfoResponse* tokengetnftinfo) {
  clear_response();
  if (tokengetnftinfo) {
    set_has_tokengetnftinfo();
    _impl_.response_.tokengetnftinfo_ = tokengetnftinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.tokenGetNftInfo)
}
inline ::proto::TokenGetNftInfoResponse* Response::_internal_mutable_tokengetnftinfo() {
  if (!_internal_has_tokengetnftinfo()) {
    clear_response();
    set_has_tokengetnftinfo();
    _impl_.response_.tokengetnftinfo_ = CreateMaybeMessage< ::proto::TokenGetNftInfoResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.tokengetnftinfo_;
}
inline ::proto::TokenGetNftInfoResponse* Response::mutable_tokengetnftinfo() {
  ::proto::TokenGetNftInfoResponse* _msg = _internal_mutable_tokengetnftinfo();
  // @@protoc_insertion_point(field_mutable:proto.Response.tokenGetNftInfo)
  return _msg;
}

// .proto.TokenGetNftInfosResponse tokenGetNftInfos = 156;
inline bool Response::_internal_has_tokengetnftinfos() const {
  return response_case() == kTokenGetNftInfos;
}
inline bool Response::has_tokengetnftinfos() const {
  return _internal_has_tokengetnftinfos();
}
inline void Response::set_has_tokengetnftinfos() {
  _impl_._oneof_case_[0] = kTokenGetNftInfos;
}
inline ::proto::TokenGetNftInfosResponse* Response::release_tokengetnftinfos() {
  // @@protoc_insertion_point(field_release:proto.Response.tokenGetNftInfos)
  if (_internal_has_tokengetnftinfos()) {
    clear_has_response();
    ::proto::TokenGetNftInfosResponse* temp = _impl_.response_.tokengetnftinfos_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.tokengetnftinfos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenGetNftInfosResponse& Response::_internal_tokengetnftinfos() const {
  return _internal_has_tokengetnftinfos()
      ? *_impl_.response_.tokengetnftinfos_
      : reinterpret_cast< ::proto::TokenGetNftInfosResponse&>(::proto::_TokenGetNftInfosResponse_default_instance_);
}
inline const ::proto::TokenGetNftInfosResponse& Response::tokengetnftinfos() const {
  // @@protoc_insertion_point(field_get:proto.Response.tokenGetNftInfos)
  return _internal_tokengetnftinfos();
}
inline ::proto::TokenGetNftInfosResponse* Response::unsafe_arena_release_tokengetnftinfos() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.tokenGetNftInfos)
  if (_internal_has_tokengetnftinfos()) {
    clear_has_response();
    ::proto::TokenGetNftInfosResponse* temp = _impl_.response_.tokengetnftinfos_;
    _impl_.response_.tokengetnftinfos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_tokengetnftinfos(::proto::TokenGetNftInfosResponse* tokengetnftinfos) {
  clear_response();
  if (tokengetnftinfos) {
    set_has_tokengetnftinfos();
    _impl_.response_.tokengetnftinfos_ = tokengetnftinfos;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.tokenGetNftInfos)
}
inline ::proto::TokenGetNftInfosResponse* Response::_internal_mutable_tokengetnftinfos() {
  if (!_internal_has_tokengetnftinfos()) {
    clear_response();
    set_has_tokengetnftinfos();
    _impl_.response_.tokengetnftinfos_ = CreateMaybeMessage< ::proto::TokenGetNftInfosResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.tokengetnftinfos_;
}
inline ::proto::TokenGetNftInfosResponse* Response::mutable_tokengetnftinfos() {
  ::proto::TokenGetNftInfosResponse* _msg = _internal_mutable_tokengetnftinfos();
  // @@protoc_insertion_point(field_mutable:proto.Response.tokenGetNftInfos)
  return _msg;
}

// .proto.NetworkGetExecutionTimeResponse networkGetExecutionTime = 157;
inline bool Response::_internal_has_networkgetexecutiontime() const {
  return response_case() == kNetworkGetExecutionTime;
}
inline bool Response::has_networkgetexecutiontime() const {
  return _internal_has_networkgetexecutiontime();
}
inline void Response::set_has_networkgetexecutiontime() {
  _impl_._oneof_case_[0] = kNetworkGetExecutionTime;
}
inline ::proto::NetworkGetExecutionTimeResponse* Response::release_networkgetexecutiontime() {
  // @@protoc_insertion_point(field_release:proto.Response.networkGetExecutionTime)
  if (_internal_has_networkgetexecutiontime()) {
    clear_has_response();
    ::proto::NetworkGetExecutionTimeResponse* temp = _impl_.response_.networkgetexecutiontime_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.networkgetexecutiontime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::NetworkGetExecutionTimeResponse& Response::_internal_networkgetexecutiontime() const {
  return _internal_has_networkgetexecutiontime()
      ? *_impl_.response_.networkgetexecutiontime_
      : reinterpret_cast< ::proto::NetworkGetExecutionTimeResponse&>(::proto::_NetworkGetExecutionTimeResponse_default_instance_);
}
inline const ::proto::NetworkGetExecutionTimeResponse& Response::networkgetexecutiontime() const {
  // @@protoc_insertion_point(field_get:proto.Response.networkGetExecutionTime)
  return _internal_networkgetexecutiontime();
}
inline ::proto::NetworkGetExecutionTimeResponse* Response::unsafe_arena_release_networkgetexecutiontime() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.networkGetExecutionTime)
  if (_internal_has_networkgetexecutiontime()) {
    clear_has_response();
    ::proto::NetworkGetExecutionTimeResponse* temp = _impl_.response_.networkgetexecutiontime_;
    _impl_.response_.networkgetexecutiontime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_networkgetexecutiontime(::proto::NetworkGetExecutionTimeResponse* networkgetexecutiontime) {
  clear_response();
  if (networkgetexecutiontime) {
    set_has_networkgetexecutiontime();
    _impl_.response_.networkgetexecutiontime_ = networkgetexecutiontime;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.networkGetExecutionTime)
}
inline ::proto::NetworkGetExecutionTimeResponse* Response::_internal_mutable_networkgetexecutiontime() {
  if (!_internal_has_networkgetexecutiontime()) {
    clear_response();
    set_has_networkgetexecutiontime();
    _impl_.response_.networkgetexecutiontime_ = CreateMaybeMessage< ::proto::NetworkGetExecutionTimeResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.networkgetexecutiontime_;
}
inline ::proto::NetworkGetExecutionTimeResponse* Response::mutable_networkgetexecutiontime() {
  ::proto::NetworkGetExecutionTimeResponse* _msg = _internal_mutable_networkgetexecutiontime();
  // @@protoc_insertion_point(field_mutable:proto.Response.networkGetExecutionTime)
  return _msg;
}

// .proto.GetAccountDetailsResponse accountDetails = 158;
inline bool Response::_internal_has_accountdetails() const {
  return response_case() == kAccountDetails;
}
inline bool Response::has_accountdetails() const {
  return _internal_has_accountdetails();
}
inline void Response::set_has_accountdetails() {
  _impl_._oneof_case_[0] = kAccountDetails;
}
inline ::proto::GetAccountDetailsResponse* Response::release_accountdetails() {
  // @@protoc_insertion_point(field_release:proto.Response.accountDetails)
  if (_internal_has_accountdetails()) {
    clear_has_response();
    ::proto::GetAccountDetailsResponse* temp = _impl_.response_.accountdetails_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.accountdetails_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::GetAccountDetailsResponse& Response::_internal_accountdetails() const {
  return _internal_has_accountdetails()
      ? *_impl_.response_.accountdetails_
      : reinterpret_cast< ::proto::GetAccountDetailsResponse&>(::proto::_GetAccountDetailsResponse_default_instance_);
}
inline const ::proto::GetAccountDetailsResponse& Response::accountdetails() const {
  // @@protoc_insertion_point(field_get:proto.Response.accountDetails)
  return _internal_accountdetails();
}
inline ::proto::GetAccountDetailsResponse* Response::unsafe_arena_release_accountdetails() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.Response.accountDetails)
  if (_internal_has_accountdetails()) {
    clear_has_response();
    ::proto::GetAccountDetailsResponse* temp = _impl_.response_.accountdetails_;
    _impl_.response_.accountdetails_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_accountdetails(::proto::GetAccountDetailsResponse* accountdetails) {
  clear_response();
  if (accountdetails) {
    set_has_accountdetails();
    _impl_.response_.accountdetails_ = accountdetails;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.Response.accountDetails)
}
inline ::proto::GetAccountDetailsResponse* Response::_internal_mutable_accountdetails() {
  if (!_internal_has_accountdetails()) {
    clear_response();
    set_has_accountdetails();
    _impl_.response_.accountdetails_ = CreateMaybeMessage< ::proto::GetAccountDetailsResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.accountdetails_;
}
inline ::proto::GetAccountDetailsResponse* Response::mutable_accountdetails() {
  ::proto::GetAccountDetailsResponse* _msg = _internal_mutable_accountdetails();
  // @@protoc_insertion_point(field_mutable:proto.Response.accountDetails)
  return _msg;
}

inline bool Response::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void Response::clear_has_response() {
  _impl_._oneof_case_[0] = RESPONSE_NOT_SET;
}
inline Response::ResponseCase Response::response_case() const {
  return Response::ResponseCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_response_2eproto
