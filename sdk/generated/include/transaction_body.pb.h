// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: transaction_body.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_transaction_5fbody_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_transaction_5fbody_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "system_delete.pb.h"
#include "system_undelete.pb.h"
#include "freeze.pb.h"
#include "contract_call.pb.h"
#include "contract_create.pb.h"
#include "contract_update.pb.h"
#include "crypto_add_live_hash.pb.h"
#include "crypto_create.pb.h"
#include "crypto_delete.pb.h"
#include "crypto_delete_live_hash.pb.h"
#include "crypto_transfer.pb.h"
#include "crypto_update.pb.h"
#include "crypto_approve_allowance.pb.h"
#include "crypto_delete_allowance.pb.h"
#include "ethereum_transaction.pb.h"
#include "file_append.pb.h"
#include "file_create.pb.h"
#include "file_delete.pb.h"
#include "file_update.pb.h"
#include "duration.pb.h"
#include "basic_types.pb.h"
#include "contract_delete.pb.h"
#include "consensus_create_topic.pb.h"
#include "consensus_update_topic.pb.h"
#include "consensus_delete_topic.pb.h"
#include "consensus_submit_message.pb.h"
#include "unchecked_submit.pb.h"
#include "token_create.pb.h"
#include "token_freeze_account.pb.h"
#include "token_unfreeze_account.pb.h"
#include "token_grant_kyc.pb.h"
#include "token_revoke_kyc.pb.h"
#include "token_delete.pb.h"
#include "token_update.pb.h"
#include "token_mint.pb.h"
#include "token_burn.pb.h"
#include "token_wipe_account.pb.h"
#include "token_associate.pb.h"
#include "token_dissociate.pb.h"
#include "token_fee_schedule_update.pb.h"
#include "token_pause.pb.h"
#include "token_unpause.pb.h"
#include "schedule_create.pb.h"
#include "schedule_delete.pb.h"
#include "schedule_sign.pb.h"
#include "node_stake_update.pb.h"
#include "util_prng.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_transaction_5fbody_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_transaction_5fbody_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_transaction_5fbody_2eproto;
namespace proto {
class TransactionBody;
struct TransactionBodyDefaultTypeInternal;
extern TransactionBodyDefaultTypeInternal _TransactionBody_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::TransactionBody* Arena::CreateMaybeMessage<::proto::TransactionBody>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

// ===================================================================

class TransactionBody final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.TransactionBody) */ {
 public:
  inline TransactionBody() : TransactionBody(nullptr) {}
  ~TransactionBody() override;
  explicit PROTOBUF_CONSTEXPR TransactionBody(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionBody(const TransactionBody& from);
  TransactionBody(TransactionBody&& from) noexcept
    : TransactionBody() {
    *this = ::std::move(from);
  }

  inline TransactionBody& operator=(const TransactionBody& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionBody& operator=(TransactionBody&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionBody& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kContractCall = 7,
    kContractCreateInstance = 8,
    kContractUpdateInstance = 9,
    kContractDeleteInstance = 22,
    kEthereumTransaction = 50,
    kCryptoAddLiveHash = 10,
    kCryptoApproveAllowance = 48,
    kCryptoDeleteAllowance = 49,
    kCryptoCreateAccount = 11,
    kCryptoDelete = 12,
    kCryptoDeleteLiveHash = 13,
    kCryptoTransfer = 14,
    kCryptoUpdateAccount = 15,
    kFileAppend = 16,
    kFileCreate = 17,
    kFileDelete = 18,
    kFileUpdate = 19,
    kSystemDelete = 20,
    kSystemUndelete = 21,
    kFreeze = 23,
    kConsensusCreateTopic = 24,
    kConsensusUpdateTopic = 25,
    kConsensusDeleteTopic = 26,
    kConsensusSubmitMessage = 27,
    kUncheckedSubmit = 28,
    kTokenCreation = 29,
    kTokenFreeze = 31,
    kTokenUnfreeze = 32,
    kTokenGrantKyc = 33,
    kTokenRevokeKyc = 34,
    kTokenDeletion = 35,
    kTokenUpdate = 36,
    kTokenMint = 37,
    kTokenBurn = 38,
    kTokenWipe = 39,
    kTokenAssociate = 40,
    kTokenDissociate = 41,
    kTokenFeeScheduleUpdate = 45,
    kTokenPause = 46,
    kTokenUnpause = 47,
    kScheduleCreate = 42,
    kScheduleDelete = 43,
    kScheduleSign = 44,
    kNodeStakeUpdate = 51,
    kUtilPrng = 52,
    DATA_NOT_SET = 0,
  };

  static inline const TransactionBody* internal_default_instance() {
    return reinterpret_cast<const TransactionBody*>(
               &_TransactionBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TransactionBody& a, TransactionBody& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionBody* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionBody* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionBody* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionBody>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionBody& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransactionBody& from) {
    TransactionBody::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionBody* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.TransactionBody";
  }
  protected:
  explicit TransactionBody(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemoFieldNumber = 6,
    kTransactionIDFieldNumber = 1,
    kNodeAccountIDFieldNumber = 2,
    kTransactionValidDurationFieldNumber = 4,
    kTransactionFeeFieldNumber = 3,
    kGenerateRecordFieldNumber = 5,
    kContractCallFieldNumber = 7,
    kContractCreateInstanceFieldNumber = 8,
    kContractUpdateInstanceFieldNumber = 9,
    kContractDeleteInstanceFieldNumber = 22,
    kEthereumTransactionFieldNumber = 50,
    kCryptoAddLiveHashFieldNumber = 10,
    kCryptoApproveAllowanceFieldNumber = 48,
    kCryptoDeleteAllowanceFieldNumber = 49,
    kCryptoCreateAccountFieldNumber = 11,
    kCryptoDeleteFieldNumber = 12,
    kCryptoDeleteLiveHashFieldNumber = 13,
    kCryptoTransferFieldNumber = 14,
    kCryptoUpdateAccountFieldNumber = 15,
    kFileAppendFieldNumber = 16,
    kFileCreateFieldNumber = 17,
    kFileDeleteFieldNumber = 18,
    kFileUpdateFieldNumber = 19,
    kSystemDeleteFieldNumber = 20,
    kSystemUndeleteFieldNumber = 21,
    kFreezeFieldNumber = 23,
    kConsensusCreateTopicFieldNumber = 24,
    kConsensusUpdateTopicFieldNumber = 25,
    kConsensusDeleteTopicFieldNumber = 26,
    kConsensusSubmitMessageFieldNumber = 27,
    kUncheckedSubmitFieldNumber = 28,
    kTokenCreationFieldNumber = 29,
    kTokenFreezeFieldNumber = 31,
    kTokenUnfreezeFieldNumber = 32,
    kTokenGrantKycFieldNumber = 33,
    kTokenRevokeKycFieldNumber = 34,
    kTokenDeletionFieldNumber = 35,
    kTokenUpdateFieldNumber = 36,
    kTokenMintFieldNumber = 37,
    kTokenBurnFieldNumber = 38,
    kTokenWipeFieldNumber = 39,
    kTokenAssociateFieldNumber = 40,
    kTokenDissociateFieldNumber = 41,
    kTokenFeeScheduleUpdateFieldNumber = 45,
    kTokenPauseFieldNumber = 46,
    kTokenUnpauseFieldNumber = 47,
    kScheduleCreateFieldNumber = 42,
    kScheduleDeleteFieldNumber = 43,
    kScheduleSignFieldNumber = 44,
    kNodeStakeUpdateFieldNumber = 51,
    kUtilPrngFieldNumber = 52,
  };
  // string memo = 6;
  void clear_memo();
  const std::string& memo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memo();
  PROTOBUF_NODISCARD std::string* release_memo();
  void set_allocated_memo(std::string* memo);
  private:
  const std::string& _internal_memo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memo(const std::string& value);
  std::string* _internal_mutable_memo();
  public:

  // .proto.TransactionID transactionID = 1;
  bool has_transactionid() const;
  private:
  bool _internal_has_transactionid() const;
  public:
  void clear_transactionid();
  const ::proto::TransactionID& transactionid() const;
  PROTOBUF_NODISCARD ::proto::TransactionID* release_transactionid();
  ::proto::TransactionID* mutable_transactionid();
  void set_allocated_transactionid(::proto::TransactionID* transactionid);
  private:
  const ::proto::TransactionID& _internal_transactionid() const;
  ::proto::TransactionID* _internal_mutable_transactionid();
  public:
  void unsafe_arena_set_allocated_transactionid(
      ::proto::TransactionID* transactionid);
  ::proto::TransactionID* unsafe_arena_release_transactionid();

  // .proto.AccountID nodeAccountID = 2;
  bool has_nodeaccountid() const;
  private:
  bool _internal_has_nodeaccountid() const;
  public:
  void clear_nodeaccountid();
  const ::proto::AccountID& nodeaccountid() const;
  PROTOBUF_NODISCARD ::proto::AccountID* release_nodeaccountid();
  ::proto::AccountID* mutable_nodeaccountid();
  void set_allocated_nodeaccountid(::proto::AccountID* nodeaccountid);
  private:
  const ::proto::AccountID& _internal_nodeaccountid() const;
  ::proto::AccountID* _internal_mutable_nodeaccountid();
  public:
  void unsafe_arena_set_allocated_nodeaccountid(
      ::proto::AccountID* nodeaccountid);
  ::proto::AccountID* unsafe_arena_release_nodeaccountid();

  // .proto.Duration transactionValidDuration = 4;
  bool has_transactionvalidduration() const;
  private:
  bool _internal_has_transactionvalidduration() const;
  public:
  void clear_transactionvalidduration();
  const ::proto::Duration& transactionvalidduration() const;
  PROTOBUF_NODISCARD ::proto::Duration* release_transactionvalidduration();
  ::proto::Duration* mutable_transactionvalidduration();
  void set_allocated_transactionvalidduration(::proto::Duration* transactionvalidduration);
  private:
  const ::proto::Duration& _internal_transactionvalidduration() const;
  ::proto::Duration* _internal_mutable_transactionvalidduration();
  public:
  void unsafe_arena_set_allocated_transactionvalidduration(
      ::proto::Duration* transactionvalidduration);
  ::proto::Duration* unsafe_arena_release_transactionvalidduration();

  // uint64 transactionFee = 3;
  void clear_transactionfee();
  uint64_t transactionfee() const;
  void set_transactionfee(uint64_t value);
  private:
  uint64_t _internal_transactionfee() const;
  void _internal_set_transactionfee(uint64_t value);
  public:

  // bool generateRecord = 5 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_generaterecord();
  PROTOBUF_DEPRECATED bool generaterecord() const;
  PROTOBUF_DEPRECATED void set_generaterecord(bool value);
  private:
  bool _internal_generaterecord() const;
  void _internal_set_generaterecord(bool value);
  public:

  // .proto.ContractCallTransactionBody contractCall = 7;
  bool has_contractcall() const;
  private:
  bool _internal_has_contractcall() const;
  public:
  void clear_contractcall();
  const ::proto::ContractCallTransactionBody& contractcall() const;
  PROTOBUF_NODISCARD ::proto::ContractCallTransactionBody* release_contractcall();
  ::proto::ContractCallTransactionBody* mutable_contractcall();
  void set_allocated_contractcall(::proto::ContractCallTransactionBody* contractcall);
  private:
  const ::proto::ContractCallTransactionBody& _internal_contractcall() const;
  ::proto::ContractCallTransactionBody* _internal_mutable_contractcall();
  public:
  void unsafe_arena_set_allocated_contractcall(
      ::proto::ContractCallTransactionBody* contractcall);
  ::proto::ContractCallTransactionBody* unsafe_arena_release_contractcall();

  // .proto.ContractCreateTransactionBody contractCreateInstance = 8;
  bool has_contractcreateinstance() const;
  private:
  bool _internal_has_contractcreateinstance() const;
  public:
  void clear_contractcreateinstance();
  const ::proto::ContractCreateTransactionBody& contractcreateinstance() const;
  PROTOBUF_NODISCARD ::proto::ContractCreateTransactionBody* release_contractcreateinstance();
  ::proto::ContractCreateTransactionBody* mutable_contractcreateinstance();
  void set_allocated_contractcreateinstance(::proto::ContractCreateTransactionBody* contractcreateinstance);
  private:
  const ::proto::ContractCreateTransactionBody& _internal_contractcreateinstance() const;
  ::proto::ContractCreateTransactionBody* _internal_mutable_contractcreateinstance();
  public:
  void unsafe_arena_set_allocated_contractcreateinstance(
      ::proto::ContractCreateTransactionBody* contractcreateinstance);
  ::proto::ContractCreateTransactionBody* unsafe_arena_release_contractcreateinstance();

  // .proto.ContractUpdateTransactionBody contractUpdateInstance = 9;
  bool has_contractupdateinstance() const;
  private:
  bool _internal_has_contractupdateinstance() const;
  public:
  void clear_contractupdateinstance();
  const ::proto::ContractUpdateTransactionBody& contractupdateinstance() const;
  PROTOBUF_NODISCARD ::proto::ContractUpdateTransactionBody* release_contractupdateinstance();
  ::proto::ContractUpdateTransactionBody* mutable_contractupdateinstance();
  void set_allocated_contractupdateinstance(::proto::ContractUpdateTransactionBody* contractupdateinstance);
  private:
  const ::proto::ContractUpdateTransactionBody& _internal_contractupdateinstance() const;
  ::proto::ContractUpdateTransactionBody* _internal_mutable_contractupdateinstance();
  public:
  void unsafe_arena_set_allocated_contractupdateinstance(
      ::proto::ContractUpdateTransactionBody* contractupdateinstance);
  ::proto::ContractUpdateTransactionBody* unsafe_arena_release_contractupdateinstance();

  // .proto.ContractDeleteTransactionBody contractDeleteInstance = 22;
  bool has_contractdeleteinstance() const;
  private:
  bool _internal_has_contractdeleteinstance() const;
  public:
  void clear_contractdeleteinstance();
  const ::proto::ContractDeleteTransactionBody& contractdeleteinstance() const;
  PROTOBUF_NODISCARD ::proto::ContractDeleteTransactionBody* release_contractdeleteinstance();
  ::proto::ContractDeleteTransactionBody* mutable_contractdeleteinstance();
  void set_allocated_contractdeleteinstance(::proto::ContractDeleteTransactionBody* contractdeleteinstance);
  private:
  const ::proto::ContractDeleteTransactionBody& _internal_contractdeleteinstance() const;
  ::proto::ContractDeleteTransactionBody* _internal_mutable_contractdeleteinstance();
  public:
  void unsafe_arena_set_allocated_contractdeleteinstance(
      ::proto::ContractDeleteTransactionBody* contractdeleteinstance);
  ::proto::ContractDeleteTransactionBody* unsafe_arena_release_contractdeleteinstance();

  // .proto.EthereumTransactionBody ethereumTransaction = 50;
  bool has_ethereumtransaction() const;
  private:
  bool _internal_has_ethereumtransaction() const;
  public:
  void clear_ethereumtransaction();
  const ::proto::EthereumTransactionBody& ethereumtransaction() const;
  PROTOBUF_NODISCARD ::proto::EthereumTransactionBody* release_ethereumtransaction();
  ::proto::EthereumTransactionBody* mutable_ethereumtransaction();
  void set_allocated_ethereumtransaction(::proto::EthereumTransactionBody* ethereumtransaction);
  private:
  const ::proto::EthereumTransactionBody& _internal_ethereumtransaction() const;
  ::proto::EthereumTransactionBody* _internal_mutable_ethereumtransaction();
  public:
  void unsafe_arena_set_allocated_ethereumtransaction(
      ::proto::EthereumTransactionBody* ethereumtransaction);
  ::proto::EthereumTransactionBody* unsafe_arena_release_ethereumtransaction();

  // .proto.CryptoAddLiveHashTransactionBody cryptoAddLiveHash = 10;
  bool has_cryptoaddlivehash() const;
  private:
  bool _internal_has_cryptoaddlivehash() const;
  public:
  void clear_cryptoaddlivehash();
  const ::proto::CryptoAddLiveHashTransactionBody& cryptoaddlivehash() const;
  PROTOBUF_NODISCARD ::proto::CryptoAddLiveHashTransactionBody* release_cryptoaddlivehash();
  ::proto::CryptoAddLiveHashTransactionBody* mutable_cryptoaddlivehash();
  void set_allocated_cryptoaddlivehash(::proto::CryptoAddLiveHashTransactionBody* cryptoaddlivehash);
  private:
  const ::proto::CryptoAddLiveHashTransactionBody& _internal_cryptoaddlivehash() const;
  ::proto::CryptoAddLiveHashTransactionBody* _internal_mutable_cryptoaddlivehash();
  public:
  void unsafe_arena_set_allocated_cryptoaddlivehash(
      ::proto::CryptoAddLiveHashTransactionBody* cryptoaddlivehash);
  ::proto::CryptoAddLiveHashTransactionBody* unsafe_arena_release_cryptoaddlivehash();

  // .proto.CryptoApproveAllowanceTransactionBody cryptoApproveAllowance = 48;
  bool has_cryptoapproveallowance() const;
  private:
  bool _internal_has_cryptoapproveallowance() const;
  public:
  void clear_cryptoapproveallowance();
  const ::proto::CryptoApproveAllowanceTransactionBody& cryptoapproveallowance() const;
  PROTOBUF_NODISCARD ::proto::CryptoApproveAllowanceTransactionBody* release_cryptoapproveallowance();
  ::proto::CryptoApproveAllowanceTransactionBody* mutable_cryptoapproveallowance();
  void set_allocated_cryptoapproveallowance(::proto::CryptoApproveAllowanceTransactionBody* cryptoapproveallowance);
  private:
  const ::proto::CryptoApproveAllowanceTransactionBody& _internal_cryptoapproveallowance() const;
  ::proto::CryptoApproveAllowanceTransactionBody* _internal_mutable_cryptoapproveallowance();
  public:
  void unsafe_arena_set_allocated_cryptoapproveallowance(
      ::proto::CryptoApproveAllowanceTransactionBody* cryptoapproveallowance);
  ::proto::CryptoApproveAllowanceTransactionBody* unsafe_arena_release_cryptoapproveallowance();

  // .proto.CryptoDeleteAllowanceTransactionBody cryptoDeleteAllowance = 49;
  bool has_cryptodeleteallowance() const;
  private:
  bool _internal_has_cryptodeleteallowance() const;
  public:
  void clear_cryptodeleteallowance();
  const ::proto::CryptoDeleteAllowanceTransactionBody& cryptodeleteallowance() const;
  PROTOBUF_NODISCARD ::proto::CryptoDeleteAllowanceTransactionBody* release_cryptodeleteallowance();
  ::proto::CryptoDeleteAllowanceTransactionBody* mutable_cryptodeleteallowance();
  void set_allocated_cryptodeleteallowance(::proto::CryptoDeleteAllowanceTransactionBody* cryptodeleteallowance);
  private:
  const ::proto::CryptoDeleteAllowanceTransactionBody& _internal_cryptodeleteallowance() const;
  ::proto::CryptoDeleteAllowanceTransactionBody* _internal_mutable_cryptodeleteallowance();
  public:
  void unsafe_arena_set_allocated_cryptodeleteallowance(
      ::proto::CryptoDeleteAllowanceTransactionBody* cryptodeleteallowance);
  ::proto::CryptoDeleteAllowanceTransactionBody* unsafe_arena_release_cryptodeleteallowance();

  // .proto.CryptoCreateTransactionBody cryptoCreateAccount = 11;
  bool has_cryptocreateaccount() const;
  private:
  bool _internal_has_cryptocreateaccount() const;
  public:
  void clear_cryptocreateaccount();
  const ::proto::CryptoCreateTransactionBody& cryptocreateaccount() const;
  PROTOBUF_NODISCARD ::proto::CryptoCreateTransactionBody* release_cryptocreateaccount();
  ::proto::CryptoCreateTransactionBody* mutable_cryptocreateaccount();
  void set_allocated_cryptocreateaccount(::proto::CryptoCreateTransactionBody* cryptocreateaccount);
  private:
  const ::proto::CryptoCreateTransactionBody& _internal_cryptocreateaccount() const;
  ::proto::CryptoCreateTransactionBody* _internal_mutable_cryptocreateaccount();
  public:
  void unsafe_arena_set_allocated_cryptocreateaccount(
      ::proto::CryptoCreateTransactionBody* cryptocreateaccount);
  ::proto::CryptoCreateTransactionBody* unsafe_arena_release_cryptocreateaccount();

  // .proto.CryptoDeleteTransactionBody cryptoDelete = 12;
  bool has_cryptodelete() const;
  private:
  bool _internal_has_cryptodelete() const;
  public:
  void clear_cryptodelete();
  const ::proto::CryptoDeleteTransactionBody& cryptodelete() const;
  PROTOBUF_NODISCARD ::proto::CryptoDeleteTransactionBody* release_cryptodelete();
  ::proto::CryptoDeleteTransactionBody* mutable_cryptodelete();
  void set_allocated_cryptodelete(::proto::CryptoDeleteTransactionBody* cryptodelete);
  private:
  const ::proto::CryptoDeleteTransactionBody& _internal_cryptodelete() const;
  ::proto::CryptoDeleteTransactionBody* _internal_mutable_cryptodelete();
  public:
  void unsafe_arena_set_allocated_cryptodelete(
      ::proto::CryptoDeleteTransactionBody* cryptodelete);
  ::proto::CryptoDeleteTransactionBody* unsafe_arena_release_cryptodelete();

  // .proto.CryptoDeleteLiveHashTransactionBody cryptoDeleteLiveHash = 13;
  bool has_cryptodeletelivehash() const;
  private:
  bool _internal_has_cryptodeletelivehash() const;
  public:
  void clear_cryptodeletelivehash();
  const ::proto::CryptoDeleteLiveHashTransactionBody& cryptodeletelivehash() const;
  PROTOBUF_NODISCARD ::proto::CryptoDeleteLiveHashTransactionBody* release_cryptodeletelivehash();
  ::proto::CryptoDeleteLiveHashTransactionBody* mutable_cryptodeletelivehash();
  void set_allocated_cryptodeletelivehash(::proto::CryptoDeleteLiveHashTransactionBody* cryptodeletelivehash);
  private:
  const ::proto::CryptoDeleteLiveHashTransactionBody& _internal_cryptodeletelivehash() const;
  ::proto::CryptoDeleteLiveHashTransactionBody* _internal_mutable_cryptodeletelivehash();
  public:
  void unsafe_arena_set_allocated_cryptodeletelivehash(
      ::proto::CryptoDeleteLiveHashTransactionBody* cryptodeletelivehash);
  ::proto::CryptoDeleteLiveHashTransactionBody* unsafe_arena_release_cryptodeletelivehash();

  // .proto.CryptoTransferTransactionBody cryptoTransfer = 14;
  bool has_cryptotransfer() const;
  private:
  bool _internal_has_cryptotransfer() const;
  public:
  void clear_cryptotransfer();
  const ::proto::CryptoTransferTransactionBody& cryptotransfer() const;
  PROTOBUF_NODISCARD ::proto::CryptoTransferTransactionBody* release_cryptotransfer();
  ::proto::CryptoTransferTransactionBody* mutable_cryptotransfer();
  void set_allocated_cryptotransfer(::proto::CryptoTransferTransactionBody* cryptotransfer);
  private:
  const ::proto::CryptoTransferTransactionBody& _internal_cryptotransfer() const;
  ::proto::CryptoTransferTransactionBody* _internal_mutable_cryptotransfer();
  public:
  void unsafe_arena_set_allocated_cryptotransfer(
      ::proto::CryptoTransferTransactionBody* cryptotransfer);
  ::proto::CryptoTransferTransactionBody* unsafe_arena_release_cryptotransfer();

  // .proto.CryptoUpdateTransactionBody cryptoUpdateAccount = 15;
  bool has_cryptoupdateaccount() const;
  private:
  bool _internal_has_cryptoupdateaccount() const;
  public:
  void clear_cryptoupdateaccount();
  const ::proto::CryptoUpdateTransactionBody& cryptoupdateaccount() const;
  PROTOBUF_NODISCARD ::proto::CryptoUpdateTransactionBody* release_cryptoupdateaccount();
  ::proto::CryptoUpdateTransactionBody* mutable_cryptoupdateaccount();
  void set_allocated_cryptoupdateaccount(::proto::CryptoUpdateTransactionBody* cryptoupdateaccount);
  private:
  const ::proto::CryptoUpdateTransactionBody& _internal_cryptoupdateaccount() const;
  ::proto::CryptoUpdateTransactionBody* _internal_mutable_cryptoupdateaccount();
  public:
  void unsafe_arena_set_allocated_cryptoupdateaccount(
      ::proto::CryptoUpdateTransactionBody* cryptoupdateaccount);
  ::proto::CryptoUpdateTransactionBody* unsafe_arena_release_cryptoupdateaccount();

  // .proto.FileAppendTransactionBody fileAppend = 16;
  bool has_fileappend() const;
  private:
  bool _internal_has_fileappend() const;
  public:
  void clear_fileappend();
  const ::proto::FileAppendTransactionBody& fileappend() const;
  PROTOBUF_NODISCARD ::proto::FileAppendTransactionBody* release_fileappend();
  ::proto::FileAppendTransactionBody* mutable_fileappend();
  void set_allocated_fileappend(::proto::FileAppendTransactionBody* fileappend);
  private:
  const ::proto::FileAppendTransactionBody& _internal_fileappend() const;
  ::proto::FileAppendTransactionBody* _internal_mutable_fileappend();
  public:
  void unsafe_arena_set_allocated_fileappend(
      ::proto::FileAppendTransactionBody* fileappend);
  ::proto::FileAppendTransactionBody* unsafe_arena_release_fileappend();

  // .proto.FileCreateTransactionBody fileCreate = 17;
  bool has_filecreate() const;
  private:
  bool _internal_has_filecreate() const;
  public:
  void clear_filecreate();
  const ::proto::FileCreateTransactionBody& filecreate() const;
  PROTOBUF_NODISCARD ::proto::FileCreateTransactionBody* release_filecreate();
  ::proto::FileCreateTransactionBody* mutable_filecreate();
  void set_allocated_filecreate(::proto::FileCreateTransactionBody* filecreate);
  private:
  const ::proto::FileCreateTransactionBody& _internal_filecreate() const;
  ::proto::FileCreateTransactionBody* _internal_mutable_filecreate();
  public:
  void unsafe_arena_set_allocated_filecreate(
      ::proto::FileCreateTransactionBody* filecreate);
  ::proto::FileCreateTransactionBody* unsafe_arena_release_filecreate();

  // .proto.FileDeleteTransactionBody fileDelete = 18;
  bool has_filedelete() const;
  private:
  bool _internal_has_filedelete() const;
  public:
  void clear_filedelete();
  const ::proto::FileDeleteTransactionBody& filedelete() const;
  PROTOBUF_NODISCARD ::proto::FileDeleteTransactionBody* release_filedelete();
  ::proto::FileDeleteTransactionBody* mutable_filedelete();
  void set_allocated_filedelete(::proto::FileDeleteTransactionBody* filedelete);
  private:
  const ::proto::FileDeleteTransactionBody& _internal_filedelete() const;
  ::proto::FileDeleteTransactionBody* _internal_mutable_filedelete();
  public:
  void unsafe_arena_set_allocated_filedelete(
      ::proto::FileDeleteTransactionBody* filedelete);
  ::proto::FileDeleteTransactionBody* unsafe_arena_release_filedelete();

  // .proto.FileUpdateTransactionBody fileUpdate = 19;
  bool has_fileupdate() const;
  private:
  bool _internal_has_fileupdate() const;
  public:
  void clear_fileupdate();
  const ::proto::FileUpdateTransactionBody& fileupdate() const;
  PROTOBUF_NODISCARD ::proto::FileUpdateTransactionBody* release_fileupdate();
  ::proto::FileUpdateTransactionBody* mutable_fileupdate();
  void set_allocated_fileupdate(::proto::FileUpdateTransactionBody* fileupdate);
  private:
  const ::proto::FileUpdateTransactionBody& _internal_fileupdate() const;
  ::proto::FileUpdateTransactionBody* _internal_mutable_fileupdate();
  public:
  void unsafe_arena_set_allocated_fileupdate(
      ::proto::FileUpdateTransactionBody* fileupdate);
  ::proto::FileUpdateTransactionBody* unsafe_arena_release_fileupdate();

  // .proto.SystemDeleteTransactionBody systemDelete = 20;
  bool has_systemdelete() const;
  private:
  bool _internal_has_systemdelete() const;
  public:
  void clear_systemdelete();
  const ::proto::SystemDeleteTransactionBody& systemdelete() const;
  PROTOBUF_NODISCARD ::proto::SystemDeleteTransactionBody* release_systemdelete();
  ::proto::SystemDeleteTransactionBody* mutable_systemdelete();
  void set_allocated_systemdelete(::proto::SystemDeleteTransactionBody* systemdelete);
  private:
  const ::proto::SystemDeleteTransactionBody& _internal_systemdelete() const;
  ::proto::SystemDeleteTransactionBody* _internal_mutable_systemdelete();
  public:
  void unsafe_arena_set_allocated_systemdelete(
      ::proto::SystemDeleteTransactionBody* systemdelete);
  ::proto::SystemDeleteTransactionBody* unsafe_arena_release_systemdelete();

  // .proto.SystemUndeleteTransactionBody systemUndelete = 21;
  bool has_systemundelete() const;
  private:
  bool _internal_has_systemundelete() const;
  public:
  void clear_systemundelete();
  const ::proto::SystemUndeleteTransactionBody& systemundelete() const;
  PROTOBUF_NODISCARD ::proto::SystemUndeleteTransactionBody* release_systemundelete();
  ::proto::SystemUndeleteTransactionBody* mutable_systemundelete();
  void set_allocated_systemundelete(::proto::SystemUndeleteTransactionBody* systemundelete);
  private:
  const ::proto::SystemUndeleteTransactionBody& _internal_systemundelete() const;
  ::proto::SystemUndeleteTransactionBody* _internal_mutable_systemundelete();
  public:
  void unsafe_arena_set_allocated_systemundelete(
      ::proto::SystemUndeleteTransactionBody* systemundelete);
  ::proto::SystemUndeleteTransactionBody* unsafe_arena_release_systemundelete();

  // .proto.FreezeTransactionBody freeze = 23;
  bool has_freeze() const;
  private:
  bool _internal_has_freeze() const;
  public:
  void clear_freeze();
  const ::proto::FreezeTransactionBody& freeze() const;
  PROTOBUF_NODISCARD ::proto::FreezeTransactionBody* release_freeze();
  ::proto::FreezeTransactionBody* mutable_freeze();
  void set_allocated_freeze(::proto::FreezeTransactionBody* freeze);
  private:
  const ::proto::FreezeTransactionBody& _internal_freeze() const;
  ::proto::FreezeTransactionBody* _internal_mutable_freeze();
  public:
  void unsafe_arena_set_allocated_freeze(
      ::proto::FreezeTransactionBody* freeze);
  ::proto::FreezeTransactionBody* unsafe_arena_release_freeze();

  // .proto.ConsensusCreateTopicTransactionBody consensusCreateTopic = 24;
  bool has_consensuscreatetopic() const;
  private:
  bool _internal_has_consensuscreatetopic() const;
  public:
  void clear_consensuscreatetopic();
  const ::proto::ConsensusCreateTopicTransactionBody& consensuscreatetopic() const;
  PROTOBUF_NODISCARD ::proto::ConsensusCreateTopicTransactionBody* release_consensuscreatetopic();
  ::proto::ConsensusCreateTopicTransactionBody* mutable_consensuscreatetopic();
  void set_allocated_consensuscreatetopic(::proto::ConsensusCreateTopicTransactionBody* consensuscreatetopic);
  private:
  const ::proto::ConsensusCreateTopicTransactionBody& _internal_consensuscreatetopic() const;
  ::proto::ConsensusCreateTopicTransactionBody* _internal_mutable_consensuscreatetopic();
  public:
  void unsafe_arena_set_allocated_consensuscreatetopic(
      ::proto::ConsensusCreateTopicTransactionBody* consensuscreatetopic);
  ::proto::ConsensusCreateTopicTransactionBody* unsafe_arena_release_consensuscreatetopic();

  // .proto.ConsensusUpdateTopicTransactionBody consensusUpdateTopic = 25;
  bool has_consensusupdatetopic() const;
  private:
  bool _internal_has_consensusupdatetopic() const;
  public:
  void clear_consensusupdatetopic();
  const ::proto::ConsensusUpdateTopicTransactionBody& consensusupdatetopic() const;
  PROTOBUF_NODISCARD ::proto::ConsensusUpdateTopicTransactionBody* release_consensusupdatetopic();
  ::proto::ConsensusUpdateTopicTransactionBody* mutable_consensusupdatetopic();
  void set_allocated_consensusupdatetopic(::proto::ConsensusUpdateTopicTransactionBody* consensusupdatetopic);
  private:
  const ::proto::ConsensusUpdateTopicTransactionBody& _internal_consensusupdatetopic() const;
  ::proto::ConsensusUpdateTopicTransactionBody* _internal_mutable_consensusupdatetopic();
  public:
  void unsafe_arena_set_allocated_consensusupdatetopic(
      ::proto::ConsensusUpdateTopicTransactionBody* consensusupdatetopic);
  ::proto::ConsensusUpdateTopicTransactionBody* unsafe_arena_release_consensusupdatetopic();

  // .proto.ConsensusDeleteTopicTransactionBody consensusDeleteTopic = 26;
  bool has_consensusdeletetopic() const;
  private:
  bool _internal_has_consensusdeletetopic() const;
  public:
  void clear_consensusdeletetopic();
  const ::proto::ConsensusDeleteTopicTransactionBody& consensusdeletetopic() const;
  PROTOBUF_NODISCARD ::proto::ConsensusDeleteTopicTransactionBody* release_consensusdeletetopic();
  ::proto::ConsensusDeleteTopicTransactionBody* mutable_consensusdeletetopic();
  void set_allocated_consensusdeletetopic(::proto::ConsensusDeleteTopicTransactionBody* consensusdeletetopic);
  private:
  const ::proto::ConsensusDeleteTopicTransactionBody& _internal_consensusdeletetopic() const;
  ::proto::ConsensusDeleteTopicTransactionBody* _internal_mutable_consensusdeletetopic();
  public:
  void unsafe_arena_set_allocated_consensusdeletetopic(
      ::proto::ConsensusDeleteTopicTransactionBody* consensusdeletetopic);
  ::proto::ConsensusDeleteTopicTransactionBody* unsafe_arena_release_consensusdeletetopic();

  // .proto.ConsensusSubmitMessageTransactionBody consensusSubmitMessage = 27;
  bool has_consensussubmitmessage() const;
  private:
  bool _internal_has_consensussubmitmessage() const;
  public:
  void clear_consensussubmitmessage();
  const ::proto::ConsensusSubmitMessageTransactionBody& consensussubmitmessage() const;
  PROTOBUF_NODISCARD ::proto::ConsensusSubmitMessageTransactionBody* release_consensussubmitmessage();
  ::proto::ConsensusSubmitMessageTransactionBody* mutable_consensussubmitmessage();
  void set_allocated_consensussubmitmessage(::proto::ConsensusSubmitMessageTransactionBody* consensussubmitmessage);
  private:
  const ::proto::ConsensusSubmitMessageTransactionBody& _internal_consensussubmitmessage() const;
  ::proto::ConsensusSubmitMessageTransactionBody* _internal_mutable_consensussubmitmessage();
  public:
  void unsafe_arena_set_allocated_consensussubmitmessage(
      ::proto::ConsensusSubmitMessageTransactionBody* consensussubmitmessage);
  ::proto::ConsensusSubmitMessageTransactionBody* unsafe_arena_release_consensussubmitmessage();

  // .proto.UncheckedSubmitBody uncheckedSubmit = 28;
  bool has_uncheckedsubmit() const;
  private:
  bool _internal_has_uncheckedsubmit() const;
  public:
  void clear_uncheckedsubmit();
  const ::proto::UncheckedSubmitBody& uncheckedsubmit() const;
  PROTOBUF_NODISCARD ::proto::UncheckedSubmitBody* release_uncheckedsubmit();
  ::proto::UncheckedSubmitBody* mutable_uncheckedsubmit();
  void set_allocated_uncheckedsubmit(::proto::UncheckedSubmitBody* uncheckedsubmit);
  private:
  const ::proto::UncheckedSubmitBody& _internal_uncheckedsubmit() const;
  ::proto::UncheckedSubmitBody* _internal_mutable_uncheckedsubmit();
  public:
  void unsafe_arena_set_allocated_uncheckedsubmit(
      ::proto::UncheckedSubmitBody* uncheckedsubmit);
  ::proto::UncheckedSubmitBody* unsafe_arena_release_uncheckedsubmit();

  // .proto.TokenCreateTransactionBody tokenCreation = 29;
  bool has_tokencreation() const;
  private:
  bool _internal_has_tokencreation() const;
  public:
  void clear_tokencreation();
  const ::proto::TokenCreateTransactionBody& tokencreation() const;
  PROTOBUF_NODISCARD ::proto::TokenCreateTransactionBody* release_tokencreation();
  ::proto::TokenCreateTransactionBody* mutable_tokencreation();
  void set_allocated_tokencreation(::proto::TokenCreateTransactionBody* tokencreation);
  private:
  const ::proto::TokenCreateTransactionBody& _internal_tokencreation() const;
  ::proto::TokenCreateTransactionBody* _internal_mutable_tokencreation();
  public:
  void unsafe_arena_set_allocated_tokencreation(
      ::proto::TokenCreateTransactionBody* tokencreation);
  ::proto::TokenCreateTransactionBody* unsafe_arena_release_tokencreation();

  // .proto.TokenFreezeAccountTransactionBody tokenFreeze = 31;
  bool has_tokenfreeze() const;
  private:
  bool _internal_has_tokenfreeze() const;
  public:
  void clear_tokenfreeze();
  const ::proto::TokenFreezeAccountTransactionBody& tokenfreeze() const;
  PROTOBUF_NODISCARD ::proto::TokenFreezeAccountTransactionBody* release_tokenfreeze();
  ::proto::TokenFreezeAccountTransactionBody* mutable_tokenfreeze();
  void set_allocated_tokenfreeze(::proto::TokenFreezeAccountTransactionBody* tokenfreeze);
  private:
  const ::proto::TokenFreezeAccountTransactionBody& _internal_tokenfreeze() const;
  ::proto::TokenFreezeAccountTransactionBody* _internal_mutable_tokenfreeze();
  public:
  void unsafe_arena_set_allocated_tokenfreeze(
      ::proto::TokenFreezeAccountTransactionBody* tokenfreeze);
  ::proto::TokenFreezeAccountTransactionBody* unsafe_arena_release_tokenfreeze();

  // .proto.TokenUnfreezeAccountTransactionBody tokenUnfreeze = 32;
  bool has_tokenunfreeze() const;
  private:
  bool _internal_has_tokenunfreeze() const;
  public:
  void clear_tokenunfreeze();
  const ::proto::TokenUnfreezeAccountTransactionBody& tokenunfreeze() const;
  PROTOBUF_NODISCARD ::proto::TokenUnfreezeAccountTransactionBody* release_tokenunfreeze();
  ::proto::TokenUnfreezeAccountTransactionBody* mutable_tokenunfreeze();
  void set_allocated_tokenunfreeze(::proto::TokenUnfreezeAccountTransactionBody* tokenunfreeze);
  private:
  const ::proto::TokenUnfreezeAccountTransactionBody& _internal_tokenunfreeze() const;
  ::proto::TokenUnfreezeAccountTransactionBody* _internal_mutable_tokenunfreeze();
  public:
  void unsafe_arena_set_allocated_tokenunfreeze(
      ::proto::TokenUnfreezeAccountTransactionBody* tokenunfreeze);
  ::proto::TokenUnfreezeAccountTransactionBody* unsafe_arena_release_tokenunfreeze();

  // .proto.TokenGrantKycTransactionBody tokenGrantKyc = 33;
  bool has_tokengrantkyc() const;
  private:
  bool _internal_has_tokengrantkyc() const;
  public:
  void clear_tokengrantkyc();
  const ::proto::TokenGrantKycTransactionBody& tokengrantkyc() const;
  PROTOBUF_NODISCARD ::proto::TokenGrantKycTransactionBody* release_tokengrantkyc();
  ::proto::TokenGrantKycTransactionBody* mutable_tokengrantkyc();
  void set_allocated_tokengrantkyc(::proto::TokenGrantKycTransactionBody* tokengrantkyc);
  private:
  const ::proto::TokenGrantKycTransactionBody& _internal_tokengrantkyc() const;
  ::proto::TokenGrantKycTransactionBody* _internal_mutable_tokengrantkyc();
  public:
  void unsafe_arena_set_allocated_tokengrantkyc(
      ::proto::TokenGrantKycTransactionBody* tokengrantkyc);
  ::proto::TokenGrantKycTransactionBody* unsafe_arena_release_tokengrantkyc();

  // .proto.TokenRevokeKycTransactionBody tokenRevokeKyc = 34;
  bool has_tokenrevokekyc() const;
  private:
  bool _internal_has_tokenrevokekyc() const;
  public:
  void clear_tokenrevokekyc();
  const ::proto::TokenRevokeKycTransactionBody& tokenrevokekyc() const;
  PROTOBUF_NODISCARD ::proto::TokenRevokeKycTransactionBody* release_tokenrevokekyc();
  ::proto::TokenRevokeKycTransactionBody* mutable_tokenrevokekyc();
  void set_allocated_tokenrevokekyc(::proto::TokenRevokeKycTransactionBody* tokenrevokekyc);
  private:
  const ::proto::TokenRevokeKycTransactionBody& _internal_tokenrevokekyc() const;
  ::proto::TokenRevokeKycTransactionBody* _internal_mutable_tokenrevokekyc();
  public:
  void unsafe_arena_set_allocated_tokenrevokekyc(
      ::proto::TokenRevokeKycTransactionBody* tokenrevokekyc);
  ::proto::TokenRevokeKycTransactionBody* unsafe_arena_release_tokenrevokekyc();

  // .proto.TokenDeleteTransactionBody tokenDeletion = 35;
  bool has_tokendeletion() const;
  private:
  bool _internal_has_tokendeletion() const;
  public:
  void clear_tokendeletion();
  const ::proto::TokenDeleteTransactionBody& tokendeletion() const;
  PROTOBUF_NODISCARD ::proto::TokenDeleteTransactionBody* release_tokendeletion();
  ::proto::TokenDeleteTransactionBody* mutable_tokendeletion();
  void set_allocated_tokendeletion(::proto::TokenDeleteTransactionBody* tokendeletion);
  private:
  const ::proto::TokenDeleteTransactionBody& _internal_tokendeletion() const;
  ::proto::TokenDeleteTransactionBody* _internal_mutable_tokendeletion();
  public:
  void unsafe_arena_set_allocated_tokendeletion(
      ::proto::TokenDeleteTransactionBody* tokendeletion);
  ::proto::TokenDeleteTransactionBody* unsafe_arena_release_tokendeletion();

  // .proto.TokenUpdateTransactionBody tokenUpdate = 36;
  bool has_tokenupdate() const;
  private:
  bool _internal_has_tokenupdate() const;
  public:
  void clear_tokenupdate();
  const ::proto::TokenUpdateTransactionBody& tokenupdate() const;
  PROTOBUF_NODISCARD ::proto::TokenUpdateTransactionBody* release_tokenupdate();
  ::proto::TokenUpdateTransactionBody* mutable_tokenupdate();
  void set_allocated_tokenupdate(::proto::TokenUpdateTransactionBody* tokenupdate);
  private:
  const ::proto::TokenUpdateTransactionBody& _internal_tokenupdate() const;
  ::proto::TokenUpdateTransactionBody* _internal_mutable_tokenupdate();
  public:
  void unsafe_arena_set_allocated_tokenupdate(
      ::proto::TokenUpdateTransactionBody* tokenupdate);
  ::proto::TokenUpdateTransactionBody* unsafe_arena_release_tokenupdate();

  // .proto.TokenMintTransactionBody tokenMint = 37;
  bool has_tokenmint() const;
  private:
  bool _internal_has_tokenmint() const;
  public:
  void clear_tokenmint();
  const ::proto::TokenMintTransactionBody& tokenmint() const;
  PROTOBUF_NODISCARD ::proto::TokenMintTransactionBody* release_tokenmint();
  ::proto::TokenMintTransactionBody* mutable_tokenmint();
  void set_allocated_tokenmint(::proto::TokenMintTransactionBody* tokenmint);
  private:
  const ::proto::TokenMintTransactionBody& _internal_tokenmint() const;
  ::proto::TokenMintTransactionBody* _internal_mutable_tokenmint();
  public:
  void unsafe_arena_set_allocated_tokenmint(
      ::proto::TokenMintTransactionBody* tokenmint);
  ::proto::TokenMintTransactionBody* unsafe_arena_release_tokenmint();

  // .proto.TokenBurnTransactionBody tokenBurn = 38;
  bool has_tokenburn() const;
  private:
  bool _internal_has_tokenburn() const;
  public:
  void clear_tokenburn();
  const ::proto::TokenBurnTransactionBody& tokenburn() const;
  PROTOBUF_NODISCARD ::proto::TokenBurnTransactionBody* release_tokenburn();
  ::proto::TokenBurnTransactionBody* mutable_tokenburn();
  void set_allocated_tokenburn(::proto::TokenBurnTransactionBody* tokenburn);
  private:
  const ::proto::TokenBurnTransactionBody& _internal_tokenburn() const;
  ::proto::TokenBurnTransactionBody* _internal_mutable_tokenburn();
  public:
  void unsafe_arena_set_allocated_tokenburn(
      ::proto::TokenBurnTransactionBody* tokenburn);
  ::proto::TokenBurnTransactionBody* unsafe_arena_release_tokenburn();

  // .proto.TokenWipeAccountTransactionBody tokenWipe = 39;
  bool has_tokenwipe() const;
  private:
  bool _internal_has_tokenwipe() const;
  public:
  void clear_tokenwipe();
  const ::proto::TokenWipeAccountTransactionBody& tokenwipe() const;
  PROTOBUF_NODISCARD ::proto::TokenWipeAccountTransactionBody* release_tokenwipe();
  ::proto::TokenWipeAccountTransactionBody* mutable_tokenwipe();
  void set_allocated_tokenwipe(::proto::TokenWipeAccountTransactionBody* tokenwipe);
  private:
  const ::proto::TokenWipeAccountTransactionBody& _internal_tokenwipe() const;
  ::proto::TokenWipeAccountTransactionBody* _internal_mutable_tokenwipe();
  public:
  void unsafe_arena_set_allocated_tokenwipe(
      ::proto::TokenWipeAccountTransactionBody* tokenwipe);
  ::proto::TokenWipeAccountTransactionBody* unsafe_arena_release_tokenwipe();

  // .proto.TokenAssociateTransactionBody tokenAssociate = 40;
  bool has_tokenassociate() const;
  private:
  bool _internal_has_tokenassociate() const;
  public:
  void clear_tokenassociate();
  const ::proto::TokenAssociateTransactionBody& tokenassociate() const;
  PROTOBUF_NODISCARD ::proto::TokenAssociateTransactionBody* release_tokenassociate();
  ::proto::TokenAssociateTransactionBody* mutable_tokenassociate();
  void set_allocated_tokenassociate(::proto::TokenAssociateTransactionBody* tokenassociate);
  private:
  const ::proto::TokenAssociateTransactionBody& _internal_tokenassociate() const;
  ::proto::TokenAssociateTransactionBody* _internal_mutable_tokenassociate();
  public:
  void unsafe_arena_set_allocated_tokenassociate(
      ::proto::TokenAssociateTransactionBody* tokenassociate);
  ::proto::TokenAssociateTransactionBody* unsafe_arena_release_tokenassociate();

  // .proto.TokenDissociateTransactionBody tokenDissociate = 41;
  bool has_tokendissociate() const;
  private:
  bool _internal_has_tokendissociate() const;
  public:
  void clear_tokendissociate();
  const ::proto::TokenDissociateTransactionBody& tokendissociate() const;
  PROTOBUF_NODISCARD ::proto::TokenDissociateTransactionBody* release_tokendissociate();
  ::proto::TokenDissociateTransactionBody* mutable_tokendissociate();
  void set_allocated_tokendissociate(::proto::TokenDissociateTransactionBody* tokendissociate);
  private:
  const ::proto::TokenDissociateTransactionBody& _internal_tokendissociate() const;
  ::proto::TokenDissociateTransactionBody* _internal_mutable_tokendissociate();
  public:
  void unsafe_arena_set_allocated_tokendissociate(
      ::proto::TokenDissociateTransactionBody* tokendissociate);
  ::proto::TokenDissociateTransactionBody* unsafe_arena_release_tokendissociate();

  // .proto.TokenFeeScheduleUpdateTransactionBody token_fee_schedule_update = 45;
  bool has_token_fee_schedule_update() const;
  private:
  bool _internal_has_token_fee_schedule_update() const;
  public:
  void clear_token_fee_schedule_update();
  const ::proto::TokenFeeScheduleUpdateTransactionBody& token_fee_schedule_update() const;
  PROTOBUF_NODISCARD ::proto::TokenFeeScheduleUpdateTransactionBody* release_token_fee_schedule_update();
  ::proto::TokenFeeScheduleUpdateTransactionBody* mutable_token_fee_schedule_update();
  void set_allocated_token_fee_schedule_update(::proto::TokenFeeScheduleUpdateTransactionBody* token_fee_schedule_update);
  private:
  const ::proto::TokenFeeScheduleUpdateTransactionBody& _internal_token_fee_schedule_update() const;
  ::proto::TokenFeeScheduleUpdateTransactionBody* _internal_mutable_token_fee_schedule_update();
  public:
  void unsafe_arena_set_allocated_token_fee_schedule_update(
      ::proto::TokenFeeScheduleUpdateTransactionBody* token_fee_schedule_update);
  ::proto::TokenFeeScheduleUpdateTransactionBody* unsafe_arena_release_token_fee_schedule_update();

  // .proto.TokenPauseTransactionBody token_pause = 46;
  bool has_token_pause() const;
  private:
  bool _internal_has_token_pause() const;
  public:
  void clear_token_pause();
  const ::proto::TokenPauseTransactionBody& token_pause() const;
  PROTOBUF_NODISCARD ::proto::TokenPauseTransactionBody* release_token_pause();
  ::proto::TokenPauseTransactionBody* mutable_token_pause();
  void set_allocated_token_pause(::proto::TokenPauseTransactionBody* token_pause);
  private:
  const ::proto::TokenPauseTransactionBody& _internal_token_pause() const;
  ::proto::TokenPauseTransactionBody* _internal_mutable_token_pause();
  public:
  void unsafe_arena_set_allocated_token_pause(
      ::proto::TokenPauseTransactionBody* token_pause);
  ::proto::TokenPauseTransactionBody* unsafe_arena_release_token_pause();

  // .proto.TokenUnpauseTransactionBody token_unpause = 47;
  bool has_token_unpause() const;
  private:
  bool _internal_has_token_unpause() const;
  public:
  void clear_token_unpause();
  const ::proto::TokenUnpauseTransactionBody& token_unpause() const;
  PROTOBUF_NODISCARD ::proto::TokenUnpauseTransactionBody* release_token_unpause();
  ::proto::TokenUnpauseTransactionBody* mutable_token_unpause();
  void set_allocated_token_unpause(::proto::TokenUnpauseTransactionBody* token_unpause);
  private:
  const ::proto::TokenUnpauseTransactionBody& _internal_token_unpause() const;
  ::proto::TokenUnpauseTransactionBody* _internal_mutable_token_unpause();
  public:
  void unsafe_arena_set_allocated_token_unpause(
      ::proto::TokenUnpauseTransactionBody* token_unpause);
  ::proto::TokenUnpauseTransactionBody* unsafe_arena_release_token_unpause();

  // .proto.ScheduleCreateTransactionBody scheduleCreate = 42;
  bool has_schedulecreate() const;
  private:
  bool _internal_has_schedulecreate() const;
  public:
  void clear_schedulecreate();
  const ::proto::ScheduleCreateTransactionBody& schedulecreate() const;
  PROTOBUF_NODISCARD ::proto::ScheduleCreateTransactionBody* release_schedulecreate();
  ::proto::ScheduleCreateTransactionBody* mutable_schedulecreate();
  void set_allocated_schedulecreate(::proto::ScheduleCreateTransactionBody* schedulecreate);
  private:
  const ::proto::ScheduleCreateTransactionBody& _internal_schedulecreate() const;
  ::proto::ScheduleCreateTransactionBody* _internal_mutable_schedulecreate();
  public:
  void unsafe_arena_set_allocated_schedulecreate(
      ::proto::ScheduleCreateTransactionBody* schedulecreate);
  ::proto::ScheduleCreateTransactionBody* unsafe_arena_release_schedulecreate();

  // .proto.ScheduleDeleteTransactionBody scheduleDelete = 43;
  bool has_scheduledelete() const;
  private:
  bool _internal_has_scheduledelete() const;
  public:
  void clear_scheduledelete();
  const ::proto::ScheduleDeleteTransactionBody& scheduledelete() const;
  PROTOBUF_NODISCARD ::proto::ScheduleDeleteTransactionBody* release_scheduledelete();
  ::proto::ScheduleDeleteTransactionBody* mutable_scheduledelete();
  void set_allocated_scheduledelete(::proto::ScheduleDeleteTransactionBody* scheduledelete);
  private:
  const ::proto::ScheduleDeleteTransactionBody& _internal_scheduledelete() const;
  ::proto::ScheduleDeleteTransactionBody* _internal_mutable_scheduledelete();
  public:
  void unsafe_arena_set_allocated_scheduledelete(
      ::proto::ScheduleDeleteTransactionBody* scheduledelete);
  ::proto::ScheduleDeleteTransactionBody* unsafe_arena_release_scheduledelete();

  // .proto.ScheduleSignTransactionBody scheduleSign = 44;
  bool has_schedulesign() const;
  private:
  bool _internal_has_schedulesign() const;
  public:
  void clear_schedulesign();
  const ::proto::ScheduleSignTransactionBody& schedulesign() const;
  PROTOBUF_NODISCARD ::proto::ScheduleSignTransactionBody* release_schedulesign();
  ::proto::ScheduleSignTransactionBody* mutable_schedulesign();
  void set_allocated_schedulesign(::proto::ScheduleSignTransactionBody* schedulesign);
  private:
  const ::proto::ScheduleSignTransactionBody& _internal_schedulesign() const;
  ::proto::ScheduleSignTransactionBody* _internal_mutable_schedulesign();
  public:
  void unsafe_arena_set_allocated_schedulesign(
      ::proto::ScheduleSignTransactionBody* schedulesign);
  ::proto::ScheduleSignTransactionBody* unsafe_arena_release_schedulesign();

  // .proto.NodeStakeUpdateTransactionBody node_stake_update = 51;
  bool has_node_stake_update() const;
  private:
  bool _internal_has_node_stake_update() const;
  public:
  void clear_node_stake_update();
  const ::proto::NodeStakeUpdateTransactionBody& node_stake_update() const;
  PROTOBUF_NODISCARD ::proto::NodeStakeUpdateTransactionBody* release_node_stake_update();
  ::proto::NodeStakeUpdateTransactionBody* mutable_node_stake_update();
  void set_allocated_node_stake_update(::proto::NodeStakeUpdateTransactionBody* node_stake_update);
  private:
  const ::proto::NodeStakeUpdateTransactionBody& _internal_node_stake_update() const;
  ::proto::NodeStakeUpdateTransactionBody* _internal_mutable_node_stake_update();
  public:
  void unsafe_arena_set_allocated_node_stake_update(
      ::proto::NodeStakeUpdateTransactionBody* node_stake_update);
  ::proto::NodeStakeUpdateTransactionBody* unsafe_arena_release_node_stake_update();

  // .proto.UtilPrngTransactionBody util_prng = 52;
  bool has_util_prng() const;
  private:
  bool _internal_has_util_prng() const;
  public:
  void clear_util_prng();
  const ::proto::UtilPrngTransactionBody& util_prng() const;
  PROTOBUF_NODISCARD ::proto::UtilPrngTransactionBody* release_util_prng();
  ::proto::UtilPrngTransactionBody* mutable_util_prng();
  void set_allocated_util_prng(::proto::UtilPrngTransactionBody* util_prng);
  private:
  const ::proto::UtilPrngTransactionBody& _internal_util_prng() const;
  ::proto::UtilPrngTransactionBody* _internal_mutable_util_prng();
  public:
  void unsafe_arena_set_allocated_util_prng(
      ::proto::UtilPrngTransactionBody* util_prng);
  ::proto::UtilPrngTransactionBody* unsafe_arena_release_util_prng();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:proto.TransactionBody)
 private:
  class _Internal;
  void set_has_contractcall();
  void set_has_contractcreateinstance();
  void set_has_contractupdateinstance();
  void set_has_contractdeleteinstance();
  void set_has_ethereumtransaction();
  void set_has_cryptoaddlivehash();
  void set_has_cryptoapproveallowance();
  void set_has_cryptodeleteallowance();
  void set_has_cryptocreateaccount();
  void set_has_cryptodelete();
  void set_has_cryptodeletelivehash();
  void set_has_cryptotransfer();
  void set_has_cryptoupdateaccount();
  void set_has_fileappend();
  void set_has_filecreate();
  void set_has_filedelete();
  void set_has_fileupdate();
  void set_has_systemdelete();
  void set_has_systemundelete();
  void set_has_freeze();
  void set_has_consensuscreatetopic();
  void set_has_consensusupdatetopic();
  void set_has_consensusdeletetopic();
  void set_has_consensussubmitmessage();
  void set_has_uncheckedsubmit();
  void set_has_tokencreation();
  void set_has_tokenfreeze();
  void set_has_tokenunfreeze();
  void set_has_tokengrantkyc();
  void set_has_tokenrevokekyc();
  void set_has_tokendeletion();
  void set_has_tokenupdate();
  void set_has_tokenmint();
  void set_has_tokenburn();
  void set_has_tokenwipe();
  void set_has_tokenassociate();
  void set_has_tokendissociate();
  void set_has_token_fee_schedule_update();
  void set_has_token_pause();
  void set_has_token_unpause();
  void set_has_schedulecreate();
  void set_has_scheduledelete();
  void set_has_schedulesign();
  void set_has_node_stake_update();
  void set_has_util_prng();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memo_;
    ::proto::TransactionID* transactionid_;
    ::proto::AccountID* nodeaccountid_;
    ::proto::Duration* transactionvalidduration_;
    uint64_t transactionfee_;
    bool generaterecord_;
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::proto::ContractCallTransactionBody* contractcall_;
      ::proto::ContractCreateTransactionBody* contractcreateinstance_;
      ::proto::ContractUpdateTransactionBody* contractupdateinstance_;
      ::proto::ContractDeleteTransactionBody* contractdeleteinstance_;
      ::proto::EthereumTransactionBody* ethereumtransaction_;
      ::proto::CryptoAddLiveHashTransactionBody* cryptoaddlivehash_;
      ::proto::CryptoApproveAllowanceTransactionBody* cryptoapproveallowance_;
      ::proto::CryptoDeleteAllowanceTransactionBody* cryptodeleteallowance_;
      ::proto::CryptoCreateTransactionBody* cryptocreateaccount_;
      ::proto::CryptoDeleteTransactionBody* cryptodelete_;
      ::proto::CryptoDeleteLiveHashTransactionBody* cryptodeletelivehash_;
      ::proto::CryptoTransferTransactionBody* cryptotransfer_;
      ::proto::CryptoUpdateTransactionBody* cryptoupdateaccount_;
      ::proto::FileAppendTransactionBody* fileappend_;
      ::proto::FileCreateTransactionBody* filecreate_;
      ::proto::FileDeleteTransactionBody* filedelete_;
      ::proto::FileUpdateTransactionBody* fileupdate_;
      ::proto::SystemDeleteTransactionBody* systemdelete_;
      ::proto::SystemUndeleteTransactionBody* systemundelete_;
      ::proto::FreezeTransactionBody* freeze_;
      ::proto::ConsensusCreateTopicTransactionBody* consensuscreatetopic_;
      ::proto::ConsensusUpdateTopicTransactionBody* consensusupdatetopic_;
      ::proto::ConsensusDeleteTopicTransactionBody* consensusdeletetopic_;
      ::proto::ConsensusSubmitMessageTransactionBody* consensussubmitmessage_;
      ::proto::UncheckedSubmitBody* uncheckedsubmit_;
      ::proto::TokenCreateTransactionBody* tokencreation_;
      ::proto::TokenFreezeAccountTransactionBody* tokenfreeze_;
      ::proto::TokenUnfreezeAccountTransactionBody* tokenunfreeze_;
      ::proto::TokenGrantKycTransactionBody* tokengrantkyc_;
      ::proto::TokenRevokeKycTransactionBody* tokenrevokekyc_;
      ::proto::TokenDeleteTransactionBody* tokendeletion_;
      ::proto::TokenUpdateTransactionBody* tokenupdate_;
      ::proto::TokenMintTransactionBody* tokenmint_;
      ::proto::TokenBurnTransactionBody* tokenburn_;
      ::proto::TokenWipeAccountTransactionBody* tokenwipe_;
      ::proto::TokenAssociateTransactionBody* tokenassociate_;
      ::proto::TokenDissociateTransactionBody* tokendissociate_;
      ::proto::TokenFeeScheduleUpdateTransactionBody* token_fee_schedule_update_;
      ::proto::TokenPauseTransactionBody* token_pause_;
      ::proto::TokenUnpauseTransactionBody* token_unpause_;
      ::proto::ScheduleCreateTransactionBody* schedulecreate_;
      ::proto::ScheduleDeleteTransactionBody* scheduledelete_;
      ::proto::ScheduleSignTransactionBody* schedulesign_;
      ::proto::NodeStakeUpdateTransactionBody* node_stake_update_;
      ::proto::UtilPrngTransactionBody* util_prng_;
    } data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transaction_5fbody_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TransactionBody

// .proto.TransactionID transactionID = 1;
inline bool TransactionBody::_internal_has_transactionid() const {
  return this != internal_default_instance() && _impl_.transactionid_ != nullptr;
}
inline bool TransactionBody::has_transactionid() const {
  return _internal_has_transactionid();
}
inline const ::proto::TransactionID& TransactionBody::_internal_transactionid() const {
  const ::proto::TransactionID* p = _impl_.transactionid_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::TransactionID&>(
      ::proto::_TransactionID_default_instance_);
}
inline const ::proto::TransactionID& TransactionBody::transactionid() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.transactionID)
  return _internal_transactionid();
}
inline void TransactionBody::unsafe_arena_set_allocated_transactionid(
    ::proto::TransactionID* transactionid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transactionid_);
  }
  _impl_.transactionid_ = transactionid;
  if (transactionid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.transactionID)
}
inline ::proto::TransactionID* TransactionBody::release_transactionid() {
  
  ::proto::TransactionID* temp = _impl_.transactionid_;
  _impl_.transactionid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::TransactionID* TransactionBody::unsafe_arena_release_transactionid() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.transactionID)
  
  ::proto::TransactionID* temp = _impl_.transactionid_;
  _impl_.transactionid_ = nullptr;
  return temp;
}
inline ::proto::TransactionID* TransactionBody::_internal_mutable_transactionid() {
  
  if (_impl_.transactionid_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::TransactionID>(GetArenaForAllocation());
    _impl_.transactionid_ = p;
  }
  return _impl_.transactionid_;
}
inline ::proto::TransactionID* TransactionBody::mutable_transactionid() {
  ::proto::TransactionID* _msg = _internal_mutable_transactionid();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.transactionID)
  return _msg;
}
inline void TransactionBody::set_allocated_transactionid(::proto::TransactionID* transactionid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transactionid_);
  }
  if (transactionid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transactionid));
    if (message_arena != submessage_arena) {
      transactionid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transactionid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transactionid_ = transactionid;
  // @@protoc_insertion_point(field_set_allocated:proto.TransactionBody.transactionID)
}

// .proto.AccountID nodeAccountID = 2;
inline bool TransactionBody::_internal_has_nodeaccountid() const {
  return this != internal_default_instance() && _impl_.nodeaccountid_ != nullptr;
}
inline bool TransactionBody::has_nodeaccountid() const {
  return _internal_has_nodeaccountid();
}
inline const ::proto::AccountID& TransactionBody::_internal_nodeaccountid() const {
  const ::proto::AccountID* p = _impl_.nodeaccountid_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::AccountID&>(
      ::proto::_AccountID_default_instance_);
}
inline const ::proto::AccountID& TransactionBody::nodeaccountid() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.nodeAccountID)
  return _internal_nodeaccountid();
}
inline void TransactionBody::unsafe_arena_set_allocated_nodeaccountid(
    ::proto::AccountID* nodeaccountid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nodeaccountid_);
  }
  _impl_.nodeaccountid_ = nodeaccountid;
  if (nodeaccountid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.nodeAccountID)
}
inline ::proto::AccountID* TransactionBody::release_nodeaccountid() {
  
  ::proto::AccountID* temp = _impl_.nodeaccountid_;
  _impl_.nodeaccountid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::AccountID* TransactionBody::unsafe_arena_release_nodeaccountid() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.nodeAccountID)
  
  ::proto::AccountID* temp = _impl_.nodeaccountid_;
  _impl_.nodeaccountid_ = nullptr;
  return temp;
}
inline ::proto::AccountID* TransactionBody::_internal_mutable_nodeaccountid() {
  
  if (_impl_.nodeaccountid_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::AccountID>(GetArenaForAllocation());
    _impl_.nodeaccountid_ = p;
  }
  return _impl_.nodeaccountid_;
}
inline ::proto::AccountID* TransactionBody::mutable_nodeaccountid() {
  ::proto::AccountID* _msg = _internal_mutable_nodeaccountid();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.nodeAccountID)
  return _msg;
}
inline void TransactionBody::set_allocated_nodeaccountid(::proto::AccountID* nodeaccountid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nodeaccountid_);
  }
  if (nodeaccountid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nodeaccountid));
    if (message_arena != submessage_arena) {
      nodeaccountid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodeaccountid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nodeaccountid_ = nodeaccountid;
  // @@protoc_insertion_point(field_set_allocated:proto.TransactionBody.nodeAccountID)
}

// uint64 transactionFee = 3;
inline void TransactionBody::clear_transactionfee() {
  _impl_.transactionfee_ = uint64_t{0u};
}
inline uint64_t TransactionBody::_internal_transactionfee() const {
  return _impl_.transactionfee_;
}
inline uint64_t TransactionBody::transactionfee() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.transactionFee)
  return _internal_transactionfee();
}
inline void TransactionBody::_internal_set_transactionfee(uint64_t value) {
  
  _impl_.transactionfee_ = value;
}
inline void TransactionBody::set_transactionfee(uint64_t value) {
  _internal_set_transactionfee(value);
  // @@protoc_insertion_point(field_set:proto.TransactionBody.transactionFee)
}

// .proto.Duration transactionValidDuration = 4;
inline bool TransactionBody::_internal_has_transactionvalidduration() const {
  return this != internal_default_instance() && _impl_.transactionvalidduration_ != nullptr;
}
inline bool TransactionBody::has_transactionvalidduration() const {
  return _internal_has_transactionvalidduration();
}
inline const ::proto::Duration& TransactionBody::_internal_transactionvalidduration() const {
  const ::proto::Duration* p = _impl_.transactionvalidduration_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Duration&>(
      ::proto::_Duration_default_instance_);
}
inline const ::proto::Duration& TransactionBody::transactionvalidduration() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.transactionValidDuration)
  return _internal_transactionvalidduration();
}
inline void TransactionBody::unsafe_arena_set_allocated_transactionvalidduration(
    ::proto::Duration* transactionvalidduration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transactionvalidduration_);
  }
  _impl_.transactionvalidduration_ = transactionvalidduration;
  if (transactionvalidduration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.transactionValidDuration)
}
inline ::proto::Duration* TransactionBody::release_transactionvalidduration() {
  
  ::proto::Duration* temp = _impl_.transactionvalidduration_;
  _impl_.transactionvalidduration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Duration* TransactionBody::unsafe_arena_release_transactionvalidduration() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.transactionValidDuration)
  
  ::proto::Duration* temp = _impl_.transactionvalidduration_;
  _impl_.transactionvalidduration_ = nullptr;
  return temp;
}
inline ::proto::Duration* TransactionBody::_internal_mutable_transactionvalidduration() {
  
  if (_impl_.transactionvalidduration_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Duration>(GetArenaForAllocation());
    _impl_.transactionvalidduration_ = p;
  }
  return _impl_.transactionvalidduration_;
}
inline ::proto::Duration* TransactionBody::mutable_transactionvalidduration() {
  ::proto::Duration* _msg = _internal_mutable_transactionvalidduration();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.transactionValidDuration)
  return _msg;
}
inline void TransactionBody::set_allocated_transactionvalidduration(::proto::Duration* transactionvalidduration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transactionvalidduration_);
  }
  if (transactionvalidduration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transactionvalidduration));
    if (message_arena != submessage_arena) {
      transactionvalidduration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transactionvalidduration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transactionvalidduration_ = transactionvalidduration;
  // @@protoc_insertion_point(field_set_allocated:proto.TransactionBody.transactionValidDuration)
}

// bool generateRecord = 5 [deprecated = true];
inline void TransactionBody::clear_generaterecord() {
  _impl_.generaterecord_ = false;
}
inline bool TransactionBody::_internal_generaterecord() const {
  return _impl_.generaterecord_;
}
inline bool TransactionBody::generaterecord() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.generateRecord)
  return _internal_generaterecord();
}
inline void TransactionBody::_internal_set_generaterecord(bool value) {
  
  _impl_.generaterecord_ = value;
}
inline void TransactionBody::set_generaterecord(bool value) {
  _internal_set_generaterecord(value);
  // @@protoc_insertion_point(field_set:proto.TransactionBody.generateRecord)
}

// string memo = 6;
inline void TransactionBody::clear_memo() {
  _impl_.memo_.ClearToEmpty();
}
inline const std::string& TransactionBody::memo() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.memo)
  return _internal_memo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionBody::set_memo(ArgT0&& arg0, ArgT... args) {
 
 _impl_.memo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.TransactionBody.memo)
}
inline std::string* TransactionBody::mutable_memo() {
  std::string* _s = _internal_mutable_memo();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.memo)
  return _s;
}
inline const std::string& TransactionBody::_internal_memo() const {
  return _impl_.memo_.Get();
}
inline void TransactionBody::_internal_set_memo(const std::string& value) {
  
  _impl_.memo_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionBody::_internal_mutable_memo() {
  
  return _impl_.memo_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionBody::release_memo() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.memo)
  return _impl_.memo_.Release();
}
inline void TransactionBody::set_allocated_memo(std::string* memo) {
  if (memo != nullptr) {
    
  } else {
    
  }
  _impl_.memo_.SetAllocated(memo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.memo_.IsDefault()) {
    _impl_.memo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.TransactionBody.memo)
}

// .proto.ContractCallTransactionBody contractCall = 7;
inline bool TransactionBody::_internal_has_contractcall() const {
  return data_case() == kContractCall;
}
inline bool TransactionBody::has_contractcall() const {
  return _internal_has_contractcall();
}
inline void TransactionBody::set_has_contractcall() {
  _impl_._oneof_case_[0] = kContractCall;
}
inline ::proto::ContractCallTransactionBody* TransactionBody::release_contractcall() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.contractCall)
  if (_internal_has_contractcall()) {
    clear_has_data();
    ::proto::ContractCallTransactionBody* temp = _impl_.data_.contractcall_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.contractcall_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ContractCallTransactionBody& TransactionBody::_internal_contractcall() const {
  return _internal_has_contractcall()
      ? *_impl_.data_.contractcall_
      : reinterpret_cast< ::proto::ContractCallTransactionBody&>(::proto::_ContractCallTransactionBody_default_instance_);
}
inline const ::proto::ContractCallTransactionBody& TransactionBody::contractcall() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.contractCall)
  return _internal_contractcall();
}
inline ::proto::ContractCallTransactionBody* TransactionBody::unsafe_arena_release_contractcall() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.contractCall)
  if (_internal_has_contractcall()) {
    clear_has_data();
    ::proto::ContractCallTransactionBody* temp = _impl_.data_.contractcall_;
    _impl_.data_.contractcall_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_contractcall(::proto::ContractCallTransactionBody* contractcall) {
  clear_data();
  if (contractcall) {
    set_has_contractcall();
    _impl_.data_.contractcall_ = contractcall;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.contractCall)
}
inline ::proto::ContractCallTransactionBody* TransactionBody::_internal_mutable_contractcall() {
  if (!_internal_has_contractcall()) {
    clear_data();
    set_has_contractcall();
    _impl_.data_.contractcall_ = CreateMaybeMessage< ::proto::ContractCallTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.contractcall_;
}
inline ::proto::ContractCallTransactionBody* TransactionBody::mutable_contractcall() {
  ::proto::ContractCallTransactionBody* _msg = _internal_mutable_contractcall();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.contractCall)
  return _msg;
}

// .proto.ContractCreateTransactionBody contractCreateInstance = 8;
inline bool TransactionBody::_internal_has_contractcreateinstance() const {
  return data_case() == kContractCreateInstance;
}
inline bool TransactionBody::has_contractcreateinstance() const {
  return _internal_has_contractcreateinstance();
}
inline void TransactionBody::set_has_contractcreateinstance() {
  _impl_._oneof_case_[0] = kContractCreateInstance;
}
inline ::proto::ContractCreateTransactionBody* TransactionBody::release_contractcreateinstance() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.contractCreateInstance)
  if (_internal_has_contractcreateinstance()) {
    clear_has_data();
    ::proto::ContractCreateTransactionBody* temp = _impl_.data_.contractcreateinstance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.contractcreateinstance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ContractCreateTransactionBody& TransactionBody::_internal_contractcreateinstance() const {
  return _internal_has_contractcreateinstance()
      ? *_impl_.data_.contractcreateinstance_
      : reinterpret_cast< ::proto::ContractCreateTransactionBody&>(::proto::_ContractCreateTransactionBody_default_instance_);
}
inline const ::proto::ContractCreateTransactionBody& TransactionBody::contractcreateinstance() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.contractCreateInstance)
  return _internal_contractcreateinstance();
}
inline ::proto::ContractCreateTransactionBody* TransactionBody::unsafe_arena_release_contractcreateinstance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.contractCreateInstance)
  if (_internal_has_contractcreateinstance()) {
    clear_has_data();
    ::proto::ContractCreateTransactionBody* temp = _impl_.data_.contractcreateinstance_;
    _impl_.data_.contractcreateinstance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_contractcreateinstance(::proto::ContractCreateTransactionBody* contractcreateinstance) {
  clear_data();
  if (contractcreateinstance) {
    set_has_contractcreateinstance();
    _impl_.data_.contractcreateinstance_ = contractcreateinstance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.contractCreateInstance)
}
inline ::proto::ContractCreateTransactionBody* TransactionBody::_internal_mutable_contractcreateinstance() {
  if (!_internal_has_contractcreateinstance()) {
    clear_data();
    set_has_contractcreateinstance();
    _impl_.data_.contractcreateinstance_ = CreateMaybeMessage< ::proto::ContractCreateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.contractcreateinstance_;
}
inline ::proto::ContractCreateTransactionBody* TransactionBody::mutable_contractcreateinstance() {
  ::proto::ContractCreateTransactionBody* _msg = _internal_mutable_contractcreateinstance();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.contractCreateInstance)
  return _msg;
}

// .proto.ContractUpdateTransactionBody contractUpdateInstance = 9;
inline bool TransactionBody::_internal_has_contractupdateinstance() const {
  return data_case() == kContractUpdateInstance;
}
inline bool TransactionBody::has_contractupdateinstance() const {
  return _internal_has_contractupdateinstance();
}
inline void TransactionBody::set_has_contractupdateinstance() {
  _impl_._oneof_case_[0] = kContractUpdateInstance;
}
inline ::proto::ContractUpdateTransactionBody* TransactionBody::release_contractupdateinstance() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.contractUpdateInstance)
  if (_internal_has_contractupdateinstance()) {
    clear_has_data();
    ::proto::ContractUpdateTransactionBody* temp = _impl_.data_.contractupdateinstance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.contractupdateinstance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ContractUpdateTransactionBody& TransactionBody::_internal_contractupdateinstance() const {
  return _internal_has_contractupdateinstance()
      ? *_impl_.data_.contractupdateinstance_
      : reinterpret_cast< ::proto::ContractUpdateTransactionBody&>(::proto::_ContractUpdateTransactionBody_default_instance_);
}
inline const ::proto::ContractUpdateTransactionBody& TransactionBody::contractupdateinstance() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.contractUpdateInstance)
  return _internal_contractupdateinstance();
}
inline ::proto::ContractUpdateTransactionBody* TransactionBody::unsafe_arena_release_contractupdateinstance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.contractUpdateInstance)
  if (_internal_has_contractupdateinstance()) {
    clear_has_data();
    ::proto::ContractUpdateTransactionBody* temp = _impl_.data_.contractupdateinstance_;
    _impl_.data_.contractupdateinstance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_contractupdateinstance(::proto::ContractUpdateTransactionBody* contractupdateinstance) {
  clear_data();
  if (contractupdateinstance) {
    set_has_contractupdateinstance();
    _impl_.data_.contractupdateinstance_ = contractupdateinstance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.contractUpdateInstance)
}
inline ::proto::ContractUpdateTransactionBody* TransactionBody::_internal_mutable_contractupdateinstance() {
  if (!_internal_has_contractupdateinstance()) {
    clear_data();
    set_has_contractupdateinstance();
    _impl_.data_.contractupdateinstance_ = CreateMaybeMessage< ::proto::ContractUpdateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.contractupdateinstance_;
}
inline ::proto::ContractUpdateTransactionBody* TransactionBody::mutable_contractupdateinstance() {
  ::proto::ContractUpdateTransactionBody* _msg = _internal_mutable_contractupdateinstance();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.contractUpdateInstance)
  return _msg;
}

// .proto.ContractDeleteTransactionBody contractDeleteInstance = 22;
inline bool TransactionBody::_internal_has_contractdeleteinstance() const {
  return data_case() == kContractDeleteInstance;
}
inline bool TransactionBody::has_contractdeleteinstance() const {
  return _internal_has_contractdeleteinstance();
}
inline void TransactionBody::set_has_contractdeleteinstance() {
  _impl_._oneof_case_[0] = kContractDeleteInstance;
}
inline ::proto::ContractDeleteTransactionBody* TransactionBody::release_contractdeleteinstance() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.contractDeleteInstance)
  if (_internal_has_contractdeleteinstance()) {
    clear_has_data();
    ::proto::ContractDeleteTransactionBody* temp = _impl_.data_.contractdeleteinstance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.contractdeleteinstance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ContractDeleteTransactionBody& TransactionBody::_internal_contractdeleteinstance() const {
  return _internal_has_contractdeleteinstance()
      ? *_impl_.data_.contractdeleteinstance_
      : reinterpret_cast< ::proto::ContractDeleteTransactionBody&>(::proto::_ContractDeleteTransactionBody_default_instance_);
}
inline const ::proto::ContractDeleteTransactionBody& TransactionBody::contractdeleteinstance() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.contractDeleteInstance)
  return _internal_contractdeleteinstance();
}
inline ::proto::ContractDeleteTransactionBody* TransactionBody::unsafe_arena_release_contractdeleteinstance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.contractDeleteInstance)
  if (_internal_has_contractdeleteinstance()) {
    clear_has_data();
    ::proto::ContractDeleteTransactionBody* temp = _impl_.data_.contractdeleteinstance_;
    _impl_.data_.contractdeleteinstance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_contractdeleteinstance(::proto::ContractDeleteTransactionBody* contractdeleteinstance) {
  clear_data();
  if (contractdeleteinstance) {
    set_has_contractdeleteinstance();
    _impl_.data_.contractdeleteinstance_ = contractdeleteinstance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.contractDeleteInstance)
}
inline ::proto::ContractDeleteTransactionBody* TransactionBody::_internal_mutable_contractdeleteinstance() {
  if (!_internal_has_contractdeleteinstance()) {
    clear_data();
    set_has_contractdeleteinstance();
    _impl_.data_.contractdeleteinstance_ = CreateMaybeMessage< ::proto::ContractDeleteTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.contractdeleteinstance_;
}
inline ::proto::ContractDeleteTransactionBody* TransactionBody::mutable_contractdeleteinstance() {
  ::proto::ContractDeleteTransactionBody* _msg = _internal_mutable_contractdeleteinstance();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.contractDeleteInstance)
  return _msg;
}

// .proto.EthereumTransactionBody ethereumTransaction = 50;
inline bool TransactionBody::_internal_has_ethereumtransaction() const {
  return data_case() == kEthereumTransaction;
}
inline bool TransactionBody::has_ethereumtransaction() const {
  return _internal_has_ethereumtransaction();
}
inline void TransactionBody::set_has_ethereumtransaction() {
  _impl_._oneof_case_[0] = kEthereumTransaction;
}
inline ::proto::EthereumTransactionBody* TransactionBody::release_ethereumtransaction() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.ethereumTransaction)
  if (_internal_has_ethereumtransaction()) {
    clear_has_data();
    ::proto::EthereumTransactionBody* temp = _impl_.data_.ethereumtransaction_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.ethereumtransaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::EthereumTransactionBody& TransactionBody::_internal_ethereumtransaction() const {
  return _internal_has_ethereumtransaction()
      ? *_impl_.data_.ethereumtransaction_
      : reinterpret_cast< ::proto::EthereumTransactionBody&>(::proto::_EthereumTransactionBody_default_instance_);
}
inline const ::proto::EthereumTransactionBody& TransactionBody::ethereumtransaction() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.ethereumTransaction)
  return _internal_ethereumtransaction();
}
inline ::proto::EthereumTransactionBody* TransactionBody::unsafe_arena_release_ethereumtransaction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.ethereumTransaction)
  if (_internal_has_ethereumtransaction()) {
    clear_has_data();
    ::proto::EthereumTransactionBody* temp = _impl_.data_.ethereumtransaction_;
    _impl_.data_.ethereumtransaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_ethereumtransaction(::proto::EthereumTransactionBody* ethereumtransaction) {
  clear_data();
  if (ethereumtransaction) {
    set_has_ethereumtransaction();
    _impl_.data_.ethereumtransaction_ = ethereumtransaction;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.ethereumTransaction)
}
inline ::proto::EthereumTransactionBody* TransactionBody::_internal_mutable_ethereumtransaction() {
  if (!_internal_has_ethereumtransaction()) {
    clear_data();
    set_has_ethereumtransaction();
    _impl_.data_.ethereumtransaction_ = CreateMaybeMessage< ::proto::EthereumTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.ethereumtransaction_;
}
inline ::proto::EthereumTransactionBody* TransactionBody::mutable_ethereumtransaction() {
  ::proto::EthereumTransactionBody* _msg = _internal_mutable_ethereumtransaction();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.ethereumTransaction)
  return _msg;
}

// .proto.CryptoAddLiveHashTransactionBody cryptoAddLiveHash = 10;
inline bool TransactionBody::_internal_has_cryptoaddlivehash() const {
  return data_case() == kCryptoAddLiveHash;
}
inline bool TransactionBody::has_cryptoaddlivehash() const {
  return _internal_has_cryptoaddlivehash();
}
inline void TransactionBody::set_has_cryptoaddlivehash() {
  _impl_._oneof_case_[0] = kCryptoAddLiveHash;
}
inline ::proto::CryptoAddLiveHashTransactionBody* TransactionBody::release_cryptoaddlivehash() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.cryptoAddLiveHash)
  if (_internal_has_cryptoaddlivehash()) {
    clear_has_data();
    ::proto::CryptoAddLiveHashTransactionBody* temp = _impl_.data_.cryptoaddlivehash_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.cryptoaddlivehash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::CryptoAddLiveHashTransactionBody& TransactionBody::_internal_cryptoaddlivehash() const {
  return _internal_has_cryptoaddlivehash()
      ? *_impl_.data_.cryptoaddlivehash_
      : reinterpret_cast< ::proto::CryptoAddLiveHashTransactionBody&>(::proto::_CryptoAddLiveHashTransactionBody_default_instance_);
}
inline const ::proto::CryptoAddLiveHashTransactionBody& TransactionBody::cryptoaddlivehash() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.cryptoAddLiveHash)
  return _internal_cryptoaddlivehash();
}
inline ::proto::CryptoAddLiveHashTransactionBody* TransactionBody::unsafe_arena_release_cryptoaddlivehash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.cryptoAddLiveHash)
  if (_internal_has_cryptoaddlivehash()) {
    clear_has_data();
    ::proto::CryptoAddLiveHashTransactionBody* temp = _impl_.data_.cryptoaddlivehash_;
    _impl_.data_.cryptoaddlivehash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_cryptoaddlivehash(::proto::CryptoAddLiveHashTransactionBody* cryptoaddlivehash) {
  clear_data();
  if (cryptoaddlivehash) {
    set_has_cryptoaddlivehash();
    _impl_.data_.cryptoaddlivehash_ = cryptoaddlivehash;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.cryptoAddLiveHash)
}
inline ::proto::CryptoAddLiveHashTransactionBody* TransactionBody::_internal_mutable_cryptoaddlivehash() {
  if (!_internal_has_cryptoaddlivehash()) {
    clear_data();
    set_has_cryptoaddlivehash();
    _impl_.data_.cryptoaddlivehash_ = CreateMaybeMessage< ::proto::CryptoAddLiveHashTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.cryptoaddlivehash_;
}
inline ::proto::CryptoAddLiveHashTransactionBody* TransactionBody::mutable_cryptoaddlivehash() {
  ::proto::CryptoAddLiveHashTransactionBody* _msg = _internal_mutable_cryptoaddlivehash();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.cryptoAddLiveHash)
  return _msg;
}

// .proto.CryptoApproveAllowanceTransactionBody cryptoApproveAllowance = 48;
inline bool TransactionBody::_internal_has_cryptoapproveallowance() const {
  return data_case() == kCryptoApproveAllowance;
}
inline bool TransactionBody::has_cryptoapproveallowance() const {
  return _internal_has_cryptoapproveallowance();
}
inline void TransactionBody::set_has_cryptoapproveallowance() {
  _impl_._oneof_case_[0] = kCryptoApproveAllowance;
}
inline ::proto::CryptoApproveAllowanceTransactionBody* TransactionBody::release_cryptoapproveallowance() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.cryptoApproveAllowance)
  if (_internal_has_cryptoapproveallowance()) {
    clear_has_data();
    ::proto::CryptoApproveAllowanceTransactionBody* temp = _impl_.data_.cryptoapproveallowance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.cryptoapproveallowance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::CryptoApproveAllowanceTransactionBody& TransactionBody::_internal_cryptoapproveallowance() const {
  return _internal_has_cryptoapproveallowance()
      ? *_impl_.data_.cryptoapproveallowance_
      : reinterpret_cast< ::proto::CryptoApproveAllowanceTransactionBody&>(::proto::_CryptoApproveAllowanceTransactionBody_default_instance_);
}
inline const ::proto::CryptoApproveAllowanceTransactionBody& TransactionBody::cryptoapproveallowance() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.cryptoApproveAllowance)
  return _internal_cryptoapproveallowance();
}
inline ::proto::CryptoApproveAllowanceTransactionBody* TransactionBody::unsafe_arena_release_cryptoapproveallowance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.cryptoApproveAllowance)
  if (_internal_has_cryptoapproveallowance()) {
    clear_has_data();
    ::proto::CryptoApproveAllowanceTransactionBody* temp = _impl_.data_.cryptoapproveallowance_;
    _impl_.data_.cryptoapproveallowance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_cryptoapproveallowance(::proto::CryptoApproveAllowanceTransactionBody* cryptoapproveallowance) {
  clear_data();
  if (cryptoapproveallowance) {
    set_has_cryptoapproveallowance();
    _impl_.data_.cryptoapproveallowance_ = cryptoapproveallowance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.cryptoApproveAllowance)
}
inline ::proto::CryptoApproveAllowanceTransactionBody* TransactionBody::_internal_mutable_cryptoapproveallowance() {
  if (!_internal_has_cryptoapproveallowance()) {
    clear_data();
    set_has_cryptoapproveallowance();
    _impl_.data_.cryptoapproveallowance_ = CreateMaybeMessage< ::proto::CryptoApproveAllowanceTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.cryptoapproveallowance_;
}
inline ::proto::CryptoApproveAllowanceTransactionBody* TransactionBody::mutable_cryptoapproveallowance() {
  ::proto::CryptoApproveAllowanceTransactionBody* _msg = _internal_mutable_cryptoapproveallowance();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.cryptoApproveAllowance)
  return _msg;
}

// .proto.CryptoDeleteAllowanceTransactionBody cryptoDeleteAllowance = 49;
inline bool TransactionBody::_internal_has_cryptodeleteallowance() const {
  return data_case() == kCryptoDeleteAllowance;
}
inline bool TransactionBody::has_cryptodeleteallowance() const {
  return _internal_has_cryptodeleteallowance();
}
inline void TransactionBody::set_has_cryptodeleteallowance() {
  _impl_._oneof_case_[0] = kCryptoDeleteAllowance;
}
inline ::proto::CryptoDeleteAllowanceTransactionBody* TransactionBody::release_cryptodeleteallowance() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.cryptoDeleteAllowance)
  if (_internal_has_cryptodeleteallowance()) {
    clear_has_data();
    ::proto::CryptoDeleteAllowanceTransactionBody* temp = _impl_.data_.cryptodeleteallowance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.cryptodeleteallowance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::CryptoDeleteAllowanceTransactionBody& TransactionBody::_internal_cryptodeleteallowance() const {
  return _internal_has_cryptodeleteallowance()
      ? *_impl_.data_.cryptodeleteallowance_
      : reinterpret_cast< ::proto::CryptoDeleteAllowanceTransactionBody&>(::proto::_CryptoDeleteAllowanceTransactionBody_default_instance_);
}
inline const ::proto::CryptoDeleteAllowanceTransactionBody& TransactionBody::cryptodeleteallowance() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.cryptoDeleteAllowance)
  return _internal_cryptodeleteallowance();
}
inline ::proto::CryptoDeleteAllowanceTransactionBody* TransactionBody::unsafe_arena_release_cryptodeleteallowance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.cryptoDeleteAllowance)
  if (_internal_has_cryptodeleteallowance()) {
    clear_has_data();
    ::proto::CryptoDeleteAllowanceTransactionBody* temp = _impl_.data_.cryptodeleteallowance_;
    _impl_.data_.cryptodeleteallowance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_cryptodeleteallowance(::proto::CryptoDeleteAllowanceTransactionBody* cryptodeleteallowance) {
  clear_data();
  if (cryptodeleteallowance) {
    set_has_cryptodeleteallowance();
    _impl_.data_.cryptodeleteallowance_ = cryptodeleteallowance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.cryptoDeleteAllowance)
}
inline ::proto::CryptoDeleteAllowanceTransactionBody* TransactionBody::_internal_mutable_cryptodeleteallowance() {
  if (!_internal_has_cryptodeleteallowance()) {
    clear_data();
    set_has_cryptodeleteallowance();
    _impl_.data_.cryptodeleteallowance_ = CreateMaybeMessage< ::proto::CryptoDeleteAllowanceTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.cryptodeleteallowance_;
}
inline ::proto::CryptoDeleteAllowanceTransactionBody* TransactionBody::mutable_cryptodeleteallowance() {
  ::proto::CryptoDeleteAllowanceTransactionBody* _msg = _internal_mutable_cryptodeleteallowance();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.cryptoDeleteAllowance)
  return _msg;
}

// .proto.CryptoCreateTransactionBody cryptoCreateAccount = 11;
inline bool TransactionBody::_internal_has_cryptocreateaccount() const {
  return data_case() == kCryptoCreateAccount;
}
inline bool TransactionBody::has_cryptocreateaccount() const {
  return _internal_has_cryptocreateaccount();
}
inline void TransactionBody::set_has_cryptocreateaccount() {
  _impl_._oneof_case_[0] = kCryptoCreateAccount;
}
inline ::proto::CryptoCreateTransactionBody* TransactionBody::release_cryptocreateaccount() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.cryptoCreateAccount)
  if (_internal_has_cryptocreateaccount()) {
    clear_has_data();
    ::proto::CryptoCreateTransactionBody* temp = _impl_.data_.cryptocreateaccount_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.cryptocreateaccount_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::CryptoCreateTransactionBody& TransactionBody::_internal_cryptocreateaccount() const {
  return _internal_has_cryptocreateaccount()
      ? *_impl_.data_.cryptocreateaccount_
      : reinterpret_cast< ::proto::CryptoCreateTransactionBody&>(::proto::_CryptoCreateTransactionBody_default_instance_);
}
inline const ::proto::CryptoCreateTransactionBody& TransactionBody::cryptocreateaccount() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.cryptoCreateAccount)
  return _internal_cryptocreateaccount();
}
inline ::proto::CryptoCreateTransactionBody* TransactionBody::unsafe_arena_release_cryptocreateaccount() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.cryptoCreateAccount)
  if (_internal_has_cryptocreateaccount()) {
    clear_has_data();
    ::proto::CryptoCreateTransactionBody* temp = _impl_.data_.cryptocreateaccount_;
    _impl_.data_.cryptocreateaccount_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_cryptocreateaccount(::proto::CryptoCreateTransactionBody* cryptocreateaccount) {
  clear_data();
  if (cryptocreateaccount) {
    set_has_cryptocreateaccount();
    _impl_.data_.cryptocreateaccount_ = cryptocreateaccount;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.cryptoCreateAccount)
}
inline ::proto::CryptoCreateTransactionBody* TransactionBody::_internal_mutable_cryptocreateaccount() {
  if (!_internal_has_cryptocreateaccount()) {
    clear_data();
    set_has_cryptocreateaccount();
    _impl_.data_.cryptocreateaccount_ = CreateMaybeMessage< ::proto::CryptoCreateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.cryptocreateaccount_;
}
inline ::proto::CryptoCreateTransactionBody* TransactionBody::mutable_cryptocreateaccount() {
  ::proto::CryptoCreateTransactionBody* _msg = _internal_mutable_cryptocreateaccount();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.cryptoCreateAccount)
  return _msg;
}

// .proto.CryptoDeleteTransactionBody cryptoDelete = 12;
inline bool TransactionBody::_internal_has_cryptodelete() const {
  return data_case() == kCryptoDelete;
}
inline bool TransactionBody::has_cryptodelete() const {
  return _internal_has_cryptodelete();
}
inline void TransactionBody::set_has_cryptodelete() {
  _impl_._oneof_case_[0] = kCryptoDelete;
}
inline ::proto::CryptoDeleteTransactionBody* TransactionBody::release_cryptodelete() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.cryptoDelete)
  if (_internal_has_cryptodelete()) {
    clear_has_data();
    ::proto::CryptoDeleteTransactionBody* temp = _impl_.data_.cryptodelete_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.cryptodelete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::CryptoDeleteTransactionBody& TransactionBody::_internal_cryptodelete() const {
  return _internal_has_cryptodelete()
      ? *_impl_.data_.cryptodelete_
      : reinterpret_cast< ::proto::CryptoDeleteTransactionBody&>(::proto::_CryptoDeleteTransactionBody_default_instance_);
}
inline const ::proto::CryptoDeleteTransactionBody& TransactionBody::cryptodelete() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.cryptoDelete)
  return _internal_cryptodelete();
}
inline ::proto::CryptoDeleteTransactionBody* TransactionBody::unsafe_arena_release_cryptodelete() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.cryptoDelete)
  if (_internal_has_cryptodelete()) {
    clear_has_data();
    ::proto::CryptoDeleteTransactionBody* temp = _impl_.data_.cryptodelete_;
    _impl_.data_.cryptodelete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_cryptodelete(::proto::CryptoDeleteTransactionBody* cryptodelete) {
  clear_data();
  if (cryptodelete) {
    set_has_cryptodelete();
    _impl_.data_.cryptodelete_ = cryptodelete;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.cryptoDelete)
}
inline ::proto::CryptoDeleteTransactionBody* TransactionBody::_internal_mutable_cryptodelete() {
  if (!_internal_has_cryptodelete()) {
    clear_data();
    set_has_cryptodelete();
    _impl_.data_.cryptodelete_ = CreateMaybeMessage< ::proto::CryptoDeleteTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.cryptodelete_;
}
inline ::proto::CryptoDeleteTransactionBody* TransactionBody::mutable_cryptodelete() {
  ::proto::CryptoDeleteTransactionBody* _msg = _internal_mutable_cryptodelete();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.cryptoDelete)
  return _msg;
}

// .proto.CryptoDeleteLiveHashTransactionBody cryptoDeleteLiveHash = 13;
inline bool TransactionBody::_internal_has_cryptodeletelivehash() const {
  return data_case() == kCryptoDeleteLiveHash;
}
inline bool TransactionBody::has_cryptodeletelivehash() const {
  return _internal_has_cryptodeletelivehash();
}
inline void TransactionBody::set_has_cryptodeletelivehash() {
  _impl_._oneof_case_[0] = kCryptoDeleteLiveHash;
}
inline ::proto::CryptoDeleteLiveHashTransactionBody* TransactionBody::release_cryptodeletelivehash() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.cryptoDeleteLiveHash)
  if (_internal_has_cryptodeletelivehash()) {
    clear_has_data();
    ::proto::CryptoDeleteLiveHashTransactionBody* temp = _impl_.data_.cryptodeletelivehash_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.cryptodeletelivehash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::CryptoDeleteLiveHashTransactionBody& TransactionBody::_internal_cryptodeletelivehash() const {
  return _internal_has_cryptodeletelivehash()
      ? *_impl_.data_.cryptodeletelivehash_
      : reinterpret_cast< ::proto::CryptoDeleteLiveHashTransactionBody&>(::proto::_CryptoDeleteLiveHashTransactionBody_default_instance_);
}
inline const ::proto::CryptoDeleteLiveHashTransactionBody& TransactionBody::cryptodeletelivehash() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.cryptoDeleteLiveHash)
  return _internal_cryptodeletelivehash();
}
inline ::proto::CryptoDeleteLiveHashTransactionBody* TransactionBody::unsafe_arena_release_cryptodeletelivehash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.cryptoDeleteLiveHash)
  if (_internal_has_cryptodeletelivehash()) {
    clear_has_data();
    ::proto::CryptoDeleteLiveHashTransactionBody* temp = _impl_.data_.cryptodeletelivehash_;
    _impl_.data_.cryptodeletelivehash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_cryptodeletelivehash(::proto::CryptoDeleteLiveHashTransactionBody* cryptodeletelivehash) {
  clear_data();
  if (cryptodeletelivehash) {
    set_has_cryptodeletelivehash();
    _impl_.data_.cryptodeletelivehash_ = cryptodeletelivehash;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.cryptoDeleteLiveHash)
}
inline ::proto::CryptoDeleteLiveHashTransactionBody* TransactionBody::_internal_mutable_cryptodeletelivehash() {
  if (!_internal_has_cryptodeletelivehash()) {
    clear_data();
    set_has_cryptodeletelivehash();
    _impl_.data_.cryptodeletelivehash_ = CreateMaybeMessage< ::proto::CryptoDeleteLiveHashTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.cryptodeletelivehash_;
}
inline ::proto::CryptoDeleteLiveHashTransactionBody* TransactionBody::mutable_cryptodeletelivehash() {
  ::proto::CryptoDeleteLiveHashTransactionBody* _msg = _internal_mutable_cryptodeletelivehash();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.cryptoDeleteLiveHash)
  return _msg;
}

// .proto.CryptoTransferTransactionBody cryptoTransfer = 14;
inline bool TransactionBody::_internal_has_cryptotransfer() const {
  return data_case() == kCryptoTransfer;
}
inline bool TransactionBody::has_cryptotransfer() const {
  return _internal_has_cryptotransfer();
}
inline void TransactionBody::set_has_cryptotransfer() {
  _impl_._oneof_case_[0] = kCryptoTransfer;
}
inline ::proto::CryptoTransferTransactionBody* TransactionBody::release_cryptotransfer() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.cryptoTransfer)
  if (_internal_has_cryptotransfer()) {
    clear_has_data();
    ::proto::CryptoTransferTransactionBody* temp = _impl_.data_.cryptotransfer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.cryptotransfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::CryptoTransferTransactionBody& TransactionBody::_internal_cryptotransfer() const {
  return _internal_has_cryptotransfer()
      ? *_impl_.data_.cryptotransfer_
      : reinterpret_cast< ::proto::CryptoTransferTransactionBody&>(::proto::_CryptoTransferTransactionBody_default_instance_);
}
inline const ::proto::CryptoTransferTransactionBody& TransactionBody::cryptotransfer() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.cryptoTransfer)
  return _internal_cryptotransfer();
}
inline ::proto::CryptoTransferTransactionBody* TransactionBody::unsafe_arena_release_cryptotransfer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.cryptoTransfer)
  if (_internal_has_cryptotransfer()) {
    clear_has_data();
    ::proto::CryptoTransferTransactionBody* temp = _impl_.data_.cryptotransfer_;
    _impl_.data_.cryptotransfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_cryptotransfer(::proto::CryptoTransferTransactionBody* cryptotransfer) {
  clear_data();
  if (cryptotransfer) {
    set_has_cryptotransfer();
    _impl_.data_.cryptotransfer_ = cryptotransfer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.cryptoTransfer)
}
inline ::proto::CryptoTransferTransactionBody* TransactionBody::_internal_mutable_cryptotransfer() {
  if (!_internal_has_cryptotransfer()) {
    clear_data();
    set_has_cryptotransfer();
    _impl_.data_.cryptotransfer_ = CreateMaybeMessage< ::proto::CryptoTransferTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.cryptotransfer_;
}
inline ::proto::CryptoTransferTransactionBody* TransactionBody::mutable_cryptotransfer() {
  ::proto::CryptoTransferTransactionBody* _msg = _internal_mutable_cryptotransfer();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.cryptoTransfer)
  return _msg;
}

// .proto.CryptoUpdateTransactionBody cryptoUpdateAccount = 15;
inline bool TransactionBody::_internal_has_cryptoupdateaccount() const {
  return data_case() == kCryptoUpdateAccount;
}
inline bool TransactionBody::has_cryptoupdateaccount() const {
  return _internal_has_cryptoupdateaccount();
}
inline void TransactionBody::set_has_cryptoupdateaccount() {
  _impl_._oneof_case_[0] = kCryptoUpdateAccount;
}
inline ::proto::CryptoUpdateTransactionBody* TransactionBody::release_cryptoupdateaccount() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.cryptoUpdateAccount)
  if (_internal_has_cryptoupdateaccount()) {
    clear_has_data();
    ::proto::CryptoUpdateTransactionBody* temp = _impl_.data_.cryptoupdateaccount_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.cryptoupdateaccount_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::CryptoUpdateTransactionBody& TransactionBody::_internal_cryptoupdateaccount() const {
  return _internal_has_cryptoupdateaccount()
      ? *_impl_.data_.cryptoupdateaccount_
      : reinterpret_cast< ::proto::CryptoUpdateTransactionBody&>(::proto::_CryptoUpdateTransactionBody_default_instance_);
}
inline const ::proto::CryptoUpdateTransactionBody& TransactionBody::cryptoupdateaccount() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.cryptoUpdateAccount)
  return _internal_cryptoupdateaccount();
}
inline ::proto::CryptoUpdateTransactionBody* TransactionBody::unsafe_arena_release_cryptoupdateaccount() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.cryptoUpdateAccount)
  if (_internal_has_cryptoupdateaccount()) {
    clear_has_data();
    ::proto::CryptoUpdateTransactionBody* temp = _impl_.data_.cryptoupdateaccount_;
    _impl_.data_.cryptoupdateaccount_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_cryptoupdateaccount(::proto::CryptoUpdateTransactionBody* cryptoupdateaccount) {
  clear_data();
  if (cryptoupdateaccount) {
    set_has_cryptoupdateaccount();
    _impl_.data_.cryptoupdateaccount_ = cryptoupdateaccount;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.cryptoUpdateAccount)
}
inline ::proto::CryptoUpdateTransactionBody* TransactionBody::_internal_mutable_cryptoupdateaccount() {
  if (!_internal_has_cryptoupdateaccount()) {
    clear_data();
    set_has_cryptoupdateaccount();
    _impl_.data_.cryptoupdateaccount_ = CreateMaybeMessage< ::proto::CryptoUpdateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.cryptoupdateaccount_;
}
inline ::proto::CryptoUpdateTransactionBody* TransactionBody::mutable_cryptoupdateaccount() {
  ::proto::CryptoUpdateTransactionBody* _msg = _internal_mutable_cryptoupdateaccount();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.cryptoUpdateAccount)
  return _msg;
}

// .proto.FileAppendTransactionBody fileAppend = 16;
inline bool TransactionBody::_internal_has_fileappend() const {
  return data_case() == kFileAppend;
}
inline bool TransactionBody::has_fileappend() const {
  return _internal_has_fileappend();
}
inline void TransactionBody::set_has_fileappend() {
  _impl_._oneof_case_[0] = kFileAppend;
}
inline ::proto::FileAppendTransactionBody* TransactionBody::release_fileappend() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.fileAppend)
  if (_internal_has_fileappend()) {
    clear_has_data();
    ::proto::FileAppendTransactionBody* temp = _impl_.data_.fileappend_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.fileappend_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::FileAppendTransactionBody& TransactionBody::_internal_fileappend() const {
  return _internal_has_fileappend()
      ? *_impl_.data_.fileappend_
      : reinterpret_cast< ::proto::FileAppendTransactionBody&>(::proto::_FileAppendTransactionBody_default_instance_);
}
inline const ::proto::FileAppendTransactionBody& TransactionBody::fileappend() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.fileAppend)
  return _internal_fileappend();
}
inline ::proto::FileAppendTransactionBody* TransactionBody::unsafe_arena_release_fileappend() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.fileAppend)
  if (_internal_has_fileappend()) {
    clear_has_data();
    ::proto::FileAppendTransactionBody* temp = _impl_.data_.fileappend_;
    _impl_.data_.fileappend_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_fileappend(::proto::FileAppendTransactionBody* fileappend) {
  clear_data();
  if (fileappend) {
    set_has_fileappend();
    _impl_.data_.fileappend_ = fileappend;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.fileAppend)
}
inline ::proto::FileAppendTransactionBody* TransactionBody::_internal_mutable_fileappend() {
  if (!_internal_has_fileappend()) {
    clear_data();
    set_has_fileappend();
    _impl_.data_.fileappend_ = CreateMaybeMessage< ::proto::FileAppendTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.fileappend_;
}
inline ::proto::FileAppendTransactionBody* TransactionBody::mutable_fileappend() {
  ::proto::FileAppendTransactionBody* _msg = _internal_mutable_fileappend();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.fileAppend)
  return _msg;
}

// .proto.FileCreateTransactionBody fileCreate = 17;
inline bool TransactionBody::_internal_has_filecreate() const {
  return data_case() == kFileCreate;
}
inline bool TransactionBody::has_filecreate() const {
  return _internal_has_filecreate();
}
inline void TransactionBody::set_has_filecreate() {
  _impl_._oneof_case_[0] = kFileCreate;
}
inline ::proto::FileCreateTransactionBody* TransactionBody::release_filecreate() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.fileCreate)
  if (_internal_has_filecreate()) {
    clear_has_data();
    ::proto::FileCreateTransactionBody* temp = _impl_.data_.filecreate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.filecreate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::FileCreateTransactionBody& TransactionBody::_internal_filecreate() const {
  return _internal_has_filecreate()
      ? *_impl_.data_.filecreate_
      : reinterpret_cast< ::proto::FileCreateTransactionBody&>(::proto::_FileCreateTransactionBody_default_instance_);
}
inline const ::proto::FileCreateTransactionBody& TransactionBody::filecreate() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.fileCreate)
  return _internal_filecreate();
}
inline ::proto::FileCreateTransactionBody* TransactionBody::unsafe_arena_release_filecreate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.fileCreate)
  if (_internal_has_filecreate()) {
    clear_has_data();
    ::proto::FileCreateTransactionBody* temp = _impl_.data_.filecreate_;
    _impl_.data_.filecreate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_filecreate(::proto::FileCreateTransactionBody* filecreate) {
  clear_data();
  if (filecreate) {
    set_has_filecreate();
    _impl_.data_.filecreate_ = filecreate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.fileCreate)
}
inline ::proto::FileCreateTransactionBody* TransactionBody::_internal_mutable_filecreate() {
  if (!_internal_has_filecreate()) {
    clear_data();
    set_has_filecreate();
    _impl_.data_.filecreate_ = CreateMaybeMessage< ::proto::FileCreateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.filecreate_;
}
inline ::proto::FileCreateTransactionBody* TransactionBody::mutable_filecreate() {
  ::proto::FileCreateTransactionBody* _msg = _internal_mutable_filecreate();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.fileCreate)
  return _msg;
}

// .proto.FileDeleteTransactionBody fileDelete = 18;
inline bool TransactionBody::_internal_has_filedelete() const {
  return data_case() == kFileDelete;
}
inline bool TransactionBody::has_filedelete() const {
  return _internal_has_filedelete();
}
inline void TransactionBody::set_has_filedelete() {
  _impl_._oneof_case_[0] = kFileDelete;
}
inline ::proto::FileDeleteTransactionBody* TransactionBody::release_filedelete() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.fileDelete)
  if (_internal_has_filedelete()) {
    clear_has_data();
    ::proto::FileDeleteTransactionBody* temp = _impl_.data_.filedelete_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.filedelete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::FileDeleteTransactionBody& TransactionBody::_internal_filedelete() const {
  return _internal_has_filedelete()
      ? *_impl_.data_.filedelete_
      : reinterpret_cast< ::proto::FileDeleteTransactionBody&>(::proto::_FileDeleteTransactionBody_default_instance_);
}
inline const ::proto::FileDeleteTransactionBody& TransactionBody::filedelete() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.fileDelete)
  return _internal_filedelete();
}
inline ::proto::FileDeleteTransactionBody* TransactionBody::unsafe_arena_release_filedelete() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.fileDelete)
  if (_internal_has_filedelete()) {
    clear_has_data();
    ::proto::FileDeleteTransactionBody* temp = _impl_.data_.filedelete_;
    _impl_.data_.filedelete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_filedelete(::proto::FileDeleteTransactionBody* filedelete) {
  clear_data();
  if (filedelete) {
    set_has_filedelete();
    _impl_.data_.filedelete_ = filedelete;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.fileDelete)
}
inline ::proto::FileDeleteTransactionBody* TransactionBody::_internal_mutable_filedelete() {
  if (!_internal_has_filedelete()) {
    clear_data();
    set_has_filedelete();
    _impl_.data_.filedelete_ = CreateMaybeMessage< ::proto::FileDeleteTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.filedelete_;
}
inline ::proto::FileDeleteTransactionBody* TransactionBody::mutable_filedelete() {
  ::proto::FileDeleteTransactionBody* _msg = _internal_mutable_filedelete();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.fileDelete)
  return _msg;
}

// .proto.FileUpdateTransactionBody fileUpdate = 19;
inline bool TransactionBody::_internal_has_fileupdate() const {
  return data_case() == kFileUpdate;
}
inline bool TransactionBody::has_fileupdate() const {
  return _internal_has_fileupdate();
}
inline void TransactionBody::set_has_fileupdate() {
  _impl_._oneof_case_[0] = kFileUpdate;
}
inline ::proto::FileUpdateTransactionBody* TransactionBody::release_fileupdate() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.fileUpdate)
  if (_internal_has_fileupdate()) {
    clear_has_data();
    ::proto::FileUpdateTransactionBody* temp = _impl_.data_.fileupdate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.fileupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::FileUpdateTransactionBody& TransactionBody::_internal_fileupdate() const {
  return _internal_has_fileupdate()
      ? *_impl_.data_.fileupdate_
      : reinterpret_cast< ::proto::FileUpdateTransactionBody&>(::proto::_FileUpdateTransactionBody_default_instance_);
}
inline const ::proto::FileUpdateTransactionBody& TransactionBody::fileupdate() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.fileUpdate)
  return _internal_fileupdate();
}
inline ::proto::FileUpdateTransactionBody* TransactionBody::unsafe_arena_release_fileupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.fileUpdate)
  if (_internal_has_fileupdate()) {
    clear_has_data();
    ::proto::FileUpdateTransactionBody* temp = _impl_.data_.fileupdate_;
    _impl_.data_.fileupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_fileupdate(::proto::FileUpdateTransactionBody* fileupdate) {
  clear_data();
  if (fileupdate) {
    set_has_fileupdate();
    _impl_.data_.fileupdate_ = fileupdate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.fileUpdate)
}
inline ::proto::FileUpdateTransactionBody* TransactionBody::_internal_mutable_fileupdate() {
  if (!_internal_has_fileupdate()) {
    clear_data();
    set_has_fileupdate();
    _impl_.data_.fileupdate_ = CreateMaybeMessage< ::proto::FileUpdateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.fileupdate_;
}
inline ::proto::FileUpdateTransactionBody* TransactionBody::mutable_fileupdate() {
  ::proto::FileUpdateTransactionBody* _msg = _internal_mutable_fileupdate();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.fileUpdate)
  return _msg;
}

// .proto.SystemDeleteTransactionBody systemDelete = 20;
inline bool TransactionBody::_internal_has_systemdelete() const {
  return data_case() == kSystemDelete;
}
inline bool TransactionBody::has_systemdelete() const {
  return _internal_has_systemdelete();
}
inline void TransactionBody::set_has_systemdelete() {
  _impl_._oneof_case_[0] = kSystemDelete;
}
inline ::proto::SystemDeleteTransactionBody* TransactionBody::release_systemdelete() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.systemDelete)
  if (_internal_has_systemdelete()) {
    clear_has_data();
    ::proto::SystemDeleteTransactionBody* temp = _impl_.data_.systemdelete_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.systemdelete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::SystemDeleteTransactionBody& TransactionBody::_internal_systemdelete() const {
  return _internal_has_systemdelete()
      ? *_impl_.data_.systemdelete_
      : reinterpret_cast< ::proto::SystemDeleteTransactionBody&>(::proto::_SystemDeleteTransactionBody_default_instance_);
}
inline const ::proto::SystemDeleteTransactionBody& TransactionBody::systemdelete() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.systemDelete)
  return _internal_systemdelete();
}
inline ::proto::SystemDeleteTransactionBody* TransactionBody::unsafe_arena_release_systemdelete() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.systemDelete)
  if (_internal_has_systemdelete()) {
    clear_has_data();
    ::proto::SystemDeleteTransactionBody* temp = _impl_.data_.systemdelete_;
    _impl_.data_.systemdelete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_systemdelete(::proto::SystemDeleteTransactionBody* systemdelete) {
  clear_data();
  if (systemdelete) {
    set_has_systemdelete();
    _impl_.data_.systemdelete_ = systemdelete;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.systemDelete)
}
inline ::proto::SystemDeleteTransactionBody* TransactionBody::_internal_mutable_systemdelete() {
  if (!_internal_has_systemdelete()) {
    clear_data();
    set_has_systemdelete();
    _impl_.data_.systemdelete_ = CreateMaybeMessage< ::proto::SystemDeleteTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.systemdelete_;
}
inline ::proto::SystemDeleteTransactionBody* TransactionBody::mutable_systemdelete() {
  ::proto::SystemDeleteTransactionBody* _msg = _internal_mutable_systemdelete();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.systemDelete)
  return _msg;
}

// .proto.SystemUndeleteTransactionBody systemUndelete = 21;
inline bool TransactionBody::_internal_has_systemundelete() const {
  return data_case() == kSystemUndelete;
}
inline bool TransactionBody::has_systemundelete() const {
  return _internal_has_systemundelete();
}
inline void TransactionBody::set_has_systemundelete() {
  _impl_._oneof_case_[0] = kSystemUndelete;
}
inline ::proto::SystemUndeleteTransactionBody* TransactionBody::release_systemundelete() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.systemUndelete)
  if (_internal_has_systemundelete()) {
    clear_has_data();
    ::proto::SystemUndeleteTransactionBody* temp = _impl_.data_.systemundelete_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.systemundelete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::SystemUndeleteTransactionBody& TransactionBody::_internal_systemundelete() const {
  return _internal_has_systemundelete()
      ? *_impl_.data_.systemundelete_
      : reinterpret_cast< ::proto::SystemUndeleteTransactionBody&>(::proto::_SystemUndeleteTransactionBody_default_instance_);
}
inline const ::proto::SystemUndeleteTransactionBody& TransactionBody::systemundelete() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.systemUndelete)
  return _internal_systemundelete();
}
inline ::proto::SystemUndeleteTransactionBody* TransactionBody::unsafe_arena_release_systemundelete() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.systemUndelete)
  if (_internal_has_systemundelete()) {
    clear_has_data();
    ::proto::SystemUndeleteTransactionBody* temp = _impl_.data_.systemundelete_;
    _impl_.data_.systemundelete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_systemundelete(::proto::SystemUndeleteTransactionBody* systemundelete) {
  clear_data();
  if (systemundelete) {
    set_has_systemundelete();
    _impl_.data_.systemundelete_ = systemundelete;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.systemUndelete)
}
inline ::proto::SystemUndeleteTransactionBody* TransactionBody::_internal_mutable_systemundelete() {
  if (!_internal_has_systemundelete()) {
    clear_data();
    set_has_systemundelete();
    _impl_.data_.systemundelete_ = CreateMaybeMessage< ::proto::SystemUndeleteTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.systemundelete_;
}
inline ::proto::SystemUndeleteTransactionBody* TransactionBody::mutable_systemundelete() {
  ::proto::SystemUndeleteTransactionBody* _msg = _internal_mutable_systemundelete();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.systemUndelete)
  return _msg;
}

// .proto.FreezeTransactionBody freeze = 23;
inline bool TransactionBody::_internal_has_freeze() const {
  return data_case() == kFreeze;
}
inline bool TransactionBody::has_freeze() const {
  return _internal_has_freeze();
}
inline void TransactionBody::set_has_freeze() {
  _impl_._oneof_case_[0] = kFreeze;
}
inline ::proto::FreezeTransactionBody* TransactionBody::release_freeze() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.freeze)
  if (_internal_has_freeze()) {
    clear_has_data();
    ::proto::FreezeTransactionBody* temp = _impl_.data_.freeze_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.freeze_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::FreezeTransactionBody& TransactionBody::_internal_freeze() const {
  return _internal_has_freeze()
      ? *_impl_.data_.freeze_
      : reinterpret_cast< ::proto::FreezeTransactionBody&>(::proto::_FreezeTransactionBody_default_instance_);
}
inline const ::proto::FreezeTransactionBody& TransactionBody::freeze() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.freeze)
  return _internal_freeze();
}
inline ::proto::FreezeTransactionBody* TransactionBody::unsafe_arena_release_freeze() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.freeze)
  if (_internal_has_freeze()) {
    clear_has_data();
    ::proto::FreezeTransactionBody* temp = _impl_.data_.freeze_;
    _impl_.data_.freeze_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_freeze(::proto::FreezeTransactionBody* freeze) {
  clear_data();
  if (freeze) {
    set_has_freeze();
    _impl_.data_.freeze_ = freeze;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.freeze)
}
inline ::proto::FreezeTransactionBody* TransactionBody::_internal_mutable_freeze() {
  if (!_internal_has_freeze()) {
    clear_data();
    set_has_freeze();
    _impl_.data_.freeze_ = CreateMaybeMessage< ::proto::FreezeTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.freeze_;
}
inline ::proto::FreezeTransactionBody* TransactionBody::mutable_freeze() {
  ::proto::FreezeTransactionBody* _msg = _internal_mutable_freeze();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.freeze)
  return _msg;
}

// .proto.ConsensusCreateTopicTransactionBody consensusCreateTopic = 24;
inline bool TransactionBody::_internal_has_consensuscreatetopic() const {
  return data_case() == kConsensusCreateTopic;
}
inline bool TransactionBody::has_consensuscreatetopic() const {
  return _internal_has_consensuscreatetopic();
}
inline void TransactionBody::set_has_consensuscreatetopic() {
  _impl_._oneof_case_[0] = kConsensusCreateTopic;
}
inline ::proto::ConsensusCreateTopicTransactionBody* TransactionBody::release_consensuscreatetopic() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.consensusCreateTopic)
  if (_internal_has_consensuscreatetopic()) {
    clear_has_data();
    ::proto::ConsensusCreateTopicTransactionBody* temp = _impl_.data_.consensuscreatetopic_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.consensuscreatetopic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ConsensusCreateTopicTransactionBody& TransactionBody::_internal_consensuscreatetopic() const {
  return _internal_has_consensuscreatetopic()
      ? *_impl_.data_.consensuscreatetopic_
      : reinterpret_cast< ::proto::ConsensusCreateTopicTransactionBody&>(::proto::_ConsensusCreateTopicTransactionBody_default_instance_);
}
inline const ::proto::ConsensusCreateTopicTransactionBody& TransactionBody::consensuscreatetopic() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.consensusCreateTopic)
  return _internal_consensuscreatetopic();
}
inline ::proto::ConsensusCreateTopicTransactionBody* TransactionBody::unsafe_arena_release_consensuscreatetopic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.consensusCreateTopic)
  if (_internal_has_consensuscreatetopic()) {
    clear_has_data();
    ::proto::ConsensusCreateTopicTransactionBody* temp = _impl_.data_.consensuscreatetopic_;
    _impl_.data_.consensuscreatetopic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_consensuscreatetopic(::proto::ConsensusCreateTopicTransactionBody* consensuscreatetopic) {
  clear_data();
  if (consensuscreatetopic) {
    set_has_consensuscreatetopic();
    _impl_.data_.consensuscreatetopic_ = consensuscreatetopic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.consensusCreateTopic)
}
inline ::proto::ConsensusCreateTopicTransactionBody* TransactionBody::_internal_mutable_consensuscreatetopic() {
  if (!_internal_has_consensuscreatetopic()) {
    clear_data();
    set_has_consensuscreatetopic();
    _impl_.data_.consensuscreatetopic_ = CreateMaybeMessage< ::proto::ConsensusCreateTopicTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.consensuscreatetopic_;
}
inline ::proto::ConsensusCreateTopicTransactionBody* TransactionBody::mutable_consensuscreatetopic() {
  ::proto::ConsensusCreateTopicTransactionBody* _msg = _internal_mutable_consensuscreatetopic();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.consensusCreateTopic)
  return _msg;
}

// .proto.ConsensusUpdateTopicTransactionBody consensusUpdateTopic = 25;
inline bool TransactionBody::_internal_has_consensusupdatetopic() const {
  return data_case() == kConsensusUpdateTopic;
}
inline bool TransactionBody::has_consensusupdatetopic() const {
  return _internal_has_consensusupdatetopic();
}
inline void TransactionBody::set_has_consensusupdatetopic() {
  _impl_._oneof_case_[0] = kConsensusUpdateTopic;
}
inline ::proto::ConsensusUpdateTopicTransactionBody* TransactionBody::release_consensusupdatetopic() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.consensusUpdateTopic)
  if (_internal_has_consensusupdatetopic()) {
    clear_has_data();
    ::proto::ConsensusUpdateTopicTransactionBody* temp = _impl_.data_.consensusupdatetopic_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.consensusupdatetopic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ConsensusUpdateTopicTransactionBody& TransactionBody::_internal_consensusupdatetopic() const {
  return _internal_has_consensusupdatetopic()
      ? *_impl_.data_.consensusupdatetopic_
      : reinterpret_cast< ::proto::ConsensusUpdateTopicTransactionBody&>(::proto::_ConsensusUpdateTopicTransactionBody_default_instance_);
}
inline const ::proto::ConsensusUpdateTopicTransactionBody& TransactionBody::consensusupdatetopic() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.consensusUpdateTopic)
  return _internal_consensusupdatetopic();
}
inline ::proto::ConsensusUpdateTopicTransactionBody* TransactionBody::unsafe_arena_release_consensusupdatetopic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.consensusUpdateTopic)
  if (_internal_has_consensusupdatetopic()) {
    clear_has_data();
    ::proto::ConsensusUpdateTopicTransactionBody* temp = _impl_.data_.consensusupdatetopic_;
    _impl_.data_.consensusupdatetopic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_consensusupdatetopic(::proto::ConsensusUpdateTopicTransactionBody* consensusupdatetopic) {
  clear_data();
  if (consensusupdatetopic) {
    set_has_consensusupdatetopic();
    _impl_.data_.consensusupdatetopic_ = consensusupdatetopic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.consensusUpdateTopic)
}
inline ::proto::ConsensusUpdateTopicTransactionBody* TransactionBody::_internal_mutable_consensusupdatetopic() {
  if (!_internal_has_consensusupdatetopic()) {
    clear_data();
    set_has_consensusupdatetopic();
    _impl_.data_.consensusupdatetopic_ = CreateMaybeMessage< ::proto::ConsensusUpdateTopicTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.consensusupdatetopic_;
}
inline ::proto::ConsensusUpdateTopicTransactionBody* TransactionBody::mutable_consensusupdatetopic() {
  ::proto::ConsensusUpdateTopicTransactionBody* _msg = _internal_mutable_consensusupdatetopic();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.consensusUpdateTopic)
  return _msg;
}

// .proto.ConsensusDeleteTopicTransactionBody consensusDeleteTopic = 26;
inline bool TransactionBody::_internal_has_consensusdeletetopic() const {
  return data_case() == kConsensusDeleteTopic;
}
inline bool TransactionBody::has_consensusdeletetopic() const {
  return _internal_has_consensusdeletetopic();
}
inline void TransactionBody::set_has_consensusdeletetopic() {
  _impl_._oneof_case_[0] = kConsensusDeleteTopic;
}
inline ::proto::ConsensusDeleteTopicTransactionBody* TransactionBody::release_consensusdeletetopic() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.consensusDeleteTopic)
  if (_internal_has_consensusdeletetopic()) {
    clear_has_data();
    ::proto::ConsensusDeleteTopicTransactionBody* temp = _impl_.data_.consensusdeletetopic_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.consensusdeletetopic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ConsensusDeleteTopicTransactionBody& TransactionBody::_internal_consensusdeletetopic() const {
  return _internal_has_consensusdeletetopic()
      ? *_impl_.data_.consensusdeletetopic_
      : reinterpret_cast< ::proto::ConsensusDeleteTopicTransactionBody&>(::proto::_ConsensusDeleteTopicTransactionBody_default_instance_);
}
inline const ::proto::ConsensusDeleteTopicTransactionBody& TransactionBody::consensusdeletetopic() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.consensusDeleteTopic)
  return _internal_consensusdeletetopic();
}
inline ::proto::ConsensusDeleteTopicTransactionBody* TransactionBody::unsafe_arena_release_consensusdeletetopic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.consensusDeleteTopic)
  if (_internal_has_consensusdeletetopic()) {
    clear_has_data();
    ::proto::ConsensusDeleteTopicTransactionBody* temp = _impl_.data_.consensusdeletetopic_;
    _impl_.data_.consensusdeletetopic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_consensusdeletetopic(::proto::ConsensusDeleteTopicTransactionBody* consensusdeletetopic) {
  clear_data();
  if (consensusdeletetopic) {
    set_has_consensusdeletetopic();
    _impl_.data_.consensusdeletetopic_ = consensusdeletetopic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.consensusDeleteTopic)
}
inline ::proto::ConsensusDeleteTopicTransactionBody* TransactionBody::_internal_mutable_consensusdeletetopic() {
  if (!_internal_has_consensusdeletetopic()) {
    clear_data();
    set_has_consensusdeletetopic();
    _impl_.data_.consensusdeletetopic_ = CreateMaybeMessage< ::proto::ConsensusDeleteTopicTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.consensusdeletetopic_;
}
inline ::proto::ConsensusDeleteTopicTransactionBody* TransactionBody::mutable_consensusdeletetopic() {
  ::proto::ConsensusDeleteTopicTransactionBody* _msg = _internal_mutable_consensusdeletetopic();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.consensusDeleteTopic)
  return _msg;
}

// .proto.ConsensusSubmitMessageTransactionBody consensusSubmitMessage = 27;
inline bool TransactionBody::_internal_has_consensussubmitmessage() const {
  return data_case() == kConsensusSubmitMessage;
}
inline bool TransactionBody::has_consensussubmitmessage() const {
  return _internal_has_consensussubmitmessage();
}
inline void TransactionBody::set_has_consensussubmitmessage() {
  _impl_._oneof_case_[0] = kConsensusSubmitMessage;
}
inline ::proto::ConsensusSubmitMessageTransactionBody* TransactionBody::release_consensussubmitmessage() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.consensusSubmitMessage)
  if (_internal_has_consensussubmitmessage()) {
    clear_has_data();
    ::proto::ConsensusSubmitMessageTransactionBody* temp = _impl_.data_.consensussubmitmessage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.consensussubmitmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ConsensusSubmitMessageTransactionBody& TransactionBody::_internal_consensussubmitmessage() const {
  return _internal_has_consensussubmitmessage()
      ? *_impl_.data_.consensussubmitmessage_
      : reinterpret_cast< ::proto::ConsensusSubmitMessageTransactionBody&>(::proto::_ConsensusSubmitMessageTransactionBody_default_instance_);
}
inline const ::proto::ConsensusSubmitMessageTransactionBody& TransactionBody::consensussubmitmessage() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.consensusSubmitMessage)
  return _internal_consensussubmitmessage();
}
inline ::proto::ConsensusSubmitMessageTransactionBody* TransactionBody::unsafe_arena_release_consensussubmitmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.consensusSubmitMessage)
  if (_internal_has_consensussubmitmessage()) {
    clear_has_data();
    ::proto::ConsensusSubmitMessageTransactionBody* temp = _impl_.data_.consensussubmitmessage_;
    _impl_.data_.consensussubmitmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_consensussubmitmessage(::proto::ConsensusSubmitMessageTransactionBody* consensussubmitmessage) {
  clear_data();
  if (consensussubmitmessage) {
    set_has_consensussubmitmessage();
    _impl_.data_.consensussubmitmessage_ = consensussubmitmessage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.consensusSubmitMessage)
}
inline ::proto::ConsensusSubmitMessageTransactionBody* TransactionBody::_internal_mutable_consensussubmitmessage() {
  if (!_internal_has_consensussubmitmessage()) {
    clear_data();
    set_has_consensussubmitmessage();
    _impl_.data_.consensussubmitmessage_ = CreateMaybeMessage< ::proto::ConsensusSubmitMessageTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.consensussubmitmessage_;
}
inline ::proto::ConsensusSubmitMessageTransactionBody* TransactionBody::mutable_consensussubmitmessage() {
  ::proto::ConsensusSubmitMessageTransactionBody* _msg = _internal_mutable_consensussubmitmessage();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.consensusSubmitMessage)
  return _msg;
}

// .proto.UncheckedSubmitBody uncheckedSubmit = 28;
inline bool TransactionBody::_internal_has_uncheckedsubmit() const {
  return data_case() == kUncheckedSubmit;
}
inline bool TransactionBody::has_uncheckedsubmit() const {
  return _internal_has_uncheckedsubmit();
}
inline void TransactionBody::set_has_uncheckedsubmit() {
  _impl_._oneof_case_[0] = kUncheckedSubmit;
}
inline ::proto::UncheckedSubmitBody* TransactionBody::release_uncheckedsubmit() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.uncheckedSubmit)
  if (_internal_has_uncheckedsubmit()) {
    clear_has_data();
    ::proto::UncheckedSubmitBody* temp = _impl_.data_.uncheckedsubmit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.uncheckedsubmit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::UncheckedSubmitBody& TransactionBody::_internal_uncheckedsubmit() const {
  return _internal_has_uncheckedsubmit()
      ? *_impl_.data_.uncheckedsubmit_
      : reinterpret_cast< ::proto::UncheckedSubmitBody&>(::proto::_UncheckedSubmitBody_default_instance_);
}
inline const ::proto::UncheckedSubmitBody& TransactionBody::uncheckedsubmit() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.uncheckedSubmit)
  return _internal_uncheckedsubmit();
}
inline ::proto::UncheckedSubmitBody* TransactionBody::unsafe_arena_release_uncheckedsubmit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.uncheckedSubmit)
  if (_internal_has_uncheckedsubmit()) {
    clear_has_data();
    ::proto::UncheckedSubmitBody* temp = _impl_.data_.uncheckedsubmit_;
    _impl_.data_.uncheckedsubmit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_uncheckedsubmit(::proto::UncheckedSubmitBody* uncheckedsubmit) {
  clear_data();
  if (uncheckedsubmit) {
    set_has_uncheckedsubmit();
    _impl_.data_.uncheckedsubmit_ = uncheckedsubmit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.uncheckedSubmit)
}
inline ::proto::UncheckedSubmitBody* TransactionBody::_internal_mutable_uncheckedsubmit() {
  if (!_internal_has_uncheckedsubmit()) {
    clear_data();
    set_has_uncheckedsubmit();
    _impl_.data_.uncheckedsubmit_ = CreateMaybeMessage< ::proto::UncheckedSubmitBody >(GetArenaForAllocation());
  }
  return _impl_.data_.uncheckedsubmit_;
}
inline ::proto::UncheckedSubmitBody* TransactionBody::mutable_uncheckedsubmit() {
  ::proto::UncheckedSubmitBody* _msg = _internal_mutable_uncheckedsubmit();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.uncheckedSubmit)
  return _msg;
}

// .proto.TokenCreateTransactionBody tokenCreation = 29;
inline bool TransactionBody::_internal_has_tokencreation() const {
  return data_case() == kTokenCreation;
}
inline bool TransactionBody::has_tokencreation() const {
  return _internal_has_tokencreation();
}
inline void TransactionBody::set_has_tokencreation() {
  _impl_._oneof_case_[0] = kTokenCreation;
}
inline ::proto::TokenCreateTransactionBody* TransactionBody::release_tokencreation() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.tokenCreation)
  if (_internal_has_tokencreation()) {
    clear_has_data();
    ::proto::TokenCreateTransactionBody* temp = _impl_.data_.tokencreation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokencreation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenCreateTransactionBody& TransactionBody::_internal_tokencreation() const {
  return _internal_has_tokencreation()
      ? *_impl_.data_.tokencreation_
      : reinterpret_cast< ::proto::TokenCreateTransactionBody&>(::proto::_TokenCreateTransactionBody_default_instance_);
}
inline const ::proto::TokenCreateTransactionBody& TransactionBody::tokencreation() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.tokenCreation)
  return _internal_tokencreation();
}
inline ::proto::TokenCreateTransactionBody* TransactionBody::unsafe_arena_release_tokencreation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.tokenCreation)
  if (_internal_has_tokencreation()) {
    clear_has_data();
    ::proto::TokenCreateTransactionBody* temp = _impl_.data_.tokencreation_;
    _impl_.data_.tokencreation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_tokencreation(::proto::TokenCreateTransactionBody* tokencreation) {
  clear_data();
  if (tokencreation) {
    set_has_tokencreation();
    _impl_.data_.tokencreation_ = tokencreation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.tokenCreation)
}
inline ::proto::TokenCreateTransactionBody* TransactionBody::_internal_mutable_tokencreation() {
  if (!_internal_has_tokencreation()) {
    clear_data();
    set_has_tokencreation();
    _impl_.data_.tokencreation_ = CreateMaybeMessage< ::proto::TokenCreateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokencreation_;
}
inline ::proto::TokenCreateTransactionBody* TransactionBody::mutable_tokencreation() {
  ::proto::TokenCreateTransactionBody* _msg = _internal_mutable_tokencreation();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.tokenCreation)
  return _msg;
}

// .proto.TokenFreezeAccountTransactionBody tokenFreeze = 31;
inline bool TransactionBody::_internal_has_tokenfreeze() const {
  return data_case() == kTokenFreeze;
}
inline bool TransactionBody::has_tokenfreeze() const {
  return _internal_has_tokenfreeze();
}
inline void TransactionBody::set_has_tokenfreeze() {
  _impl_._oneof_case_[0] = kTokenFreeze;
}
inline ::proto::TokenFreezeAccountTransactionBody* TransactionBody::release_tokenfreeze() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.tokenFreeze)
  if (_internal_has_tokenfreeze()) {
    clear_has_data();
    ::proto::TokenFreezeAccountTransactionBody* temp = _impl_.data_.tokenfreeze_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokenfreeze_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenFreezeAccountTransactionBody& TransactionBody::_internal_tokenfreeze() const {
  return _internal_has_tokenfreeze()
      ? *_impl_.data_.tokenfreeze_
      : reinterpret_cast< ::proto::TokenFreezeAccountTransactionBody&>(::proto::_TokenFreezeAccountTransactionBody_default_instance_);
}
inline const ::proto::TokenFreezeAccountTransactionBody& TransactionBody::tokenfreeze() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.tokenFreeze)
  return _internal_tokenfreeze();
}
inline ::proto::TokenFreezeAccountTransactionBody* TransactionBody::unsafe_arena_release_tokenfreeze() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.tokenFreeze)
  if (_internal_has_tokenfreeze()) {
    clear_has_data();
    ::proto::TokenFreezeAccountTransactionBody* temp = _impl_.data_.tokenfreeze_;
    _impl_.data_.tokenfreeze_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_tokenfreeze(::proto::TokenFreezeAccountTransactionBody* tokenfreeze) {
  clear_data();
  if (tokenfreeze) {
    set_has_tokenfreeze();
    _impl_.data_.tokenfreeze_ = tokenfreeze;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.tokenFreeze)
}
inline ::proto::TokenFreezeAccountTransactionBody* TransactionBody::_internal_mutable_tokenfreeze() {
  if (!_internal_has_tokenfreeze()) {
    clear_data();
    set_has_tokenfreeze();
    _impl_.data_.tokenfreeze_ = CreateMaybeMessage< ::proto::TokenFreezeAccountTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokenfreeze_;
}
inline ::proto::TokenFreezeAccountTransactionBody* TransactionBody::mutable_tokenfreeze() {
  ::proto::TokenFreezeAccountTransactionBody* _msg = _internal_mutable_tokenfreeze();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.tokenFreeze)
  return _msg;
}

// .proto.TokenUnfreezeAccountTransactionBody tokenUnfreeze = 32;
inline bool TransactionBody::_internal_has_tokenunfreeze() const {
  return data_case() == kTokenUnfreeze;
}
inline bool TransactionBody::has_tokenunfreeze() const {
  return _internal_has_tokenunfreeze();
}
inline void TransactionBody::set_has_tokenunfreeze() {
  _impl_._oneof_case_[0] = kTokenUnfreeze;
}
inline ::proto::TokenUnfreezeAccountTransactionBody* TransactionBody::release_tokenunfreeze() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.tokenUnfreeze)
  if (_internal_has_tokenunfreeze()) {
    clear_has_data();
    ::proto::TokenUnfreezeAccountTransactionBody* temp = _impl_.data_.tokenunfreeze_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokenunfreeze_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenUnfreezeAccountTransactionBody& TransactionBody::_internal_tokenunfreeze() const {
  return _internal_has_tokenunfreeze()
      ? *_impl_.data_.tokenunfreeze_
      : reinterpret_cast< ::proto::TokenUnfreezeAccountTransactionBody&>(::proto::_TokenUnfreezeAccountTransactionBody_default_instance_);
}
inline const ::proto::TokenUnfreezeAccountTransactionBody& TransactionBody::tokenunfreeze() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.tokenUnfreeze)
  return _internal_tokenunfreeze();
}
inline ::proto::TokenUnfreezeAccountTransactionBody* TransactionBody::unsafe_arena_release_tokenunfreeze() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.tokenUnfreeze)
  if (_internal_has_tokenunfreeze()) {
    clear_has_data();
    ::proto::TokenUnfreezeAccountTransactionBody* temp = _impl_.data_.tokenunfreeze_;
    _impl_.data_.tokenunfreeze_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_tokenunfreeze(::proto::TokenUnfreezeAccountTransactionBody* tokenunfreeze) {
  clear_data();
  if (tokenunfreeze) {
    set_has_tokenunfreeze();
    _impl_.data_.tokenunfreeze_ = tokenunfreeze;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.tokenUnfreeze)
}
inline ::proto::TokenUnfreezeAccountTransactionBody* TransactionBody::_internal_mutable_tokenunfreeze() {
  if (!_internal_has_tokenunfreeze()) {
    clear_data();
    set_has_tokenunfreeze();
    _impl_.data_.tokenunfreeze_ = CreateMaybeMessage< ::proto::TokenUnfreezeAccountTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokenunfreeze_;
}
inline ::proto::TokenUnfreezeAccountTransactionBody* TransactionBody::mutable_tokenunfreeze() {
  ::proto::TokenUnfreezeAccountTransactionBody* _msg = _internal_mutable_tokenunfreeze();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.tokenUnfreeze)
  return _msg;
}

// .proto.TokenGrantKycTransactionBody tokenGrantKyc = 33;
inline bool TransactionBody::_internal_has_tokengrantkyc() const {
  return data_case() == kTokenGrantKyc;
}
inline bool TransactionBody::has_tokengrantkyc() const {
  return _internal_has_tokengrantkyc();
}
inline void TransactionBody::set_has_tokengrantkyc() {
  _impl_._oneof_case_[0] = kTokenGrantKyc;
}
inline ::proto::TokenGrantKycTransactionBody* TransactionBody::release_tokengrantkyc() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.tokenGrantKyc)
  if (_internal_has_tokengrantkyc()) {
    clear_has_data();
    ::proto::TokenGrantKycTransactionBody* temp = _impl_.data_.tokengrantkyc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokengrantkyc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenGrantKycTransactionBody& TransactionBody::_internal_tokengrantkyc() const {
  return _internal_has_tokengrantkyc()
      ? *_impl_.data_.tokengrantkyc_
      : reinterpret_cast< ::proto::TokenGrantKycTransactionBody&>(::proto::_TokenGrantKycTransactionBody_default_instance_);
}
inline const ::proto::TokenGrantKycTransactionBody& TransactionBody::tokengrantkyc() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.tokenGrantKyc)
  return _internal_tokengrantkyc();
}
inline ::proto::TokenGrantKycTransactionBody* TransactionBody::unsafe_arena_release_tokengrantkyc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.tokenGrantKyc)
  if (_internal_has_tokengrantkyc()) {
    clear_has_data();
    ::proto::TokenGrantKycTransactionBody* temp = _impl_.data_.tokengrantkyc_;
    _impl_.data_.tokengrantkyc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_tokengrantkyc(::proto::TokenGrantKycTransactionBody* tokengrantkyc) {
  clear_data();
  if (tokengrantkyc) {
    set_has_tokengrantkyc();
    _impl_.data_.tokengrantkyc_ = tokengrantkyc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.tokenGrantKyc)
}
inline ::proto::TokenGrantKycTransactionBody* TransactionBody::_internal_mutable_tokengrantkyc() {
  if (!_internal_has_tokengrantkyc()) {
    clear_data();
    set_has_tokengrantkyc();
    _impl_.data_.tokengrantkyc_ = CreateMaybeMessage< ::proto::TokenGrantKycTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokengrantkyc_;
}
inline ::proto::TokenGrantKycTransactionBody* TransactionBody::mutable_tokengrantkyc() {
  ::proto::TokenGrantKycTransactionBody* _msg = _internal_mutable_tokengrantkyc();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.tokenGrantKyc)
  return _msg;
}

// .proto.TokenRevokeKycTransactionBody tokenRevokeKyc = 34;
inline bool TransactionBody::_internal_has_tokenrevokekyc() const {
  return data_case() == kTokenRevokeKyc;
}
inline bool TransactionBody::has_tokenrevokekyc() const {
  return _internal_has_tokenrevokekyc();
}
inline void TransactionBody::set_has_tokenrevokekyc() {
  _impl_._oneof_case_[0] = kTokenRevokeKyc;
}
inline ::proto::TokenRevokeKycTransactionBody* TransactionBody::release_tokenrevokekyc() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.tokenRevokeKyc)
  if (_internal_has_tokenrevokekyc()) {
    clear_has_data();
    ::proto::TokenRevokeKycTransactionBody* temp = _impl_.data_.tokenrevokekyc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokenrevokekyc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenRevokeKycTransactionBody& TransactionBody::_internal_tokenrevokekyc() const {
  return _internal_has_tokenrevokekyc()
      ? *_impl_.data_.tokenrevokekyc_
      : reinterpret_cast< ::proto::TokenRevokeKycTransactionBody&>(::proto::_TokenRevokeKycTransactionBody_default_instance_);
}
inline const ::proto::TokenRevokeKycTransactionBody& TransactionBody::tokenrevokekyc() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.tokenRevokeKyc)
  return _internal_tokenrevokekyc();
}
inline ::proto::TokenRevokeKycTransactionBody* TransactionBody::unsafe_arena_release_tokenrevokekyc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.tokenRevokeKyc)
  if (_internal_has_tokenrevokekyc()) {
    clear_has_data();
    ::proto::TokenRevokeKycTransactionBody* temp = _impl_.data_.tokenrevokekyc_;
    _impl_.data_.tokenrevokekyc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_tokenrevokekyc(::proto::TokenRevokeKycTransactionBody* tokenrevokekyc) {
  clear_data();
  if (tokenrevokekyc) {
    set_has_tokenrevokekyc();
    _impl_.data_.tokenrevokekyc_ = tokenrevokekyc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.tokenRevokeKyc)
}
inline ::proto::TokenRevokeKycTransactionBody* TransactionBody::_internal_mutable_tokenrevokekyc() {
  if (!_internal_has_tokenrevokekyc()) {
    clear_data();
    set_has_tokenrevokekyc();
    _impl_.data_.tokenrevokekyc_ = CreateMaybeMessage< ::proto::TokenRevokeKycTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokenrevokekyc_;
}
inline ::proto::TokenRevokeKycTransactionBody* TransactionBody::mutable_tokenrevokekyc() {
  ::proto::TokenRevokeKycTransactionBody* _msg = _internal_mutable_tokenrevokekyc();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.tokenRevokeKyc)
  return _msg;
}

// .proto.TokenDeleteTransactionBody tokenDeletion = 35;
inline bool TransactionBody::_internal_has_tokendeletion() const {
  return data_case() == kTokenDeletion;
}
inline bool TransactionBody::has_tokendeletion() const {
  return _internal_has_tokendeletion();
}
inline void TransactionBody::set_has_tokendeletion() {
  _impl_._oneof_case_[0] = kTokenDeletion;
}
inline ::proto::TokenDeleteTransactionBody* TransactionBody::release_tokendeletion() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.tokenDeletion)
  if (_internal_has_tokendeletion()) {
    clear_has_data();
    ::proto::TokenDeleteTransactionBody* temp = _impl_.data_.tokendeletion_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokendeletion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenDeleteTransactionBody& TransactionBody::_internal_tokendeletion() const {
  return _internal_has_tokendeletion()
      ? *_impl_.data_.tokendeletion_
      : reinterpret_cast< ::proto::TokenDeleteTransactionBody&>(::proto::_TokenDeleteTransactionBody_default_instance_);
}
inline const ::proto::TokenDeleteTransactionBody& TransactionBody::tokendeletion() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.tokenDeletion)
  return _internal_tokendeletion();
}
inline ::proto::TokenDeleteTransactionBody* TransactionBody::unsafe_arena_release_tokendeletion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.tokenDeletion)
  if (_internal_has_tokendeletion()) {
    clear_has_data();
    ::proto::TokenDeleteTransactionBody* temp = _impl_.data_.tokendeletion_;
    _impl_.data_.tokendeletion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_tokendeletion(::proto::TokenDeleteTransactionBody* tokendeletion) {
  clear_data();
  if (tokendeletion) {
    set_has_tokendeletion();
    _impl_.data_.tokendeletion_ = tokendeletion;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.tokenDeletion)
}
inline ::proto::TokenDeleteTransactionBody* TransactionBody::_internal_mutable_tokendeletion() {
  if (!_internal_has_tokendeletion()) {
    clear_data();
    set_has_tokendeletion();
    _impl_.data_.tokendeletion_ = CreateMaybeMessage< ::proto::TokenDeleteTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokendeletion_;
}
inline ::proto::TokenDeleteTransactionBody* TransactionBody::mutable_tokendeletion() {
  ::proto::TokenDeleteTransactionBody* _msg = _internal_mutable_tokendeletion();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.tokenDeletion)
  return _msg;
}

// .proto.TokenUpdateTransactionBody tokenUpdate = 36;
inline bool TransactionBody::_internal_has_tokenupdate() const {
  return data_case() == kTokenUpdate;
}
inline bool TransactionBody::has_tokenupdate() const {
  return _internal_has_tokenupdate();
}
inline void TransactionBody::set_has_tokenupdate() {
  _impl_._oneof_case_[0] = kTokenUpdate;
}
inline ::proto::TokenUpdateTransactionBody* TransactionBody::release_tokenupdate() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.tokenUpdate)
  if (_internal_has_tokenupdate()) {
    clear_has_data();
    ::proto::TokenUpdateTransactionBody* temp = _impl_.data_.tokenupdate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokenupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenUpdateTransactionBody& TransactionBody::_internal_tokenupdate() const {
  return _internal_has_tokenupdate()
      ? *_impl_.data_.tokenupdate_
      : reinterpret_cast< ::proto::TokenUpdateTransactionBody&>(::proto::_TokenUpdateTransactionBody_default_instance_);
}
inline const ::proto::TokenUpdateTransactionBody& TransactionBody::tokenupdate() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.tokenUpdate)
  return _internal_tokenupdate();
}
inline ::proto::TokenUpdateTransactionBody* TransactionBody::unsafe_arena_release_tokenupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.tokenUpdate)
  if (_internal_has_tokenupdate()) {
    clear_has_data();
    ::proto::TokenUpdateTransactionBody* temp = _impl_.data_.tokenupdate_;
    _impl_.data_.tokenupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_tokenupdate(::proto::TokenUpdateTransactionBody* tokenupdate) {
  clear_data();
  if (tokenupdate) {
    set_has_tokenupdate();
    _impl_.data_.tokenupdate_ = tokenupdate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.tokenUpdate)
}
inline ::proto::TokenUpdateTransactionBody* TransactionBody::_internal_mutable_tokenupdate() {
  if (!_internal_has_tokenupdate()) {
    clear_data();
    set_has_tokenupdate();
    _impl_.data_.tokenupdate_ = CreateMaybeMessage< ::proto::TokenUpdateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokenupdate_;
}
inline ::proto::TokenUpdateTransactionBody* TransactionBody::mutable_tokenupdate() {
  ::proto::TokenUpdateTransactionBody* _msg = _internal_mutable_tokenupdate();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.tokenUpdate)
  return _msg;
}

// .proto.TokenMintTransactionBody tokenMint = 37;
inline bool TransactionBody::_internal_has_tokenmint() const {
  return data_case() == kTokenMint;
}
inline bool TransactionBody::has_tokenmint() const {
  return _internal_has_tokenmint();
}
inline void TransactionBody::set_has_tokenmint() {
  _impl_._oneof_case_[0] = kTokenMint;
}
inline ::proto::TokenMintTransactionBody* TransactionBody::release_tokenmint() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.tokenMint)
  if (_internal_has_tokenmint()) {
    clear_has_data();
    ::proto::TokenMintTransactionBody* temp = _impl_.data_.tokenmint_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokenmint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenMintTransactionBody& TransactionBody::_internal_tokenmint() const {
  return _internal_has_tokenmint()
      ? *_impl_.data_.tokenmint_
      : reinterpret_cast< ::proto::TokenMintTransactionBody&>(::proto::_TokenMintTransactionBody_default_instance_);
}
inline const ::proto::TokenMintTransactionBody& TransactionBody::tokenmint() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.tokenMint)
  return _internal_tokenmint();
}
inline ::proto::TokenMintTransactionBody* TransactionBody::unsafe_arena_release_tokenmint() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.tokenMint)
  if (_internal_has_tokenmint()) {
    clear_has_data();
    ::proto::TokenMintTransactionBody* temp = _impl_.data_.tokenmint_;
    _impl_.data_.tokenmint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_tokenmint(::proto::TokenMintTransactionBody* tokenmint) {
  clear_data();
  if (tokenmint) {
    set_has_tokenmint();
    _impl_.data_.tokenmint_ = tokenmint;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.tokenMint)
}
inline ::proto::TokenMintTransactionBody* TransactionBody::_internal_mutable_tokenmint() {
  if (!_internal_has_tokenmint()) {
    clear_data();
    set_has_tokenmint();
    _impl_.data_.tokenmint_ = CreateMaybeMessage< ::proto::TokenMintTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokenmint_;
}
inline ::proto::TokenMintTransactionBody* TransactionBody::mutable_tokenmint() {
  ::proto::TokenMintTransactionBody* _msg = _internal_mutable_tokenmint();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.tokenMint)
  return _msg;
}

// .proto.TokenBurnTransactionBody tokenBurn = 38;
inline bool TransactionBody::_internal_has_tokenburn() const {
  return data_case() == kTokenBurn;
}
inline bool TransactionBody::has_tokenburn() const {
  return _internal_has_tokenburn();
}
inline void TransactionBody::set_has_tokenburn() {
  _impl_._oneof_case_[0] = kTokenBurn;
}
inline ::proto::TokenBurnTransactionBody* TransactionBody::release_tokenburn() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.tokenBurn)
  if (_internal_has_tokenburn()) {
    clear_has_data();
    ::proto::TokenBurnTransactionBody* temp = _impl_.data_.tokenburn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokenburn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenBurnTransactionBody& TransactionBody::_internal_tokenburn() const {
  return _internal_has_tokenburn()
      ? *_impl_.data_.tokenburn_
      : reinterpret_cast< ::proto::TokenBurnTransactionBody&>(::proto::_TokenBurnTransactionBody_default_instance_);
}
inline const ::proto::TokenBurnTransactionBody& TransactionBody::tokenburn() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.tokenBurn)
  return _internal_tokenburn();
}
inline ::proto::TokenBurnTransactionBody* TransactionBody::unsafe_arena_release_tokenburn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.tokenBurn)
  if (_internal_has_tokenburn()) {
    clear_has_data();
    ::proto::TokenBurnTransactionBody* temp = _impl_.data_.tokenburn_;
    _impl_.data_.tokenburn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_tokenburn(::proto::TokenBurnTransactionBody* tokenburn) {
  clear_data();
  if (tokenburn) {
    set_has_tokenburn();
    _impl_.data_.tokenburn_ = tokenburn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.tokenBurn)
}
inline ::proto::TokenBurnTransactionBody* TransactionBody::_internal_mutable_tokenburn() {
  if (!_internal_has_tokenburn()) {
    clear_data();
    set_has_tokenburn();
    _impl_.data_.tokenburn_ = CreateMaybeMessage< ::proto::TokenBurnTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokenburn_;
}
inline ::proto::TokenBurnTransactionBody* TransactionBody::mutable_tokenburn() {
  ::proto::TokenBurnTransactionBody* _msg = _internal_mutable_tokenburn();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.tokenBurn)
  return _msg;
}

// .proto.TokenWipeAccountTransactionBody tokenWipe = 39;
inline bool TransactionBody::_internal_has_tokenwipe() const {
  return data_case() == kTokenWipe;
}
inline bool TransactionBody::has_tokenwipe() const {
  return _internal_has_tokenwipe();
}
inline void TransactionBody::set_has_tokenwipe() {
  _impl_._oneof_case_[0] = kTokenWipe;
}
inline ::proto::TokenWipeAccountTransactionBody* TransactionBody::release_tokenwipe() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.tokenWipe)
  if (_internal_has_tokenwipe()) {
    clear_has_data();
    ::proto::TokenWipeAccountTransactionBody* temp = _impl_.data_.tokenwipe_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokenwipe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenWipeAccountTransactionBody& TransactionBody::_internal_tokenwipe() const {
  return _internal_has_tokenwipe()
      ? *_impl_.data_.tokenwipe_
      : reinterpret_cast< ::proto::TokenWipeAccountTransactionBody&>(::proto::_TokenWipeAccountTransactionBody_default_instance_);
}
inline const ::proto::TokenWipeAccountTransactionBody& TransactionBody::tokenwipe() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.tokenWipe)
  return _internal_tokenwipe();
}
inline ::proto::TokenWipeAccountTransactionBody* TransactionBody::unsafe_arena_release_tokenwipe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.tokenWipe)
  if (_internal_has_tokenwipe()) {
    clear_has_data();
    ::proto::TokenWipeAccountTransactionBody* temp = _impl_.data_.tokenwipe_;
    _impl_.data_.tokenwipe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_tokenwipe(::proto::TokenWipeAccountTransactionBody* tokenwipe) {
  clear_data();
  if (tokenwipe) {
    set_has_tokenwipe();
    _impl_.data_.tokenwipe_ = tokenwipe;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.tokenWipe)
}
inline ::proto::TokenWipeAccountTransactionBody* TransactionBody::_internal_mutable_tokenwipe() {
  if (!_internal_has_tokenwipe()) {
    clear_data();
    set_has_tokenwipe();
    _impl_.data_.tokenwipe_ = CreateMaybeMessage< ::proto::TokenWipeAccountTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokenwipe_;
}
inline ::proto::TokenWipeAccountTransactionBody* TransactionBody::mutable_tokenwipe() {
  ::proto::TokenWipeAccountTransactionBody* _msg = _internal_mutable_tokenwipe();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.tokenWipe)
  return _msg;
}

// .proto.TokenAssociateTransactionBody tokenAssociate = 40;
inline bool TransactionBody::_internal_has_tokenassociate() const {
  return data_case() == kTokenAssociate;
}
inline bool TransactionBody::has_tokenassociate() const {
  return _internal_has_tokenassociate();
}
inline void TransactionBody::set_has_tokenassociate() {
  _impl_._oneof_case_[0] = kTokenAssociate;
}
inline ::proto::TokenAssociateTransactionBody* TransactionBody::release_tokenassociate() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.tokenAssociate)
  if (_internal_has_tokenassociate()) {
    clear_has_data();
    ::proto::TokenAssociateTransactionBody* temp = _impl_.data_.tokenassociate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokenassociate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenAssociateTransactionBody& TransactionBody::_internal_tokenassociate() const {
  return _internal_has_tokenassociate()
      ? *_impl_.data_.tokenassociate_
      : reinterpret_cast< ::proto::TokenAssociateTransactionBody&>(::proto::_TokenAssociateTransactionBody_default_instance_);
}
inline const ::proto::TokenAssociateTransactionBody& TransactionBody::tokenassociate() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.tokenAssociate)
  return _internal_tokenassociate();
}
inline ::proto::TokenAssociateTransactionBody* TransactionBody::unsafe_arena_release_tokenassociate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.tokenAssociate)
  if (_internal_has_tokenassociate()) {
    clear_has_data();
    ::proto::TokenAssociateTransactionBody* temp = _impl_.data_.tokenassociate_;
    _impl_.data_.tokenassociate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_tokenassociate(::proto::TokenAssociateTransactionBody* tokenassociate) {
  clear_data();
  if (tokenassociate) {
    set_has_tokenassociate();
    _impl_.data_.tokenassociate_ = tokenassociate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.tokenAssociate)
}
inline ::proto::TokenAssociateTransactionBody* TransactionBody::_internal_mutable_tokenassociate() {
  if (!_internal_has_tokenassociate()) {
    clear_data();
    set_has_tokenassociate();
    _impl_.data_.tokenassociate_ = CreateMaybeMessage< ::proto::TokenAssociateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokenassociate_;
}
inline ::proto::TokenAssociateTransactionBody* TransactionBody::mutable_tokenassociate() {
  ::proto::TokenAssociateTransactionBody* _msg = _internal_mutable_tokenassociate();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.tokenAssociate)
  return _msg;
}

// .proto.TokenDissociateTransactionBody tokenDissociate = 41;
inline bool TransactionBody::_internal_has_tokendissociate() const {
  return data_case() == kTokenDissociate;
}
inline bool TransactionBody::has_tokendissociate() const {
  return _internal_has_tokendissociate();
}
inline void TransactionBody::set_has_tokendissociate() {
  _impl_._oneof_case_[0] = kTokenDissociate;
}
inline ::proto::TokenDissociateTransactionBody* TransactionBody::release_tokendissociate() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.tokenDissociate)
  if (_internal_has_tokendissociate()) {
    clear_has_data();
    ::proto::TokenDissociateTransactionBody* temp = _impl_.data_.tokendissociate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.tokendissociate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenDissociateTransactionBody& TransactionBody::_internal_tokendissociate() const {
  return _internal_has_tokendissociate()
      ? *_impl_.data_.tokendissociate_
      : reinterpret_cast< ::proto::TokenDissociateTransactionBody&>(::proto::_TokenDissociateTransactionBody_default_instance_);
}
inline const ::proto::TokenDissociateTransactionBody& TransactionBody::tokendissociate() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.tokenDissociate)
  return _internal_tokendissociate();
}
inline ::proto::TokenDissociateTransactionBody* TransactionBody::unsafe_arena_release_tokendissociate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.tokenDissociate)
  if (_internal_has_tokendissociate()) {
    clear_has_data();
    ::proto::TokenDissociateTransactionBody* temp = _impl_.data_.tokendissociate_;
    _impl_.data_.tokendissociate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_tokendissociate(::proto::TokenDissociateTransactionBody* tokendissociate) {
  clear_data();
  if (tokendissociate) {
    set_has_tokendissociate();
    _impl_.data_.tokendissociate_ = tokendissociate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.tokenDissociate)
}
inline ::proto::TokenDissociateTransactionBody* TransactionBody::_internal_mutable_tokendissociate() {
  if (!_internal_has_tokendissociate()) {
    clear_data();
    set_has_tokendissociate();
    _impl_.data_.tokendissociate_ = CreateMaybeMessage< ::proto::TokenDissociateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.tokendissociate_;
}
inline ::proto::TokenDissociateTransactionBody* TransactionBody::mutable_tokendissociate() {
  ::proto::TokenDissociateTransactionBody* _msg = _internal_mutable_tokendissociate();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.tokenDissociate)
  return _msg;
}

// .proto.TokenFeeScheduleUpdateTransactionBody token_fee_schedule_update = 45;
inline bool TransactionBody::_internal_has_token_fee_schedule_update() const {
  return data_case() == kTokenFeeScheduleUpdate;
}
inline bool TransactionBody::has_token_fee_schedule_update() const {
  return _internal_has_token_fee_schedule_update();
}
inline void TransactionBody::set_has_token_fee_schedule_update() {
  _impl_._oneof_case_[0] = kTokenFeeScheduleUpdate;
}
inline ::proto::TokenFeeScheduleUpdateTransactionBody* TransactionBody::release_token_fee_schedule_update() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.token_fee_schedule_update)
  if (_internal_has_token_fee_schedule_update()) {
    clear_has_data();
    ::proto::TokenFeeScheduleUpdateTransactionBody* temp = _impl_.data_.token_fee_schedule_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.token_fee_schedule_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenFeeScheduleUpdateTransactionBody& TransactionBody::_internal_token_fee_schedule_update() const {
  return _internal_has_token_fee_schedule_update()
      ? *_impl_.data_.token_fee_schedule_update_
      : reinterpret_cast< ::proto::TokenFeeScheduleUpdateTransactionBody&>(::proto::_TokenFeeScheduleUpdateTransactionBody_default_instance_);
}
inline const ::proto::TokenFeeScheduleUpdateTransactionBody& TransactionBody::token_fee_schedule_update() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.token_fee_schedule_update)
  return _internal_token_fee_schedule_update();
}
inline ::proto::TokenFeeScheduleUpdateTransactionBody* TransactionBody::unsafe_arena_release_token_fee_schedule_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.token_fee_schedule_update)
  if (_internal_has_token_fee_schedule_update()) {
    clear_has_data();
    ::proto::TokenFeeScheduleUpdateTransactionBody* temp = _impl_.data_.token_fee_schedule_update_;
    _impl_.data_.token_fee_schedule_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_token_fee_schedule_update(::proto::TokenFeeScheduleUpdateTransactionBody* token_fee_schedule_update) {
  clear_data();
  if (token_fee_schedule_update) {
    set_has_token_fee_schedule_update();
    _impl_.data_.token_fee_schedule_update_ = token_fee_schedule_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.token_fee_schedule_update)
}
inline ::proto::TokenFeeScheduleUpdateTransactionBody* TransactionBody::_internal_mutable_token_fee_schedule_update() {
  if (!_internal_has_token_fee_schedule_update()) {
    clear_data();
    set_has_token_fee_schedule_update();
    _impl_.data_.token_fee_schedule_update_ = CreateMaybeMessage< ::proto::TokenFeeScheduleUpdateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.token_fee_schedule_update_;
}
inline ::proto::TokenFeeScheduleUpdateTransactionBody* TransactionBody::mutable_token_fee_schedule_update() {
  ::proto::TokenFeeScheduleUpdateTransactionBody* _msg = _internal_mutable_token_fee_schedule_update();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.token_fee_schedule_update)
  return _msg;
}

// .proto.TokenPauseTransactionBody token_pause = 46;
inline bool TransactionBody::_internal_has_token_pause() const {
  return data_case() == kTokenPause;
}
inline bool TransactionBody::has_token_pause() const {
  return _internal_has_token_pause();
}
inline void TransactionBody::set_has_token_pause() {
  _impl_._oneof_case_[0] = kTokenPause;
}
inline ::proto::TokenPauseTransactionBody* TransactionBody::release_token_pause() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.token_pause)
  if (_internal_has_token_pause()) {
    clear_has_data();
    ::proto::TokenPauseTransactionBody* temp = _impl_.data_.token_pause_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.token_pause_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenPauseTransactionBody& TransactionBody::_internal_token_pause() const {
  return _internal_has_token_pause()
      ? *_impl_.data_.token_pause_
      : reinterpret_cast< ::proto::TokenPauseTransactionBody&>(::proto::_TokenPauseTransactionBody_default_instance_);
}
inline const ::proto::TokenPauseTransactionBody& TransactionBody::token_pause() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.token_pause)
  return _internal_token_pause();
}
inline ::proto::TokenPauseTransactionBody* TransactionBody::unsafe_arena_release_token_pause() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.token_pause)
  if (_internal_has_token_pause()) {
    clear_has_data();
    ::proto::TokenPauseTransactionBody* temp = _impl_.data_.token_pause_;
    _impl_.data_.token_pause_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_token_pause(::proto::TokenPauseTransactionBody* token_pause) {
  clear_data();
  if (token_pause) {
    set_has_token_pause();
    _impl_.data_.token_pause_ = token_pause;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.token_pause)
}
inline ::proto::TokenPauseTransactionBody* TransactionBody::_internal_mutable_token_pause() {
  if (!_internal_has_token_pause()) {
    clear_data();
    set_has_token_pause();
    _impl_.data_.token_pause_ = CreateMaybeMessage< ::proto::TokenPauseTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.token_pause_;
}
inline ::proto::TokenPauseTransactionBody* TransactionBody::mutable_token_pause() {
  ::proto::TokenPauseTransactionBody* _msg = _internal_mutable_token_pause();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.token_pause)
  return _msg;
}

// .proto.TokenUnpauseTransactionBody token_unpause = 47;
inline bool TransactionBody::_internal_has_token_unpause() const {
  return data_case() == kTokenUnpause;
}
inline bool TransactionBody::has_token_unpause() const {
  return _internal_has_token_unpause();
}
inline void TransactionBody::set_has_token_unpause() {
  _impl_._oneof_case_[0] = kTokenUnpause;
}
inline ::proto::TokenUnpauseTransactionBody* TransactionBody::release_token_unpause() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.token_unpause)
  if (_internal_has_token_unpause()) {
    clear_has_data();
    ::proto::TokenUnpauseTransactionBody* temp = _impl_.data_.token_unpause_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.token_unpause_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::TokenUnpauseTransactionBody& TransactionBody::_internal_token_unpause() const {
  return _internal_has_token_unpause()
      ? *_impl_.data_.token_unpause_
      : reinterpret_cast< ::proto::TokenUnpauseTransactionBody&>(::proto::_TokenUnpauseTransactionBody_default_instance_);
}
inline const ::proto::TokenUnpauseTransactionBody& TransactionBody::token_unpause() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.token_unpause)
  return _internal_token_unpause();
}
inline ::proto::TokenUnpauseTransactionBody* TransactionBody::unsafe_arena_release_token_unpause() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.token_unpause)
  if (_internal_has_token_unpause()) {
    clear_has_data();
    ::proto::TokenUnpauseTransactionBody* temp = _impl_.data_.token_unpause_;
    _impl_.data_.token_unpause_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_token_unpause(::proto::TokenUnpauseTransactionBody* token_unpause) {
  clear_data();
  if (token_unpause) {
    set_has_token_unpause();
    _impl_.data_.token_unpause_ = token_unpause;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.token_unpause)
}
inline ::proto::TokenUnpauseTransactionBody* TransactionBody::_internal_mutable_token_unpause() {
  if (!_internal_has_token_unpause()) {
    clear_data();
    set_has_token_unpause();
    _impl_.data_.token_unpause_ = CreateMaybeMessage< ::proto::TokenUnpauseTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.token_unpause_;
}
inline ::proto::TokenUnpauseTransactionBody* TransactionBody::mutable_token_unpause() {
  ::proto::TokenUnpauseTransactionBody* _msg = _internal_mutable_token_unpause();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.token_unpause)
  return _msg;
}

// .proto.ScheduleCreateTransactionBody scheduleCreate = 42;
inline bool TransactionBody::_internal_has_schedulecreate() const {
  return data_case() == kScheduleCreate;
}
inline bool TransactionBody::has_schedulecreate() const {
  return _internal_has_schedulecreate();
}
inline void TransactionBody::set_has_schedulecreate() {
  _impl_._oneof_case_[0] = kScheduleCreate;
}
inline ::proto::ScheduleCreateTransactionBody* TransactionBody::release_schedulecreate() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.scheduleCreate)
  if (_internal_has_schedulecreate()) {
    clear_has_data();
    ::proto::ScheduleCreateTransactionBody* temp = _impl_.data_.schedulecreate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.schedulecreate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ScheduleCreateTransactionBody& TransactionBody::_internal_schedulecreate() const {
  return _internal_has_schedulecreate()
      ? *_impl_.data_.schedulecreate_
      : reinterpret_cast< ::proto::ScheduleCreateTransactionBody&>(::proto::_ScheduleCreateTransactionBody_default_instance_);
}
inline const ::proto::ScheduleCreateTransactionBody& TransactionBody::schedulecreate() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.scheduleCreate)
  return _internal_schedulecreate();
}
inline ::proto::ScheduleCreateTransactionBody* TransactionBody::unsafe_arena_release_schedulecreate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.scheduleCreate)
  if (_internal_has_schedulecreate()) {
    clear_has_data();
    ::proto::ScheduleCreateTransactionBody* temp = _impl_.data_.schedulecreate_;
    _impl_.data_.schedulecreate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_schedulecreate(::proto::ScheduleCreateTransactionBody* schedulecreate) {
  clear_data();
  if (schedulecreate) {
    set_has_schedulecreate();
    _impl_.data_.schedulecreate_ = schedulecreate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.scheduleCreate)
}
inline ::proto::ScheduleCreateTransactionBody* TransactionBody::_internal_mutable_schedulecreate() {
  if (!_internal_has_schedulecreate()) {
    clear_data();
    set_has_schedulecreate();
    _impl_.data_.schedulecreate_ = CreateMaybeMessage< ::proto::ScheduleCreateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.schedulecreate_;
}
inline ::proto::ScheduleCreateTransactionBody* TransactionBody::mutable_schedulecreate() {
  ::proto::ScheduleCreateTransactionBody* _msg = _internal_mutable_schedulecreate();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.scheduleCreate)
  return _msg;
}

// .proto.ScheduleDeleteTransactionBody scheduleDelete = 43;
inline bool TransactionBody::_internal_has_scheduledelete() const {
  return data_case() == kScheduleDelete;
}
inline bool TransactionBody::has_scheduledelete() const {
  return _internal_has_scheduledelete();
}
inline void TransactionBody::set_has_scheduledelete() {
  _impl_._oneof_case_[0] = kScheduleDelete;
}
inline ::proto::ScheduleDeleteTransactionBody* TransactionBody::release_scheduledelete() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.scheduleDelete)
  if (_internal_has_scheduledelete()) {
    clear_has_data();
    ::proto::ScheduleDeleteTransactionBody* temp = _impl_.data_.scheduledelete_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.scheduledelete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ScheduleDeleteTransactionBody& TransactionBody::_internal_scheduledelete() const {
  return _internal_has_scheduledelete()
      ? *_impl_.data_.scheduledelete_
      : reinterpret_cast< ::proto::ScheduleDeleteTransactionBody&>(::proto::_ScheduleDeleteTransactionBody_default_instance_);
}
inline const ::proto::ScheduleDeleteTransactionBody& TransactionBody::scheduledelete() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.scheduleDelete)
  return _internal_scheduledelete();
}
inline ::proto::ScheduleDeleteTransactionBody* TransactionBody::unsafe_arena_release_scheduledelete() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.scheduleDelete)
  if (_internal_has_scheduledelete()) {
    clear_has_data();
    ::proto::ScheduleDeleteTransactionBody* temp = _impl_.data_.scheduledelete_;
    _impl_.data_.scheduledelete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_scheduledelete(::proto::ScheduleDeleteTransactionBody* scheduledelete) {
  clear_data();
  if (scheduledelete) {
    set_has_scheduledelete();
    _impl_.data_.scheduledelete_ = scheduledelete;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.scheduleDelete)
}
inline ::proto::ScheduleDeleteTransactionBody* TransactionBody::_internal_mutable_scheduledelete() {
  if (!_internal_has_scheduledelete()) {
    clear_data();
    set_has_scheduledelete();
    _impl_.data_.scheduledelete_ = CreateMaybeMessage< ::proto::ScheduleDeleteTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.scheduledelete_;
}
inline ::proto::ScheduleDeleteTransactionBody* TransactionBody::mutable_scheduledelete() {
  ::proto::ScheduleDeleteTransactionBody* _msg = _internal_mutable_scheduledelete();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.scheduleDelete)
  return _msg;
}

// .proto.ScheduleSignTransactionBody scheduleSign = 44;
inline bool TransactionBody::_internal_has_schedulesign() const {
  return data_case() == kScheduleSign;
}
inline bool TransactionBody::has_schedulesign() const {
  return _internal_has_schedulesign();
}
inline void TransactionBody::set_has_schedulesign() {
  _impl_._oneof_case_[0] = kScheduleSign;
}
inline ::proto::ScheduleSignTransactionBody* TransactionBody::release_schedulesign() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.scheduleSign)
  if (_internal_has_schedulesign()) {
    clear_has_data();
    ::proto::ScheduleSignTransactionBody* temp = _impl_.data_.schedulesign_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.schedulesign_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ScheduleSignTransactionBody& TransactionBody::_internal_schedulesign() const {
  return _internal_has_schedulesign()
      ? *_impl_.data_.schedulesign_
      : reinterpret_cast< ::proto::ScheduleSignTransactionBody&>(::proto::_ScheduleSignTransactionBody_default_instance_);
}
inline const ::proto::ScheduleSignTransactionBody& TransactionBody::schedulesign() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.scheduleSign)
  return _internal_schedulesign();
}
inline ::proto::ScheduleSignTransactionBody* TransactionBody::unsafe_arena_release_schedulesign() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.scheduleSign)
  if (_internal_has_schedulesign()) {
    clear_has_data();
    ::proto::ScheduleSignTransactionBody* temp = _impl_.data_.schedulesign_;
    _impl_.data_.schedulesign_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_schedulesign(::proto::ScheduleSignTransactionBody* schedulesign) {
  clear_data();
  if (schedulesign) {
    set_has_schedulesign();
    _impl_.data_.schedulesign_ = schedulesign;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.scheduleSign)
}
inline ::proto::ScheduleSignTransactionBody* TransactionBody::_internal_mutable_schedulesign() {
  if (!_internal_has_schedulesign()) {
    clear_data();
    set_has_schedulesign();
    _impl_.data_.schedulesign_ = CreateMaybeMessage< ::proto::ScheduleSignTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.schedulesign_;
}
inline ::proto::ScheduleSignTransactionBody* TransactionBody::mutable_schedulesign() {
  ::proto::ScheduleSignTransactionBody* _msg = _internal_mutable_schedulesign();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.scheduleSign)
  return _msg;
}

// .proto.NodeStakeUpdateTransactionBody node_stake_update = 51;
inline bool TransactionBody::_internal_has_node_stake_update() const {
  return data_case() == kNodeStakeUpdate;
}
inline bool TransactionBody::has_node_stake_update() const {
  return _internal_has_node_stake_update();
}
inline void TransactionBody::set_has_node_stake_update() {
  _impl_._oneof_case_[0] = kNodeStakeUpdate;
}
inline ::proto::NodeStakeUpdateTransactionBody* TransactionBody::release_node_stake_update() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.node_stake_update)
  if (_internal_has_node_stake_update()) {
    clear_has_data();
    ::proto::NodeStakeUpdateTransactionBody* temp = _impl_.data_.node_stake_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.node_stake_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::NodeStakeUpdateTransactionBody& TransactionBody::_internal_node_stake_update() const {
  return _internal_has_node_stake_update()
      ? *_impl_.data_.node_stake_update_
      : reinterpret_cast< ::proto::NodeStakeUpdateTransactionBody&>(::proto::_NodeStakeUpdateTransactionBody_default_instance_);
}
inline const ::proto::NodeStakeUpdateTransactionBody& TransactionBody::node_stake_update() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.node_stake_update)
  return _internal_node_stake_update();
}
inline ::proto::NodeStakeUpdateTransactionBody* TransactionBody::unsafe_arena_release_node_stake_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.node_stake_update)
  if (_internal_has_node_stake_update()) {
    clear_has_data();
    ::proto::NodeStakeUpdateTransactionBody* temp = _impl_.data_.node_stake_update_;
    _impl_.data_.node_stake_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_node_stake_update(::proto::NodeStakeUpdateTransactionBody* node_stake_update) {
  clear_data();
  if (node_stake_update) {
    set_has_node_stake_update();
    _impl_.data_.node_stake_update_ = node_stake_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.node_stake_update)
}
inline ::proto::NodeStakeUpdateTransactionBody* TransactionBody::_internal_mutable_node_stake_update() {
  if (!_internal_has_node_stake_update()) {
    clear_data();
    set_has_node_stake_update();
    _impl_.data_.node_stake_update_ = CreateMaybeMessage< ::proto::NodeStakeUpdateTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.node_stake_update_;
}
inline ::proto::NodeStakeUpdateTransactionBody* TransactionBody::mutable_node_stake_update() {
  ::proto::NodeStakeUpdateTransactionBody* _msg = _internal_mutable_node_stake_update();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.node_stake_update)
  return _msg;
}

// .proto.UtilPrngTransactionBody util_prng = 52;
inline bool TransactionBody::_internal_has_util_prng() const {
  return data_case() == kUtilPrng;
}
inline bool TransactionBody::has_util_prng() const {
  return _internal_has_util_prng();
}
inline void TransactionBody::set_has_util_prng() {
  _impl_._oneof_case_[0] = kUtilPrng;
}
inline ::proto::UtilPrngTransactionBody* TransactionBody::release_util_prng() {
  // @@protoc_insertion_point(field_release:proto.TransactionBody.util_prng)
  if (_internal_has_util_prng()) {
    clear_has_data();
    ::proto::UtilPrngTransactionBody* temp = _impl_.data_.util_prng_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.util_prng_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::UtilPrngTransactionBody& TransactionBody::_internal_util_prng() const {
  return _internal_has_util_prng()
      ? *_impl_.data_.util_prng_
      : reinterpret_cast< ::proto::UtilPrngTransactionBody&>(::proto::_UtilPrngTransactionBody_default_instance_);
}
inline const ::proto::UtilPrngTransactionBody& TransactionBody::util_prng() const {
  // @@protoc_insertion_point(field_get:proto.TransactionBody.util_prng)
  return _internal_util_prng();
}
inline ::proto::UtilPrngTransactionBody* TransactionBody::unsafe_arena_release_util_prng() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.TransactionBody.util_prng)
  if (_internal_has_util_prng()) {
    clear_has_data();
    ::proto::UtilPrngTransactionBody* temp = _impl_.data_.util_prng_;
    _impl_.data_.util_prng_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionBody::unsafe_arena_set_allocated_util_prng(::proto::UtilPrngTransactionBody* util_prng) {
  clear_data();
  if (util_prng) {
    set_has_util_prng();
    _impl_.data_.util_prng_ = util_prng;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.TransactionBody.util_prng)
}
inline ::proto::UtilPrngTransactionBody* TransactionBody::_internal_mutable_util_prng() {
  if (!_internal_has_util_prng()) {
    clear_data();
    set_has_util_prng();
    _impl_.data_.util_prng_ = CreateMaybeMessage< ::proto::UtilPrngTransactionBody >(GetArenaForAllocation());
  }
  return _impl_.data_.util_prng_;
}
inline ::proto::UtilPrngTransactionBody* TransactionBody::mutable_util_prng() {
  ::proto::UtilPrngTransactionBody* _msg = _internal_mutable_util_prng();
  // @@protoc_insertion_point(field_mutable:proto.TransactionBody.util_prng)
  return _msg;
}

inline bool TransactionBody::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void TransactionBody::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline TransactionBody::DataCase TransactionBody::data_case() const {
  return TransactionBody::DataCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_transaction_5fbody_2eproto
