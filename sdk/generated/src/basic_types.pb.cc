// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: basic_types.proto

#include "basic_types.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace proto {
PROTOBUF_CONSTEXPR ShardID::ShardID(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.shardnum_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ShardIDDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShardIDDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShardIDDefaultTypeInternal() {}
  union {
    ShardID _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShardIDDefaultTypeInternal _ShardID_default_instance_;
PROTOBUF_CONSTEXPR RealmID::RealmID(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.shardnum_)*/int64_t{0}
  , /*decltype(_impl_.realmnum_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RealmIDDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RealmIDDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RealmIDDefaultTypeInternal() {}
  union {
    RealmID _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RealmIDDefaultTypeInternal _RealmID_default_instance_;
PROTOBUF_CONSTEXPR AccountID::AccountID(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.shardnum_)*/int64_t{0}
  , /*decltype(_impl_.realmnum_)*/int64_t{0}
  , /*decltype(_impl_.account_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct AccountIDDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountIDDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountIDDefaultTypeInternal() {}
  union {
    AccountID _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountIDDefaultTypeInternal _AccountID_default_instance_;
PROTOBUF_CONSTEXPR FileID::FileID(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.shardnum_)*/int64_t{0}
  , /*decltype(_impl_.realmnum_)*/int64_t{0}
  , /*decltype(_impl_.filenum_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FileIDDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FileIDDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FileIDDefaultTypeInternal() {}
  union {
    FileID _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileIDDefaultTypeInternal _FileID_default_instance_;
PROTOBUF_CONSTEXPR ContractID::ContractID(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.shardnum_)*/int64_t{0}
  , /*decltype(_impl_.realmnum_)*/int64_t{0}
  , /*decltype(_impl_.contract_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ContractIDDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractIDDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractIDDefaultTypeInternal() {}
  union {
    ContractID _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractIDDefaultTypeInternal _ContractID_default_instance_;
PROTOBUF_CONSTEXPR TransactionID::TransactionID(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.transactionvalidstart_)*/nullptr
  , /*decltype(_impl_.accountid_)*/nullptr
  , /*decltype(_impl_.scheduled_)*/false
  , /*decltype(_impl_.nonce_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TransactionIDDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransactionIDDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransactionIDDefaultTypeInternal() {}
  union {
    TransactionID _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransactionIDDefaultTypeInternal _TransactionID_default_instance_;
PROTOBUF_CONSTEXPR AccountAmount::AccountAmount(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.accountid_)*/nullptr
  , /*decltype(_impl_.amount_)*/int64_t{0}
  , /*decltype(_impl_.is_approval_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AccountAmountDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountAmountDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountAmountDefaultTypeInternal() {}
  union {
    AccountAmount _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountAmountDefaultTypeInternal _AccountAmount_default_instance_;
PROTOBUF_CONSTEXPR TransferList::TransferList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.accountamounts_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TransferListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransferListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransferListDefaultTypeInternal() {}
  union {
    TransferList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransferListDefaultTypeInternal _TransferList_default_instance_;
PROTOBUF_CONSTEXPR NftTransfer::NftTransfer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.senderaccountid_)*/nullptr
  , /*decltype(_impl_.receiveraccountid_)*/nullptr
  , /*decltype(_impl_.serialnumber_)*/int64_t{0}
  , /*decltype(_impl_.is_approval_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NftTransferDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NftTransferDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NftTransferDefaultTypeInternal() {}
  union {
    NftTransfer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NftTransferDefaultTypeInternal _NftTransfer_default_instance_;
PROTOBUF_CONSTEXPR TokenTransferList::TokenTransferList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.transfers_)*/{}
  , /*decltype(_impl_.nfttransfers_)*/{}
  , /*decltype(_impl_.token_)*/nullptr
  , /*decltype(_impl_.expected_decimals_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TokenTransferListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TokenTransferListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TokenTransferListDefaultTypeInternal() {}
  union {
    TokenTransferList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TokenTransferListDefaultTypeInternal _TokenTransferList_default_instance_;
PROTOBUF_CONSTEXPR Fraction::Fraction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.numerator_)*/int64_t{0}
  , /*decltype(_impl_.denominator_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FractionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FractionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FractionDefaultTypeInternal() {}
  union {
    Fraction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FractionDefaultTypeInternal _Fraction_default_instance_;
PROTOBUF_CONSTEXPR TopicID::TopicID(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.shardnum_)*/int64_t{0}
  , /*decltype(_impl_.realmnum_)*/int64_t{0}
  , /*decltype(_impl_.topicnum_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TopicIDDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TopicIDDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TopicIDDefaultTypeInternal() {}
  union {
    TopicID _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TopicIDDefaultTypeInternal _TopicID_default_instance_;
PROTOBUF_CONSTEXPR TokenID::TokenID(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.shardnum_)*/int64_t{0}
  , /*decltype(_impl_.realmnum_)*/int64_t{0}
  , /*decltype(_impl_.tokennum_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TokenIDDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TokenIDDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TokenIDDefaultTypeInternal() {}
  union {
    TokenID _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TokenIDDefaultTypeInternal _TokenID_default_instance_;
PROTOBUF_CONSTEXPR ScheduleID::ScheduleID(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.shardnum_)*/int64_t{0}
  , /*decltype(_impl_.realmnum_)*/int64_t{0}
  , /*decltype(_impl_.schedulenum_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ScheduleIDDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScheduleIDDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScheduleIDDefaultTypeInternal() {}
  union {
    ScheduleID _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScheduleIDDefaultTypeInternal _ScheduleID_default_instance_;
PROTOBUF_CONSTEXPR Key::Key(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct KeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyDefaultTypeInternal() {}
  union {
    Key _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyDefaultTypeInternal _Key_default_instance_;
PROTOBUF_CONSTEXPR ThresholdKey::ThresholdKey(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.keys_)*/nullptr
  , /*decltype(_impl_.threshold_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ThresholdKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThresholdKeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThresholdKeyDefaultTypeInternal() {}
  union {
    ThresholdKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThresholdKeyDefaultTypeInternal _ThresholdKey_default_instance_;
PROTOBUF_CONSTEXPR KeyList::KeyList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.keys_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct KeyListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyListDefaultTypeInternal() {}
  union {
    KeyList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyListDefaultTypeInternal _KeyList_default_instance_;
PROTOBUF_CONSTEXPR Signature::Signature(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.signature_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct SignatureDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignatureDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignatureDefaultTypeInternal() {}
  union {
    Signature _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignatureDefaultTypeInternal _Signature_default_instance_;
PROTOBUF_CONSTEXPR ThresholdSignature::ThresholdSignature(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.sigs_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ThresholdSignatureDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThresholdSignatureDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThresholdSignatureDefaultTypeInternal() {}
  union {
    ThresholdSignature _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThresholdSignatureDefaultTypeInternal _ThresholdSignature_default_instance_;
PROTOBUF_CONSTEXPR SignatureList::SignatureList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.sigs_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SignatureListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignatureListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignatureListDefaultTypeInternal() {}
  union {
    SignatureList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignatureListDefaultTypeInternal _SignatureList_default_instance_;
PROTOBUF_CONSTEXPR SignaturePair::SignaturePair(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pubkeyprefix_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signature_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct SignaturePairDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignaturePairDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignaturePairDefaultTypeInternal() {}
  union {
    SignaturePair _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignaturePairDefaultTypeInternal _SignaturePair_default_instance_;
PROTOBUF_CONSTEXPR SignatureMap::SignatureMap(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.sigpair_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SignatureMapDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignatureMapDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignatureMapDefaultTypeInternal() {}
  union {
    SignatureMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignatureMapDefaultTypeInternal _SignatureMap_default_instance_;
PROTOBUF_CONSTEXPR FeeComponents::FeeComponents(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.min_)*/int64_t{0}
  , /*decltype(_impl_.max_)*/int64_t{0}
  , /*decltype(_impl_.constant_)*/int64_t{0}
  , /*decltype(_impl_.bpt_)*/int64_t{0}
  , /*decltype(_impl_.vpt_)*/int64_t{0}
  , /*decltype(_impl_.rbh_)*/int64_t{0}
  , /*decltype(_impl_.sbh_)*/int64_t{0}
  , /*decltype(_impl_.gas_)*/int64_t{0}
  , /*decltype(_impl_.tv_)*/int64_t{0}
  , /*decltype(_impl_.bpr_)*/int64_t{0}
  , /*decltype(_impl_.sbpr_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FeeComponentsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeeComponentsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeeComponentsDefaultTypeInternal() {}
  union {
    FeeComponents _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeeComponentsDefaultTypeInternal _FeeComponents_default_instance_;
PROTOBUF_CONSTEXPR TransactionFeeSchedule::TransactionFeeSchedule(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.fees_)*/{}
  , /*decltype(_impl_.feedata_)*/nullptr
  , /*decltype(_impl_.hederafunctionality_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TransactionFeeScheduleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransactionFeeScheduleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransactionFeeScheduleDefaultTypeInternal() {}
  union {
    TransactionFeeSchedule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransactionFeeScheduleDefaultTypeInternal _TransactionFeeSchedule_default_instance_;
PROTOBUF_CONSTEXPR FeeData::FeeData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nodedata_)*/nullptr
  , /*decltype(_impl_.networkdata_)*/nullptr
  , /*decltype(_impl_.servicedata_)*/nullptr
  , /*decltype(_impl_.subtype_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FeeDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeeDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeeDataDefaultTypeInternal() {}
  union {
    FeeData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeeDataDefaultTypeInternal _FeeData_default_instance_;
PROTOBUF_CONSTEXPR FeeSchedule::FeeSchedule(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.transactionfeeschedule_)*/{}
  , /*decltype(_impl_.expirytime_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FeeScheduleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeeScheduleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeeScheduleDefaultTypeInternal() {}
  union {
    FeeSchedule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeeScheduleDefaultTypeInternal _FeeSchedule_default_instance_;
PROTOBUF_CONSTEXPR CurrentAndNextFeeSchedule::CurrentAndNextFeeSchedule(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.currentfeeschedule_)*/nullptr
  , /*decltype(_impl_.nextfeeschedule_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CurrentAndNextFeeScheduleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CurrentAndNextFeeScheduleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CurrentAndNextFeeScheduleDefaultTypeInternal() {}
  union {
    CurrentAndNextFeeSchedule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CurrentAndNextFeeScheduleDefaultTypeInternal _CurrentAndNextFeeSchedule_default_instance_;
PROTOBUF_CONSTEXPR ServiceEndpoint::ServiceEndpoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ipaddressv4_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.port_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ServiceEndpointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceEndpointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceEndpointDefaultTypeInternal() {}
  union {
    ServiceEndpoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceEndpointDefaultTypeInternal _ServiceEndpoint_default_instance_;
PROTOBUF_CONSTEXPR NodeAddress::NodeAddress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.serviceendpoint_)*/{}
  , /*decltype(_impl_.ipaddress_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.memo_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.rsa_pubkey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nodecerthash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nodeaccountid_)*/nullptr
  , /*decltype(_impl_.nodeid_)*/int64_t{0}
  , /*decltype(_impl_.stake_)*/int64_t{0}
  , /*decltype(_impl_.portno_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NodeAddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeAddressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeAddressDefaultTypeInternal() {}
  union {
    NodeAddress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeAddressDefaultTypeInternal _NodeAddress_default_instance_;
PROTOBUF_CONSTEXPR NodeAddressBook::NodeAddressBook(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nodeaddress_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NodeAddressBookDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeAddressBookDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeAddressBookDefaultTypeInternal() {}
  union {
    NodeAddressBook _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeAddressBookDefaultTypeInternal _NodeAddressBook_default_instance_;
PROTOBUF_CONSTEXPR SemanticVersion::SemanticVersion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pre_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.build_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.major_)*/0
  , /*decltype(_impl_.minor_)*/0
  , /*decltype(_impl_.patch_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SemanticVersionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SemanticVersionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SemanticVersionDefaultTypeInternal() {}
  union {
    SemanticVersion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SemanticVersionDefaultTypeInternal _SemanticVersion_default_instance_;
PROTOBUF_CONSTEXPR Setting::Setting(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SettingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SettingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SettingDefaultTypeInternal() {}
  union {
    Setting _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SettingDefaultTypeInternal _Setting_default_instance_;
PROTOBUF_CONSTEXPR ServicesConfigurationList::ServicesConfigurationList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.namevalue_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ServicesConfigurationListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServicesConfigurationListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServicesConfigurationListDefaultTypeInternal() {}
  union {
    ServicesConfigurationList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServicesConfigurationListDefaultTypeInternal _ServicesConfigurationList_default_instance_;
PROTOBUF_CONSTEXPR TokenRelationship::TokenRelationship(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.symbol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tokenid_)*/nullptr
  , /*decltype(_impl_.balance_)*/uint64_t{0u}
  , /*decltype(_impl_.kycstatus_)*/0
  , /*decltype(_impl_.freezestatus_)*/0
  , /*decltype(_impl_.decimals_)*/0u
  , /*decltype(_impl_.automatic_association_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TokenRelationshipDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TokenRelationshipDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TokenRelationshipDefaultTypeInternal() {}
  union {
    TokenRelationship _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TokenRelationshipDefaultTypeInternal _TokenRelationship_default_instance_;
PROTOBUF_CONSTEXPR TokenBalance::TokenBalance(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tokenid_)*/nullptr
  , /*decltype(_impl_.balance_)*/uint64_t{0u}
  , /*decltype(_impl_.decimals_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TokenBalanceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TokenBalanceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TokenBalanceDefaultTypeInternal() {}
  union {
    TokenBalance _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TokenBalanceDefaultTypeInternal _TokenBalance_default_instance_;
PROTOBUF_CONSTEXPR TokenBalances::TokenBalances(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tokenbalances_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TokenBalancesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TokenBalancesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TokenBalancesDefaultTypeInternal() {}
  union {
    TokenBalances _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TokenBalancesDefaultTypeInternal _TokenBalances_default_instance_;
PROTOBUF_CONSTEXPR TokenAssociation::TokenAssociation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.token_id_)*/nullptr
  , /*decltype(_impl_.account_id_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TokenAssociationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TokenAssociationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TokenAssociationDefaultTypeInternal() {}
  union {
    TokenAssociation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TokenAssociationDefaultTypeInternal _TokenAssociation_default_instance_;
PROTOBUF_CONSTEXPR StakingInfo::StakingInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stake_period_start_)*/nullptr
  , /*decltype(_impl_.pending_reward_)*/int64_t{0}
  , /*decltype(_impl_.staked_to_me_)*/int64_t{0}
  , /*decltype(_impl_.decline_reward_)*/false
  , /*decltype(_impl_.staked_id_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct StakingInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StakingInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StakingInfoDefaultTypeInternal() {}
  union {
    StakingInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StakingInfoDefaultTypeInternal _StakingInfo_default_instance_;
}  // namespace proto
static ::_pb::Metadata file_level_metadata_basic_5ftypes_2eproto[38];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_basic_5ftypes_2eproto[7];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_basic_5ftypes_2eproto = nullptr;

const uint32_t TableStruct_basic_5ftypes_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::ShardID, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::ShardID, _impl_.shardnum_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::RealmID, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::RealmID, _impl_.shardnum_),
  PROTOBUF_FIELD_OFFSET(::proto::RealmID, _impl_.realmnum_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::AccountID, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::proto::AccountID, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::AccountID, _impl_.shardnum_),
  PROTOBUF_FIELD_OFFSET(::proto::AccountID, _impl_.realmnum_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::proto::AccountID, _impl_.account_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::FileID, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::FileID, _impl_.shardnum_),
  PROTOBUF_FIELD_OFFSET(::proto::FileID, _impl_.realmnum_),
  PROTOBUF_FIELD_OFFSET(::proto::FileID, _impl_.filenum_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::ContractID, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::proto::ContractID, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::ContractID, _impl_.shardnum_),
  PROTOBUF_FIELD_OFFSET(::proto::ContractID, _impl_.realmnum_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::proto::ContractID, _impl_.contract_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::TransactionID, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::TransactionID, _impl_.transactionvalidstart_),
  PROTOBUF_FIELD_OFFSET(::proto::TransactionID, _impl_.accountid_),
  PROTOBUF_FIELD_OFFSET(::proto::TransactionID, _impl_.scheduled_),
  PROTOBUF_FIELD_OFFSET(::proto::TransactionID, _impl_.nonce_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::AccountAmount, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::AccountAmount, _impl_.accountid_),
  PROTOBUF_FIELD_OFFSET(::proto::AccountAmount, _impl_.amount_),
  PROTOBUF_FIELD_OFFSET(::proto::AccountAmount, _impl_.is_approval_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::TransferList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::TransferList, _impl_.accountamounts_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::NftTransfer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::NftTransfer, _impl_.senderaccountid_),
  PROTOBUF_FIELD_OFFSET(::proto::NftTransfer, _impl_.receiveraccountid_),
  PROTOBUF_FIELD_OFFSET(::proto::NftTransfer, _impl_.serialnumber_),
  PROTOBUF_FIELD_OFFSET(::proto::NftTransfer, _impl_.is_approval_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::TokenTransferList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::TokenTransferList, _impl_.token_),
  PROTOBUF_FIELD_OFFSET(::proto::TokenTransferList, _impl_.transfers_),
  PROTOBUF_FIELD_OFFSET(::proto::TokenTransferList, _impl_.nfttransfers_),
  PROTOBUF_FIELD_OFFSET(::proto::TokenTransferList, _impl_.expected_decimals_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::Fraction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::Fraction, _impl_.numerator_),
  PROTOBUF_FIELD_OFFSET(::proto::Fraction, _impl_.denominator_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::TopicID, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::TopicID, _impl_.shardnum_),
  PROTOBUF_FIELD_OFFSET(::proto::TopicID, _impl_.realmnum_),
  PROTOBUF_FIELD_OFFSET(::proto::TopicID, _impl_.topicnum_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::TokenID, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::TokenID, _impl_.shardnum_),
  PROTOBUF_FIELD_OFFSET(::proto::TokenID, _impl_.realmnum_),
  PROTOBUF_FIELD_OFFSET(::proto::TokenID, _impl_.tokennum_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::ScheduleID, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::ScheduleID, _impl_.shardnum_),
  PROTOBUF_FIELD_OFFSET(::proto::ScheduleID, _impl_.realmnum_),
  PROTOBUF_FIELD_OFFSET(::proto::ScheduleID, _impl_.schedulenum_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::Key, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::proto::Key, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::proto::Key, _impl_.key_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::ThresholdKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::ThresholdKey, _impl_.threshold_),
  PROTOBUF_FIELD_OFFSET(::proto::ThresholdKey, _impl_.keys_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::KeyList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::KeyList, _impl_.keys_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::Signature, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::proto::Signature, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::proto::Signature, _impl_.signature_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::ThresholdSignature, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::ThresholdSignature, _impl_.sigs_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::SignatureList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::SignatureList, _impl_.sigs_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::SignaturePair, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::proto::SignaturePair, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::SignaturePair, _impl_.pubkeyprefix_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::proto::SignaturePair, _impl_.signature_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::SignatureMap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::SignatureMap, _impl_.sigpair_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::FeeComponents, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::FeeComponents, _impl_.min_),
  PROTOBUF_FIELD_OFFSET(::proto::FeeComponents, _impl_.max_),
  PROTOBUF_FIELD_OFFSET(::proto::FeeComponents, _impl_.constant_),
  PROTOBUF_FIELD_OFFSET(::proto::FeeComponents, _impl_.bpt_),
  PROTOBUF_FIELD_OFFSET(::proto::FeeComponents, _impl_.vpt_),
  PROTOBUF_FIELD_OFFSET(::proto::FeeComponents, _impl_.rbh_),
  PROTOBUF_FIELD_OFFSET(::proto::FeeComponents, _impl_.sbh_),
  PROTOBUF_FIELD_OFFSET(::proto::FeeComponents, _impl_.gas_),
  PROTOBUF_FIELD_OFFSET(::proto::FeeComponents, _impl_.tv_),
  PROTOBUF_FIELD_OFFSET(::proto::FeeComponents, _impl_.bpr_),
  PROTOBUF_FIELD_OFFSET(::proto::FeeComponents, _impl_.sbpr_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::TransactionFeeSchedule, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::TransactionFeeSchedule, _impl_.hederafunctionality_),
  PROTOBUF_FIELD_OFFSET(::proto::TransactionFeeSchedule, _impl_.feedata_),
  PROTOBUF_FIELD_OFFSET(::proto::TransactionFeeSchedule, _impl_.fees_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::FeeData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::FeeData, _impl_.nodedata_),
  PROTOBUF_FIELD_OFFSET(::proto::FeeData, _impl_.networkdata_),
  PROTOBUF_FIELD_OFFSET(::proto::FeeData, _impl_.servicedata_),
  PROTOBUF_FIELD_OFFSET(::proto::FeeData, _impl_.subtype_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::FeeSchedule, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::FeeSchedule, _impl_.transactionfeeschedule_),
  PROTOBUF_FIELD_OFFSET(::proto::FeeSchedule, _impl_.expirytime_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::CurrentAndNextFeeSchedule, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::CurrentAndNextFeeSchedule, _impl_.currentfeeschedule_),
  PROTOBUF_FIELD_OFFSET(::proto::CurrentAndNextFeeSchedule, _impl_.nextfeeschedule_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::ServiceEndpoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::ServiceEndpoint, _impl_.ipaddressv4_),
  PROTOBUF_FIELD_OFFSET(::proto::ServiceEndpoint, _impl_.port_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::NodeAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::NodeAddress, _impl_.ipaddress_),
  PROTOBUF_FIELD_OFFSET(::proto::NodeAddress, _impl_.portno_),
  PROTOBUF_FIELD_OFFSET(::proto::NodeAddress, _impl_.memo_),
  PROTOBUF_FIELD_OFFSET(::proto::NodeAddress, _impl_.rsa_pubkey_),
  PROTOBUF_FIELD_OFFSET(::proto::NodeAddress, _impl_.nodeid_),
  PROTOBUF_FIELD_OFFSET(::proto::NodeAddress, _impl_.nodeaccountid_),
  PROTOBUF_FIELD_OFFSET(::proto::NodeAddress, _impl_.nodecerthash_),
  PROTOBUF_FIELD_OFFSET(::proto::NodeAddress, _impl_.serviceendpoint_),
  PROTOBUF_FIELD_OFFSET(::proto::NodeAddress, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::proto::NodeAddress, _impl_.stake_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::NodeAddressBook, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::NodeAddressBook, _impl_.nodeaddress_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::SemanticVersion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::SemanticVersion, _impl_.major_),
  PROTOBUF_FIELD_OFFSET(::proto::SemanticVersion, _impl_.minor_),
  PROTOBUF_FIELD_OFFSET(::proto::SemanticVersion, _impl_.patch_),
  PROTOBUF_FIELD_OFFSET(::proto::SemanticVersion, _impl_.pre_),
  PROTOBUF_FIELD_OFFSET(::proto::SemanticVersion, _impl_.build_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::Setting, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::Setting, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::proto::Setting, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::proto::Setting, _impl_.data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::ServicesConfigurationList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::ServicesConfigurationList, _impl_.namevalue_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::TokenRelationship, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::TokenRelationship, _impl_.tokenid_),
  PROTOBUF_FIELD_OFFSET(::proto::TokenRelationship, _impl_.symbol_),
  PROTOBUF_FIELD_OFFSET(::proto::TokenRelationship, _impl_.balance_),
  PROTOBUF_FIELD_OFFSET(::proto::TokenRelationship, _impl_.kycstatus_),
  PROTOBUF_FIELD_OFFSET(::proto::TokenRelationship, _impl_.freezestatus_),
  PROTOBUF_FIELD_OFFSET(::proto::TokenRelationship, _impl_.decimals_),
  PROTOBUF_FIELD_OFFSET(::proto::TokenRelationship, _impl_.automatic_association_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::TokenBalance, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::TokenBalance, _impl_.tokenid_),
  PROTOBUF_FIELD_OFFSET(::proto::TokenBalance, _impl_.balance_),
  PROTOBUF_FIELD_OFFSET(::proto::TokenBalance, _impl_.decimals_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::TokenBalances, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::TokenBalances, _impl_.tokenbalances_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::TokenAssociation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::TokenAssociation, _impl_.token_id_),
  PROTOBUF_FIELD_OFFSET(::proto::TokenAssociation, _impl_.account_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto::StakingInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::proto::StakingInfo, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto::StakingInfo, _impl_.decline_reward_),
  PROTOBUF_FIELD_OFFSET(::proto::StakingInfo, _impl_.stake_period_start_),
  PROTOBUF_FIELD_OFFSET(::proto::StakingInfo, _impl_.pending_reward_),
  PROTOBUF_FIELD_OFFSET(::proto::StakingInfo, _impl_.staked_to_me_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::proto::StakingInfo, _impl_.staked_id_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::proto::ShardID)},
  { 7, -1, -1, sizeof(::proto::RealmID)},
  { 15, -1, -1, sizeof(::proto::AccountID)},
  { 26, -1, -1, sizeof(::proto::FileID)},
  { 35, -1, -1, sizeof(::proto::ContractID)},
  { 46, -1, -1, sizeof(::proto::TransactionID)},
  { 56, -1, -1, sizeof(::proto::AccountAmount)},
  { 65, -1, -1, sizeof(::proto::TransferList)},
  { 72, -1, -1, sizeof(::proto::NftTransfer)},
  { 82, -1, -1, sizeof(::proto::TokenTransferList)},
  { 92, -1, -1, sizeof(::proto::Fraction)},
  { 100, -1, -1, sizeof(::proto::TopicID)},
  { 109, -1, -1, sizeof(::proto::TokenID)},
  { 118, -1, -1, sizeof(::proto::ScheduleID)},
  { 127, -1, -1, sizeof(::proto::Key)},
  { 142, -1, -1, sizeof(::proto::ThresholdKey)},
  { 150, -1, -1, sizeof(::proto::KeyList)},
  { 157, -1, -1, sizeof(::proto::Signature)},
  { 170, -1, -1, sizeof(::proto::ThresholdSignature)},
  { 177, -1, -1, sizeof(::proto::SignatureList)},
  { 184, -1, -1, sizeof(::proto::SignaturePair)},
  { 197, -1, -1, sizeof(::proto::SignatureMap)},
  { 204, -1, -1, sizeof(::proto::FeeComponents)},
  { 221, -1, -1, sizeof(::proto::TransactionFeeSchedule)},
  { 230, -1, -1, sizeof(::proto::FeeData)},
  { 240, -1, -1, sizeof(::proto::FeeSchedule)},
  { 248, -1, -1, sizeof(::proto::CurrentAndNextFeeSchedule)},
  { 256, -1, -1, sizeof(::proto::ServiceEndpoint)},
  { 264, -1, -1, sizeof(::proto::NodeAddress)},
  { 280, -1, -1, sizeof(::proto::NodeAddressBook)},
  { 287, -1, -1, sizeof(::proto::SemanticVersion)},
  { 298, -1, -1, sizeof(::proto::Setting)},
  { 307, -1, -1, sizeof(::proto::ServicesConfigurationList)},
  { 314, -1, -1, sizeof(::proto::TokenRelationship)},
  { 327, -1, -1, sizeof(::proto::TokenBalance)},
  { 336, -1, -1, sizeof(::proto::TokenBalances)},
  { 343, -1, -1, sizeof(::proto::TokenAssociation)},
  { 351, -1, -1, sizeof(::proto::StakingInfo)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::proto::_ShardID_default_instance_._instance,
  &::proto::_RealmID_default_instance_._instance,
  &::proto::_AccountID_default_instance_._instance,
  &::proto::_FileID_default_instance_._instance,
  &::proto::_ContractID_default_instance_._instance,
  &::proto::_TransactionID_default_instance_._instance,
  &::proto::_AccountAmount_default_instance_._instance,
  &::proto::_TransferList_default_instance_._instance,
  &::proto::_NftTransfer_default_instance_._instance,
  &::proto::_TokenTransferList_default_instance_._instance,
  &::proto::_Fraction_default_instance_._instance,
  &::proto::_TopicID_default_instance_._instance,
  &::proto::_TokenID_default_instance_._instance,
  &::proto::_ScheduleID_default_instance_._instance,
  &::proto::_Key_default_instance_._instance,
  &::proto::_ThresholdKey_default_instance_._instance,
  &::proto::_KeyList_default_instance_._instance,
  &::proto::_Signature_default_instance_._instance,
  &::proto::_ThresholdSignature_default_instance_._instance,
  &::proto::_SignatureList_default_instance_._instance,
  &::proto::_SignaturePair_default_instance_._instance,
  &::proto::_SignatureMap_default_instance_._instance,
  &::proto::_FeeComponents_default_instance_._instance,
  &::proto::_TransactionFeeSchedule_default_instance_._instance,
  &::proto::_FeeData_default_instance_._instance,
  &::proto::_FeeSchedule_default_instance_._instance,
  &::proto::_CurrentAndNextFeeSchedule_default_instance_._instance,
  &::proto::_ServiceEndpoint_default_instance_._instance,
  &::proto::_NodeAddress_default_instance_._instance,
  &::proto::_NodeAddressBook_default_instance_._instance,
  &::proto::_SemanticVersion_default_instance_._instance,
  &::proto::_Setting_default_instance_._instance,
  &::proto::_ServicesConfigurationList_default_instance_._instance,
  &::proto::_TokenRelationship_default_instance_._instance,
  &::proto::_TokenBalance_default_instance_._instance,
  &::proto::_TokenBalances_default_instance_._instance,
  &::proto::_TokenAssociation_default_instance_._instance,
  &::proto::_StakingInfo_default_instance_._instance,
};

const char descriptor_table_protodef_basic_5ftypes_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\021basic_types.proto\022\005proto\032\017timestamp.pr"
  "oto\032\036google/protobuf/wrappers.proto\"\033\n\007S"
  "hardID\022\020\n\010shardNum\030\001 \001(\003\"-\n\007RealmID\022\020\n\010s"
  "hardNum\030\001 \001(\003\022\020\n\010realmNum\030\002 \001(\003\"a\n\tAccou"
  "ntID\022\020\n\010shardNum\030\001 \001(\003\022\020\n\010realmNum\030\002 \001(\003"
  "\022\024\n\naccountNum\030\003 \001(\003H\000\022\017\n\005alias\030\004 \001(\014H\000B"
  "\t\n\007account\"=\n\006FileID\022\020\n\010shardNum\030\001 \001(\003\022\020"
  "\n\010realmNum\030\002 \001(\003\022\017\n\007fileNum\030\003 \001(\003\"j\n\nCon"
  "tractID\022\020\n\010shardNum\030\001 \001(\003\022\020\n\010realmNum\030\002 "
  "\001(\003\022\025\n\013contractNum\030\003 \001(\003H\000\022\025\n\013evm_addres"
  "s\030\004 \001(\014H\000B\n\n\010contract\"\207\001\n\rTransactionID\022"
  "/\n\025transactionValidStart\030\001 \001(\0132\020.proto.T"
  "imestamp\022#\n\taccountID\030\002 \001(\0132\020.proto.Acco"
  "untID\022\021\n\tscheduled\030\003 \001(\010\022\r\n\005nonce\030\004 \001(\005\""
  "Y\n\rAccountAmount\022#\n\taccountID\030\001 \001(\0132\020.pr"
  "oto.AccountID\022\016\n\006amount\030\002 \001(\022\022\023\n\013is_appr"
  "oval\030\003 \001(\010\"<\n\014TransferList\022,\n\016accountAmo"
  "unts\030\001 \003(\0132\024.proto.AccountAmount\"\220\001\n\013Nft"
  "Transfer\022)\n\017senderAccountID\030\001 \001(\0132\020.prot"
  "o.AccountID\022+\n\021receiverAccountID\030\002 \001(\0132\020"
  ".proto.AccountID\022\024\n\014serialNumber\030\003 \001(\003\022\023"
  "\n\013is_approval\030\004 \001(\010\"\276\001\n\021TokenTransferLis"
  "t\022\035\n\005token\030\001 \001(\0132\016.proto.TokenID\022\'\n\ttran"
  "sfers\030\002 \003(\0132\024.proto.AccountAmount\022(\n\014nft"
  "Transfers\030\003 \003(\0132\022.proto.NftTransfer\0227\n\021e"
  "xpected_decimals\030\004 \001(\0132\034.google.protobuf"
  ".UInt32Value\"2\n\010Fraction\022\021\n\tnumerator\030\001 "
  "\001(\003\022\023\n\013denominator\030\002 \001(\003\"\?\n\007TopicID\022\020\n\010s"
  "hardNum\030\001 \001(\003\022\020\n\010realmNum\030\002 \001(\003\022\020\n\010topic"
  "Num\030\003 \001(\003\"\?\n\007TokenID\022\020\n\010shardNum\030\001 \001(\003\022\020"
  "\n\010realmNum\030\002 \001(\003\022\020\n\010tokenNum\030\003 \001(\003\"E\n\nSc"
  "heduleID\022\020\n\010shardNum\030\001 \001(\003\022\020\n\010realmNum\030\002"
  " \001(\003\022\023\n\013scheduleNum\030\003 \001(\003\"\222\002\n\003Key\022\'\n\ncon"
  "tractID\030\001 \001(\0132\021.proto.ContractIDH\000\022\021\n\007ed"
  "25519\030\002 \001(\014H\000\022\022\n\010RSA_3072\030\003 \001(\014H\000\022\023\n\tECD"
  "SA_384\030\004 \001(\014H\000\022+\n\014thresholdKey\030\005 \001(\0132\023.p"
  "roto.ThresholdKeyH\000\022!\n\007keyList\030\006 \001(\0132\016.p"
  "roto.KeyListH\000\022\031\n\017ECDSA_secp256k1\030\007 \001(\014H"
  "\000\0224\n\027delegatable_contract_id\030\010 \001(\0132\021.pro"
  "to.ContractIDH\000B\005\n\003key\"\?\n\014ThresholdKey\022\021"
  "\n\tthreshold\030\001 \001(\r\022\034\n\004keys\030\002 \001(\0132\016.proto."
  "KeyList\"#\n\007KeyList\022\030\n\004keys\030\001 \003(\0132\n.proto"
  ".Key\"\324\001\n\tSignature\022\022\n\010contract\030\001 \001(\014H\000\022\021"
  "\n\007ed25519\030\002 \001(\014H\000\022\022\n\010RSA_3072\030\003 \001(\014H\000\022\023\n"
  "\tECDSA_384\030\004 \001(\014H\000\0227\n\022thresholdSignature"
  "\030\005 \001(\0132\031.proto.ThresholdSignatureH\000\022-\n\rs"
  "ignatureList\030\006 \001(\0132\024.proto.SignatureList"
  "H\000:\002\030\001B\013\n\tsignature\"<\n\022ThresholdSignatur"
  "e\022\"\n\004sigs\030\002 \001(\0132\024.proto.SignatureList:\002\030"
  "\001\"3\n\rSignatureList\022\036\n\004sigs\030\002 \003(\0132\020.proto"
  ".Signature:\002\030\001\"\235\001\n\rSignaturePair\022\024\n\014pubK"
  "eyPrefix\030\001 \001(\014\022\022\n\010contract\030\002 \001(\014H\000\022\021\n\007ed"
  "25519\030\003 \001(\014H\000\022\022\n\010RSA_3072\030\004 \001(\014H\000\022\023\n\tECD"
  "SA_384\030\005 \001(\014H\000\022\031\n\017ECDSA_secp256k1\030\006 \001(\014H"
  "\000B\013\n\tsignature\"5\n\014SignatureMap\022%\n\007sigPai"
  "r\030\001 \003(\0132\024.proto.SignaturePair\"\243\001\n\rFeeCom"
  "ponents\022\013\n\003min\030\001 \001(\003\022\013\n\003max\030\002 \001(\003\022\020\n\010con"
  "stant\030\003 \001(\003\022\013\n\003bpt\030\004 \001(\003\022\013\n\003vpt\030\005 \001(\003\022\013\n"
  "\003rbh\030\006 \001(\003\022\013\n\003sbh\030\007 \001(\003\022\013\n\003gas\030\010 \001(\003\022\n\n\002"
  "tv\030\t \001(\003\022\013\n\003bpr\030\n \001(\003\022\014\n\004sbpr\030\013 \001(\003\"\224\001\n\026"
  "TransactionFeeSchedule\0227\n\023hederaFunction"
  "ality\030\001 \001(\0162\032.proto.HederaFunctionality\022"
  "#\n\007feeData\030\002 \001(\0132\016.proto.FeeDataB\002\030\001\022\034\n\004"
  "fees\030\003 \003(\0132\016.proto.FeeData\"\250\001\n\007FeeData\022&"
  "\n\010nodedata\030\001 \001(\0132\024.proto.FeeComponents\022)"
  "\n\013networkdata\030\002 \001(\0132\024.proto.FeeComponent"
  "s\022)\n\013servicedata\030\003 \001(\0132\024.proto.FeeCompon"
  "ents\022\037\n\007subType\030\004 \001(\0162\016.proto.SubType\"y\n"
  "\013FeeSchedule\022=\n\026transactionFeeSchedule\030\001"
  " \003(\0132\035.proto.TransactionFeeSchedule\022+\n\ne"
  "xpiryTime\030\002 \001(\0132\027.proto.TimestampSeconds"
  "\"x\n\031CurrentAndNextFeeSchedule\022.\n\022current"
  "FeeSchedule\030\001 \001(\0132\022.proto.FeeSchedule\022+\n"
  "\017nextFeeSchedule\030\002 \001(\0132\022.proto.FeeSchedu"
  "le\"4\n\017ServiceEndpoint\022\023\n\013ipAddressV4\030\001 \001"
  "(\014\022\014\n\004port\030\002 \001(\005\"\206\002\n\013NodeAddress\022\025\n\tipAd"
  "dress\030\001 \001(\014B\002\030\001\022\022\n\006portno\030\002 \001(\005B\002\030\001\022\020\n\004m"
  "emo\030\003 \001(\014B\002\030\001\022\022\n\nRSA_PubKey\030\004 \001(\t\022\016\n\006nod"
  "eId\030\005 \001(\003\022\'\n\rnodeAccountId\030\006 \001(\0132\020.proto"
  ".AccountID\022\024\n\014nodeCertHash\030\007 \001(\014\022/\n\017serv"
  "iceEndpoint\030\010 \003(\0132\026.proto.ServiceEndpoin"
  "t\022\023\n\013description\030\t \001(\t\022\021\n\005stake\030\n \001(\003B\002\030"
  "\001\":\n\017NodeAddressBook\022\'\n\013nodeAddress\030\001 \003("
  "\0132\022.proto.NodeAddress\"Z\n\017SemanticVersion"
  "\022\r\n\005major\030\001 \001(\005\022\r\n\005minor\030\002 \001(\005\022\r\n\005patch\030"
  "\003 \001(\005\022\013\n\003pre\030\004 \001(\t\022\r\n\005build\030\005 \001(\t\"4\n\007Set"
  "ting\022\014\n\004name\030\001 \001(\t\022\r\n\005value\030\002 \001(\t\022\014\n\004dat"
  "a\030\003 \001(\014\">\n\031ServicesConfigurationList\022!\n\t"
  "nameValue\030\001 \003(\0132\016.proto.Setting\"\340\001\n\021Toke"
  "nRelationship\022\037\n\007tokenId\030\001 \001(\0132\016.proto.T"
  "okenID\022\016\n\006symbol\030\002 \001(\t\022\017\n\007balance\030\003 \001(\004\022"
  "(\n\tkycStatus\030\004 \001(\0162\025.proto.TokenKycStatu"
  "s\022.\n\014freezeStatus\030\005 \001(\0162\030.proto.TokenFre"
  "ezeStatus\022\020\n\010decimals\030\006 \001(\r\022\035\n\025automatic"
  "_association\030\007 \001(\010\"R\n\014TokenBalance\022\037\n\007to"
  "kenId\030\001 \001(\0132\016.proto.TokenID\022\017\n\007balance\030\002"
  " \001(\004\022\020\n\010decimals\030\003 \001(\r\";\n\rTokenBalances\022"
  "*\n\rtokenBalances\030\001 \003(\0132\023.proto.TokenBala"
  "nce\"Z\n\020TokenAssociation\022 \n\010token_id\030\001 \001("
  "\0132\016.proto.TokenID\022$\n\naccount_id\030\002 \001(\0132\020."
  "proto.AccountID\"\327\001\n\013StakingInfo\022\026\n\016decli"
  "ne_reward\030\001 \001(\010\022,\n\022stake_period_start\030\002 "
  "\001(\0132\020.proto.Timestamp\022\026\n\016pending_reward\030"
  "\003 \001(\003\022\024\n\014staked_to_me\030\004 \001(\003\022-\n\021staked_ac"
  "count_id\030\005 \001(\0132\020.proto.AccountIDH\000\022\030\n\016st"
  "aked_node_id\030\006 \001(\003H\000B\013\n\tstaked_id*9\n\tTok"
  "enType\022\023\n\017FUNGIBLE_COMMON\020\000\022\027\n\023NON_FUNGI"
  "BLE_UNIQUE\020\001*\317\001\n\007SubType\022\013\n\007DEFAULT\020\000\022\031\n"
  "\025TOKEN_FUNGIBLE_COMMON\020\001\022\035\n\031TOKEN_NON_FU"
  "NGIBLE_UNIQUE\020\002\022*\n&TOKEN_FUNGIBLE_COMMON"
  "_WITH_CUSTOM_FEES\020\003\022.\n*TOKEN_NON_FUNGIBL"
  "E_UNIQUE_WITH_CUSTOM_FEES\020\004\022!\n\035SCHEDULE_"
  "CREATE_CONTRACT_CALL\020\005*+\n\017TokenSupplyTyp"
  "e\022\014\n\010INFINITE\020\000\022\n\n\006FINITE\020\001*F\n\021TokenFree"
  "zeStatus\022\027\n\023FreezeNotApplicable\020\000\022\n\n\006Fro"
  "zen\020\001\022\014\n\010Unfrozen\020\002*@\n\016TokenKycStatus\022\024\n"
  "\020KycNotApplicable\020\000\022\013\n\007Granted\020\001\022\013\n\007Revo"
  "ked\020\002*D\n\020TokenPauseStatus\022\026\n\022PauseNotApp"
  "licable\020\000\022\n\n\006Paused\020\001\022\014\n\010Unpaused\020\002*\314\014\n\023"
  "HederaFunctionality\022\010\n\004NONE\020\000\022\022\n\016CryptoT"
  "ransfer\020\001\022\020\n\014CryptoUpdate\020\002\022\020\n\014CryptoDel"
  "ete\020\003\022\025\n\021CryptoAddLiveHash\020\004\022\030\n\024CryptoDe"
  "leteLiveHash\020\005\022\020\n\014ContractCall\020\006\022\022\n\016Cont"
  "ractCreate\020\007\022\022\n\016ContractUpdate\020\010\022\016\n\nFile"
  "Create\020\t\022\016\n\nFileAppend\020\n\022\016\n\nFileUpdate\020\013"
  "\022\016\n\nFileDelete\020\014\022\033\n\027CryptoGetAccountBala"
  "nce\020\r\022\033\n\027CryptoGetAccountRecords\020\016\022\021\n\rCr"
  "yptoGetInfo\020\017\022\025\n\021ContractCallLocal\020\020\022\023\n\017"
  "ContractGetInfo\020\021\022\027\n\023ContractGetBytecode"
  "\020\022\022\023\n\017GetBySolidityID\020\023\022\014\n\010GetByKey\020\024\022\025\n"
  "\021CryptoGetLiveHash\020\025\022\024\n\020CryptoGetStakers"
  "\020\026\022\023\n\017FileGetContents\020\027\022\017\n\013FileGetInfo\020\030"
  "\022\030\n\024TransactionGetRecord\020\031\022\026\n\022ContractGe"
  "tRecords\020\032\022\020\n\014CryptoCreate\020\033\022\020\n\014SystemDe"
  "lete\020\034\022\022\n\016SystemUndelete\020\035\022\022\n\016ContractDe"
  "lete\020\036\022\n\n\006Freeze\020\037\022\033\n\027CreateTransactionR"
  "ecord\020 \022\032\n\026CryptoAccountAutoRenew\020!\022\025\n\021C"
  "ontractAutoRenew\020\"\022\022\n\016GetVersionInfo\020#\022\031"
  "\n\025TransactionGetReceipt\020$\022\030\n\024ConsensusCr"
  "eateTopic\0202\022\030\n\024ConsensusUpdateTopic\0203\022\030\n"
  "\024ConsensusDeleteTopic\0204\022\031\n\025ConsensusGetT"
  "opicInfo\0205\022\032\n\026ConsensusSubmitMessage\0206\022\023"
  "\n\017UncheckedSubmit\0207\022\017\n\013TokenCreate\0208\022\020\n\014"
  "TokenGetInfo\020:\022\026\n\022TokenFreezeAccount\020;\022\030"
  "\n\024TokenUnfreezeAccount\020<\022\032\n\026TokenGrantKy"
  "cToAccount\020=\022\035\n\031TokenRevokeKycFromAccoun"
  "t\020>\022\017\n\013TokenDelete\020\?\022\017\n\013TokenUpdate\020@\022\r\n"
  "\tTokenMint\020A\022\r\n\tTokenBurn\020B\022\024\n\020TokenAcco"
  "untWipe\020C\022\033\n\027TokenAssociateToAccount\020D\022\036"
  "\n\032TokenDissociateFromAccount\020E\022\022\n\016Schedu"
  "leCreate\020F\022\022\n\016ScheduleDelete\020G\022\020\n\014Schedu"
  "leSign\020H\022\023\n\017ScheduleGetInfo\020I\022\033\n\027TokenGe"
  "tAccountNftInfos\020J\022\023\n\017TokenGetNftInfo\020K\022"
  "\024\n\020TokenGetNftInfos\020L\022\032\n\026TokenFeeSchedul"
  "eUpdate\020M\022\033\n\027NetworkGetExecutionTime\020N\022\016"
  "\n\nTokenPause\020O\022\020\n\014TokenUnpause\020P\022\032\n\026Cryp"
  "toApproveAllowance\020Q\022\031\n\025CryptoDeleteAllo"
  "wance\020R\022\025\n\021GetAccountDetails\020S\022\027\n\023Ethere"
  "umTransaction\020T\022\023\n\017NodeStakeUpdate\020U\022\014\n\010"
  "UtilPrng\020VB&\n\"com.hederahashgraph.api.pr"
  "oto.javaP\001b\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_basic_5ftypes_2eproto_deps[2] = {
  &::descriptor_table_google_2fprotobuf_2fwrappers_2eproto,
  &::descriptor_table_timestamp_2eproto,
};
static ::_pbi::once_flag descriptor_table_basic_5ftypes_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_basic_5ftypes_2eproto = {
    false, false, 6418, descriptor_table_protodef_basic_5ftypes_2eproto,
    "basic_types.proto",
    &descriptor_table_basic_5ftypes_2eproto_once, descriptor_table_basic_5ftypes_2eproto_deps, 2, 38,
    schemas, file_default_instances, TableStruct_basic_5ftypes_2eproto::offsets,
    file_level_metadata_basic_5ftypes_2eproto, file_level_enum_descriptors_basic_5ftypes_2eproto,
    file_level_service_descriptors_basic_5ftypes_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_basic_5ftypes_2eproto_getter() {
  return &descriptor_table_basic_5ftypes_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_basic_5ftypes_2eproto(&descriptor_table_basic_5ftypes_2eproto);
namespace proto {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TokenType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_basic_5ftypes_2eproto);
  return file_level_enum_descriptors_basic_5ftypes_2eproto[0];
}
bool TokenType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SubType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_basic_5ftypes_2eproto);
  return file_level_enum_descriptors_basic_5ftypes_2eproto[1];
}
bool SubType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TokenSupplyType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_basic_5ftypes_2eproto);
  return file_level_enum_descriptors_basic_5ftypes_2eproto[2];
}
bool TokenSupplyType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TokenFreezeStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_basic_5ftypes_2eproto);
  return file_level_enum_descriptors_basic_5ftypes_2eproto[3];
}
bool TokenFreezeStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TokenKycStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_basic_5ftypes_2eproto);
  return file_level_enum_descriptors_basic_5ftypes_2eproto[4];
}
bool TokenKycStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TokenPauseStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_basic_5ftypes_2eproto);
  return file_level_enum_descriptors_basic_5ftypes_2eproto[5];
}
bool TokenPauseStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HederaFunctionality_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_basic_5ftypes_2eproto);
  return file_level_enum_descriptors_basic_5ftypes_2eproto[6];
}
bool HederaFunctionality_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class ShardID::_Internal {
 public:
};

ShardID::ShardID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.ShardID)
}
ShardID::ShardID(const ShardID& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShardID* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.shardnum_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.shardnum_ = from._impl_.shardnum_;
  // @@protoc_insertion_point(copy_constructor:proto.ShardID)
}

inline void ShardID::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.shardnum_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ShardID::~ShardID() {
  // @@protoc_insertion_point(destructor:proto.ShardID)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShardID::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ShardID::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShardID::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.ShardID)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.shardnum_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShardID::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 shardNum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.shardnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShardID::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.ShardID)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 shardNum = 1;
  if (this->_internal_shardnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_shardnum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.ShardID)
  return target;
}

size_t ShardID::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.ShardID)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 shardNum = 1;
  if (this->_internal_shardnum() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shardnum());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShardID::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShardID::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShardID::GetClassData() const { return &_class_data_; }


void ShardID::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShardID*>(&to_msg);
  auto& from = static_cast<const ShardID&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.ShardID)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_shardnum() != 0) {
    _this->_internal_set_shardnum(from._internal_shardnum());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShardID::CopyFrom(const ShardID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.ShardID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShardID::IsInitialized() const {
  return true;
}

void ShardID::InternalSwap(ShardID* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.shardnum_, other->_impl_.shardnum_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ShardID::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[0]);
}

// ===================================================================

class RealmID::_Internal {
 public:
};

RealmID::RealmID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.RealmID)
}
RealmID::RealmID(const RealmID& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RealmID* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.shardnum_){}
    , decltype(_impl_.realmnum_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.shardnum_, &from._impl_.shardnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.realmnum_) -
    reinterpret_cast<char*>(&_impl_.shardnum_)) + sizeof(_impl_.realmnum_));
  // @@protoc_insertion_point(copy_constructor:proto.RealmID)
}

inline void RealmID::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.shardnum_){int64_t{0}}
    , decltype(_impl_.realmnum_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RealmID::~RealmID() {
  // @@protoc_insertion_point(destructor:proto.RealmID)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RealmID::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RealmID::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RealmID::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.RealmID)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.shardnum_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.realmnum_) -
      reinterpret_cast<char*>(&_impl_.shardnum_)) + sizeof(_impl_.realmnum_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RealmID::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 shardNum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.shardnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 realmNum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.realmnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RealmID::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.RealmID)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 shardNum = 1;
  if (this->_internal_shardnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_shardnum(), target);
  }

  // int64 realmNum = 2;
  if (this->_internal_realmnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_realmnum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.RealmID)
  return target;
}

size_t RealmID::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.RealmID)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 shardNum = 1;
  if (this->_internal_shardnum() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shardnum());
  }

  // int64 realmNum = 2;
  if (this->_internal_realmnum() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_realmnum());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RealmID::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RealmID::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RealmID::GetClassData() const { return &_class_data_; }


void RealmID::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RealmID*>(&to_msg);
  auto& from = static_cast<const RealmID&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.RealmID)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_shardnum() != 0) {
    _this->_internal_set_shardnum(from._internal_shardnum());
  }
  if (from._internal_realmnum() != 0) {
    _this->_internal_set_realmnum(from._internal_realmnum());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RealmID::CopyFrom(const RealmID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.RealmID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RealmID::IsInitialized() const {
  return true;
}

void RealmID::InternalSwap(RealmID* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RealmID, _impl_.realmnum_)
      + sizeof(RealmID::_impl_.realmnum_)
      - PROTOBUF_FIELD_OFFSET(RealmID, _impl_.shardnum_)>(
          reinterpret_cast<char*>(&_impl_.shardnum_),
          reinterpret_cast<char*>(&other->_impl_.shardnum_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RealmID::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[1]);
}

// ===================================================================

class AccountID::_Internal {
 public:
};

AccountID::AccountID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.AccountID)
}
AccountID::AccountID(const AccountID& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountID* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.shardnum_){}
    , decltype(_impl_.realmnum_){}
    , decltype(_impl_.account_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.shardnum_, &from._impl_.shardnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.realmnum_) -
    reinterpret_cast<char*>(&_impl_.shardnum_)) + sizeof(_impl_.realmnum_));
  clear_has_account();
  switch (from.account_case()) {
    case kAccountNum: {
      _this->_internal_set_accountnum(from._internal_accountnum());
      break;
    }
    case kAlias: {
      _this->_internal_set_alias(from._internal_alias());
      break;
    }
    case ACCOUNT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:proto.AccountID)
}

inline void AccountID::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.shardnum_){int64_t{0}}
    , decltype(_impl_.realmnum_){int64_t{0}}
    , decltype(_impl_.account_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_account();
}

AccountID::~AccountID() {
  // @@protoc_insertion_point(destructor:proto.AccountID)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountID::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_account()) {
    clear_account();
  }
}

void AccountID::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountID::clear_account() {
// @@protoc_insertion_point(one_of_clear_start:proto.AccountID)
  switch (account_case()) {
    case kAccountNum: {
      // No need to clear
      break;
    }
    case kAlias: {
      _impl_.account_.alias_.Destroy();
      break;
    }
    case ACCOUNT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ACCOUNT_NOT_SET;
}


void AccountID::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.AccountID)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.shardnum_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.realmnum_) -
      reinterpret_cast<char*>(&_impl_.shardnum_)) + sizeof(_impl_.realmnum_));
  clear_account();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountID::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 shardNum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.shardnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 realmNum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.realmnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 accountNum = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_accountnum(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes alias = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_alias();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AccountID::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.AccountID)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 shardNum = 1;
  if (this->_internal_shardnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_shardnum(), target);
  }

  // int64 realmNum = 2;
  if (this->_internal_realmnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_realmnum(), target);
  }

  // int64 accountNum = 3;
  if (_internal_has_accountnum()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_accountnum(), target);
  }

  // bytes alias = 4;
  if (_internal_has_alias()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_alias(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.AccountID)
  return target;
}

size_t AccountID::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.AccountID)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 shardNum = 1;
  if (this->_internal_shardnum() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shardnum());
  }

  // int64 realmNum = 2;
  if (this->_internal_realmnum() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_realmnum());
  }

  switch (account_case()) {
    // int64 accountNum = 3;
    case kAccountNum: {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_accountnum());
      break;
    }
    // bytes alias = 4;
    case kAlias: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_alias());
      break;
    }
    case ACCOUNT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountID::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountID::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountID::GetClassData() const { return &_class_data_; }


void AccountID::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountID*>(&to_msg);
  auto& from = static_cast<const AccountID&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.AccountID)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_shardnum() != 0) {
    _this->_internal_set_shardnum(from._internal_shardnum());
  }
  if (from._internal_realmnum() != 0) {
    _this->_internal_set_realmnum(from._internal_realmnum());
  }
  switch (from.account_case()) {
    case kAccountNum: {
      _this->_internal_set_accountnum(from._internal_accountnum());
      break;
    }
    case kAlias: {
      _this->_internal_set_alias(from._internal_alias());
      break;
    }
    case ACCOUNT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountID::CopyFrom(const AccountID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.AccountID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountID::IsInitialized() const {
  return true;
}

void AccountID::InternalSwap(AccountID* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AccountID, _impl_.realmnum_)
      + sizeof(AccountID::_impl_.realmnum_)
      - PROTOBUF_FIELD_OFFSET(AccountID, _impl_.shardnum_)>(
          reinterpret_cast<char*>(&_impl_.shardnum_),
          reinterpret_cast<char*>(&other->_impl_.shardnum_));
  swap(_impl_.account_, other->_impl_.account_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountID::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[2]);
}

// ===================================================================

class FileID::_Internal {
 public:
};

FileID::FileID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.FileID)
}
FileID::FileID(const FileID& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FileID* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.shardnum_){}
    , decltype(_impl_.realmnum_){}
    , decltype(_impl_.filenum_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.shardnum_, &from._impl_.shardnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.filenum_) -
    reinterpret_cast<char*>(&_impl_.shardnum_)) + sizeof(_impl_.filenum_));
  // @@protoc_insertion_point(copy_constructor:proto.FileID)
}

inline void FileID::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.shardnum_){int64_t{0}}
    , decltype(_impl_.realmnum_){int64_t{0}}
    , decltype(_impl_.filenum_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FileID::~FileID() {
  // @@protoc_insertion_point(destructor:proto.FileID)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FileID::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FileID::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FileID::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.FileID)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.shardnum_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.filenum_) -
      reinterpret_cast<char*>(&_impl_.shardnum_)) + sizeof(_impl_.filenum_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FileID::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 shardNum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.shardnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 realmNum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.realmnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 fileNum = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.filenum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FileID::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.FileID)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 shardNum = 1;
  if (this->_internal_shardnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_shardnum(), target);
  }

  // int64 realmNum = 2;
  if (this->_internal_realmnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_realmnum(), target);
  }

  // int64 fileNum = 3;
  if (this->_internal_filenum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_filenum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.FileID)
  return target;
}

size_t FileID::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.FileID)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 shardNum = 1;
  if (this->_internal_shardnum() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shardnum());
  }

  // int64 realmNum = 2;
  if (this->_internal_realmnum() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_realmnum());
  }

  // int64 fileNum = 3;
  if (this->_internal_filenum() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenum());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FileID::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FileID::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FileID::GetClassData() const { return &_class_data_; }


void FileID::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FileID*>(&to_msg);
  auto& from = static_cast<const FileID&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.FileID)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_shardnum() != 0) {
    _this->_internal_set_shardnum(from._internal_shardnum());
  }
  if (from._internal_realmnum() != 0) {
    _this->_internal_set_realmnum(from._internal_realmnum());
  }
  if (from._internal_filenum() != 0) {
    _this->_internal_set_filenum(from._internal_filenum());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FileID::CopyFrom(const FileID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.FileID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileID::IsInitialized() const {
  return true;
}

void FileID::InternalSwap(FileID* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FileID, _impl_.filenum_)
      + sizeof(FileID::_impl_.filenum_)
      - PROTOBUF_FIELD_OFFSET(FileID, _impl_.shardnum_)>(
          reinterpret_cast<char*>(&_impl_.shardnum_),
          reinterpret_cast<char*>(&other->_impl_.shardnum_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FileID::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[3]);
}

// ===================================================================

class ContractID::_Internal {
 public:
};

ContractID::ContractID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.ContractID)
}
ContractID::ContractID(const ContractID& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContractID* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.shardnum_){}
    , decltype(_impl_.realmnum_){}
    , decltype(_impl_.contract_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.shardnum_, &from._impl_.shardnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.realmnum_) -
    reinterpret_cast<char*>(&_impl_.shardnum_)) + sizeof(_impl_.realmnum_));
  clear_has_contract();
  switch (from.contract_case()) {
    case kContractNum: {
      _this->_internal_set_contractnum(from._internal_contractnum());
      break;
    }
    case kEvmAddress: {
      _this->_internal_set_evm_address(from._internal_evm_address());
      break;
    }
    case CONTRACT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:proto.ContractID)
}

inline void ContractID::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.shardnum_){int64_t{0}}
    , decltype(_impl_.realmnum_){int64_t{0}}
    , decltype(_impl_.contract_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_contract();
}

ContractID::~ContractID() {
  // @@protoc_insertion_point(destructor:proto.ContractID)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractID::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_contract()) {
    clear_contract();
  }
}

void ContractID::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContractID::clear_contract() {
// @@protoc_insertion_point(one_of_clear_start:proto.ContractID)
  switch (contract_case()) {
    case kContractNum: {
      // No need to clear
      break;
    }
    case kEvmAddress: {
      _impl_.contract_.evm_address_.Destroy();
      break;
    }
    case CONTRACT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = CONTRACT_NOT_SET;
}


void ContractID::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.ContractID)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.shardnum_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.realmnum_) -
      reinterpret_cast<char*>(&_impl_.shardnum_)) + sizeof(_impl_.realmnum_));
  clear_contract();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractID::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 shardNum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.shardnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 realmNum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.realmnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 contractNum = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_contractnum(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes evm_address = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_evm_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractID::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.ContractID)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 shardNum = 1;
  if (this->_internal_shardnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_shardnum(), target);
  }

  // int64 realmNum = 2;
  if (this->_internal_realmnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_realmnum(), target);
  }

  // int64 contractNum = 3;
  if (_internal_has_contractnum()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_contractnum(), target);
  }

  // bytes evm_address = 4;
  if (_internal_has_evm_address()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_evm_address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.ContractID)
  return target;
}

size_t ContractID::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.ContractID)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 shardNum = 1;
  if (this->_internal_shardnum() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shardnum());
  }

  // int64 realmNum = 2;
  if (this->_internal_realmnum() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_realmnum());
  }

  switch (contract_case()) {
    // int64 contractNum = 3;
    case kContractNum: {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_contractnum());
      break;
    }
    // bytes evm_address = 4;
    case kEvmAddress: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_evm_address());
      break;
    }
    case CONTRACT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractID::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContractID::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractID::GetClassData() const { return &_class_data_; }


void ContractID::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContractID*>(&to_msg);
  auto& from = static_cast<const ContractID&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.ContractID)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_shardnum() != 0) {
    _this->_internal_set_shardnum(from._internal_shardnum());
  }
  if (from._internal_realmnum() != 0) {
    _this->_internal_set_realmnum(from._internal_realmnum());
  }
  switch (from.contract_case()) {
    case kContractNum: {
      _this->_internal_set_contractnum(from._internal_contractnum());
      break;
    }
    case kEvmAddress: {
      _this->_internal_set_evm_address(from._internal_evm_address());
      break;
    }
    case CONTRACT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractID::CopyFrom(const ContractID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.ContractID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractID::IsInitialized() const {
  return true;
}

void ContractID::InternalSwap(ContractID* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContractID, _impl_.realmnum_)
      + sizeof(ContractID::_impl_.realmnum_)
      - PROTOBUF_FIELD_OFFSET(ContractID, _impl_.shardnum_)>(
          reinterpret_cast<char*>(&_impl_.shardnum_),
          reinterpret_cast<char*>(&other->_impl_.shardnum_));
  swap(_impl_.contract_, other->_impl_.contract_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractID::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[4]);
}

// ===================================================================

class TransactionID::_Internal {
 public:
  static const ::proto::Timestamp& transactionvalidstart(const TransactionID* msg);
  static const ::proto::AccountID& accountid(const TransactionID* msg);
};

const ::proto::Timestamp&
TransactionID::_Internal::transactionvalidstart(const TransactionID* msg) {
  return *msg->_impl_.transactionvalidstart_;
}
const ::proto::AccountID&
TransactionID::_Internal::accountid(const TransactionID* msg) {
  return *msg->_impl_.accountid_;
}
void TransactionID::clear_transactionvalidstart() {
  if (GetArenaForAllocation() == nullptr && _impl_.transactionvalidstart_ != nullptr) {
    delete _impl_.transactionvalidstart_;
  }
  _impl_.transactionvalidstart_ = nullptr;
}
TransactionID::TransactionID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.TransactionID)
}
TransactionID::TransactionID(const TransactionID& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TransactionID* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.transactionvalidstart_){nullptr}
    , decltype(_impl_.accountid_){nullptr}
    , decltype(_impl_.scheduled_){}
    , decltype(_impl_.nonce_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_transactionvalidstart()) {
    _this->_impl_.transactionvalidstart_ = new ::proto::Timestamp(*from._impl_.transactionvalidstart_);
  }
  if (from._internal_has_accountid()) {
    _this->_impl_.accountid_ = new ::proto::AccountID(*from._impl_.accountid_);
  }
  ::memcpy(&_impl_.scheduled_, &from._impl_.scheduled_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nonce_) -
    reinterpret_cast<char*>(&_impl_.scheduled_)) + sizeof(_impl_.nonce_));
  // @@protoc_insertion_point(copy_constructor:proto.TransactionID)
}

inline void TransactionID::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.transactionvalidstart_){nullptr}
    , decltype(_impl_.accountid_){nullptr}
    , decltype(_impl_.scheduled_){false}
    , decltype(_impl_.nonce_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TransactionID::~TransactionID() {
  // @@protoc_insertion_point(destructor:proto.TransactionID)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TransactionID::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.transactionvalidstart_;
  if (this != internal_default_instance()) delete _impl_.accountid_;
}

void TransactionID::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TransactionID::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.TransactionID)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.transactionvalidstart_ != nullptr) {
    delete _impl_.transactionvalidstart_;
  }
  _impl_.transactionvalidstart_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.accountid_ != nullptr) {
    delete _impl_.accountid_;
  }
  _impl_.accountid_ = nullptr;
  ::memset(&_impl_.scheduled_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.nonce_) -
      reinterpret_cast<char*>(&_impl_.scheduled_)) + sizeof(_impl_.nonce_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TransactionID::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.Timestamp transactionValidStart = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_transactionvalidstart(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.AccountID accountID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_accountid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool scheduled = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.scheduled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 nonce = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.nonce_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TransactionID::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.TransactionID)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.Timestamp transactionValidStart = 1;
  if (this->_internal_has_transactionvalidstart()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::transactionvalidstart(this),
        _Internal::transactionvalidstart(this).GetCachedSize(), target, stream);
  }

  // .proto.AccountID accountID = 2;
  if (this->_internal_has_accountid()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::accountid(this),
        _Internal::accountid(this).GetCachedSize(), target, stream);
  }

  // bool scheduled = 3;
  if (this->_internal_scheduled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_scheduled(), target);
  }

  // int32 nonce = 4;
  if (this->_internal_nonce() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_nonce(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.TransactionID)
  return target;
}

size_t TransactionID::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.TransactionID)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.Timestamp transactionValidStart = 1;
  if (this->_internal_has_transactionvalidstart()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.transactionvalidstart_);
  }

  // .proto.AccountID accountID = 2;
  if (this->_internal_has_accountid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.accountid_);
  }

  // bool scheduled = 3;
  if (this->_internal_scheduled() != 0) {
    total_size += 1 + 1;
  }

  // int32 nonce = 4;
  if (this->_internal_nonce() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nonce());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TransactionID::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TransactionID::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TransactionID::GetClassData() const { return &_class_data_; }


void TransactionID::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TransactionID*>(&to_msg);
  auto& from = static_cast<const TransactionID&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.TransactionID)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_transactionvalidstart()) {
    _this->_internal_mutable_transactionvalidstart()->::proto::Timestamp::MergeFrom(
        from._internal_transactionvalidstart());
  }
  if (from._internal_has_accountid()) {
    _this->_internal_mutable_accountid()->::proto::AccountID::MergeFrom(
        from._internal_accountid());
  }
  if (from._internal_scheduled() != 0) {
    _this->_internal_set_scheduled(from._internal_scheduled());
  }
  if (from._internal_nonce() != 0) {
    _this->_internal_set_nonce(from._internal_nonce());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TransactionID::CopyFrom(const TransactionID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.TransactionID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionID::IsInitialized() const {
  return true;
}

void TransactionID::InternalSwap(TransactionID* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TransactionID, _impl_.nonce_)
      + sizeof(TransactionID::_impl_.nonce_)
      - PROTOBUF_FIELD_OFFSET(TransactionID, _impl_.transactionvalidstart_)>(
          reinterpret_cast<char*>(&_impl_.transactionvalidstart_),
          reinterpret_cast<char*>(&other->_impl_.transactionvalidstart_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TransactionID::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[5]);
}

// ===================================================================

class AccountAmount::_Internal {
 public:
  static const ::proto::AccountID& accountid(const AccountAmount* msg);
};

const ::proto::AccountID&
AccountAmount::_Internal::accountid(const AccountAmount* msg) {
  return *msg->_impl_.accountid_;
}
AccountAmount::AccountAmount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.AccountAmount)
}
AccountAmount::AccountAmount(const AccountAmount& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountAmount* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.accountid_){nullptr}
    , decltype(_impl_.amount_){}
    , decltype(_impl_.is_approval_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_accountid()) {
    _this->_impl_.accountid_ = new ::proto::AccountID(*from._impl_.accountid_);
  }
  ::memcpy(&_impl_.amount_, &from._impl_.amount_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_approval_) -
    reinterpret_cast<char*>(&_impl_.amount_)) + sizeof(_impl_.is_approval_));
  // @@protoc_insertion_point(copy_constructor:proto.AccountAmount)
}

inline void AccountAmount::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.accountid_){nullptr}
    , decltype(_impl_.amount_){int64_t{0}}
    , decltype(_impl_.is_approval_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AccountAmount::~AccountAmount() {
  // @@protoc_insertion_point(destructor:proto.AccountAmount)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountAmount::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.accountid_;
}

void AccountAmount::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountAmount::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.AccountAmount)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.accountid_ != nullptr) {
    delete _impl_.accountid_;
  }
  _impl_.accountid_ = nullptr;
  ::memset(&_impl_.amount_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_approval_) -
      reinterpret_cast<char*>(&_impl_.amount_)) + sizeof(_impl_.is_approval_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountAmount::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.AccountID accountID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_accountid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // sint64 amount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_approval = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.is_approval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AccountAmount::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.AccountAmount)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.AccountID accountID = 1;
  if (this->_internal_has_accountid()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::accountid(this),
        _Internal::accountid(this).GetCachedSize(), target, stream);
  }

  // sint64 amount = 2;
  if (this->_internal_amount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(2, this->_internal_amount(), target);
  }

  // bool is_approval = 3;
  if (this->_internal_is_approval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_approval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.AccountAmount)
  return target;
}

size_t AccountAmount::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.AccountAmount)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.AccountID accountID = 1;
  if (this->_internal_has_accountid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.accountid_);
  }

  // sint64 amount = 2;
  if (this->_internal_amount() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(this->_internal_amount());
  }

  // bool is_approval = 3;
  if (this->_internal_is_approval() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountAmount::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountAmount::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountAmount::GetClassData() const { return &_class_data_; }


void AccountAmount::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountAmount*>(&to_msg);
  auto& from = static_cast<const AccountAmount&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.AccountAmount)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_accountid()) {
    _this->_internal_mutable_accountid()->::proto::AccountID::MergeFrom(
        from._internal_accountid());
  }
  if (from._internal_amount() != 0) {
    _this->_internal_set_amount(from._internal_amount());
  }
  if (from._internal_is_approval() != 0) {
    _this->_internal_set_is_approval(from._internal_is_approval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountAmount::CopyFrom(const AccountAmount& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.AccountAmount)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountAmount::IsInitialized() const {
  return true;
}

void AccountAmount::InternalSwap(AccountAmount* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AccountAmount, _impl_.is_approval_)
      + sizeof(AccountAmount::_impl_.is_approval_)
      - PROTOBUF_FIELD_OFFSET(AccountAmount, _impl_.accountid_)>(
          reinterpret_cast<char*>(&_impl_.accountid_),
          reinterpret_cast<char*>(&other->_impl_.accountid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountAmount::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[6]);
}

// ===================================================================

class TransferList::_Internal {
 public:
};

TransferList::TransferList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.TransferList)
}
TransferList::TransferList(const TransferList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TransferList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.accountamounts_){from._impl_.accountamounts_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.TransferList)
}

inline void TransferList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.accountamounts_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TransferList::~TransferList() {
  // @@protoc_insertion_point(destructor:proto.TransferList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TransferList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.accountamounts_.~RepeatedPtrField();
}

void TransferList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TransferList::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.TransferList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.accountamounts_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TransferList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.AccountAmount accountAmounts = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_accountamounts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TransferList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.TransferList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.AccountAmount accountAmounts = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_accountamounts_size()); i < n; i++) {
    const auto& repfield = this->_internal_accountamounts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.TransferList)
  return target;
}

size_t TransferList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.TransferList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.AccountAmount accountAmounts = 1;
  total_size += 1UL * this->_internal_accountamounts_size();
  for (const auto& msg : this->_impl_.accountamounts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TransferList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TransferList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TransferList::GetClassData() const { return &_class_data_; }


void TransferList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TransferList*>(&to_msg);
  auto& from = static_cast<const TransferList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.TransferList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.accountamounts_.MergeFrom(from._impl_.accountamounts_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TransferList::CopyFrom(const TransferList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.TransferList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransferList::IsInitialized() const {
  return true;
}

void TransferList::InternalSwap(TransferList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.accountamounts_.InternalSwap(&other->_impl_.accountamounts_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TransferList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[7]);
}

// ===================================================================

class NftTransfer::_Internal {
 public:
  static const ::proto::AccountID& senderaccountid(const NftTransfer* msg);
  static const ::proto::AccountID& receiveraccountid(const NftTransfer* msg);
};

const ::proto::AccountID&
NftTransfer::_Internal::senderaccountid(const NftTransfer* msg) {
  return *msg->_impl_.senderaccountid_;
}
const ::proto::AccountID&
NftTransfer::_Internal::receiveraccountid(const NftTransfer* msg) {
  return *msg->_impl_.receiveraccountid_;
}
NftTransfer::NftTransfer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.NftTransfer)
}
NftTransfer::NftTransfer(const NftTransfer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NftTransfer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.senderaccountid_){nullptr}
    , decltype(_impl_.receiveraccountid_){nullptr}
    , decltype(_impl_.serialnumber_){}
    , decltype(_impl_.is_approval_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_senderaccountid()) {
    _this->_impl_.senderaccountid_ = new ::proto::AccountID(*from._impl_.senderaccountid_);
  }
  if (from._internal_has_receiveraccountid()) {
    _this->_impl_.receiveraccountid_ = new ::proto::AccountID(*from._impl_.receiveraccountid_);
  }
  ::memcpy(&_impl_.serialnumber_, &from._impl_.serialnumber_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_approval_) -
    reinterpret_cast<char*>(&_impl_.serialnumber_)) + sizeof(_impl_.is_approval_));
  // @@protoc_insertion_point(copy_constructor:proto.NftTransfer)
}

inline void NftTransfer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.senderaccountid_){nullptr}
    , decltype(_impl_.receiveraccountid_){nullptr}
    , decltype(_impl_.serialnumber_){int64_t{0}}
    , decltype(_impl_.is_approval_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NftTransfer::~NftTransfer() {
  // @@protoc_insertion_point(destructor:proto.NftTransfer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NftTransfer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.senderaccountid_;
  if (this != internal_default_instance()) delete _impl_.receiveraccountid_;
}

void NftTransfer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NftTransfer::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.NftTransfer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.senderaccountid_ != nullptr) {
    delete _impl_.senderaccountid_;
  }
  _impl_.senderaccountid_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.receiveraccountid_ != nullptr) {
    delete _impl_.receiveraccountid_;
  }
  _impl_.receiveraccountid_ = nullptr;
  ::memset(&_impl_.serialnumber_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_approval_) -
      reinterpret_cast<char*>(&_impl_.serialnumber_)) + sizeof(_impl_.is_approval_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NftTransfer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.AccountID senderAccountID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_senderaccountid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.AccountID receiverAccountID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_receiveraccountid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 serialNumber = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.serialnumber_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_approval = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.is_approval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NftTransfer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.NftTransfer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.AccountID senderAccountID = 1;
  if (this->_internal_has_senderaccountid()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::senderaccountid(this),
        _Internal::senderaccountid(this).GetCachedSize(), target, stream);
  }

  // .proto.AccountID receiverAccountID = 2;
  if (this->_internal_has_receiveraccountid()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::receiveraccountid(this),
        _Internal::receiveraccountid(this).GetCachedSize(), target, stream);
  }

  // int64 serialNumber = 3;
  if (this->_internal_serialnumber() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_serialnumber(), target);
  }

  // bool is_approval = 4;
  if (this->_internal_is_approval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_approval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.NftTransfer)
  return target;
}

size_t NftTransfer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.NftTransfer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.AccountID senderAccountID = 1;
  if (this->_internal_has_senderaccountid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.senderaccountid_);
  }

  // .proto.AccountID receiverAccountID = 2;
  if (this->_internal_has_receiveraccountid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.receiveraccountid_);
  }

  // int64 serialNumber = 3;
  if (this->_internal_serialnumber() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_serialnumber());
  }

  // bool is_approval = 4;
  if (this->_internal_is_approval() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NftTransfer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NftTransfer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NftTransfer::GetClassData() const { return &_class_data_; }


void NftTransfer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NftTransfer*>(&to_msg);
  auto& from = static_cast<const NftTransfer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.NftTransfer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_senderaccountid()) {
    _this->_internal_mutable_senderaccountid()->::proto::AccountID::MergeFrom(
        from._internal_senderaccountid());
  }
  if (from._internal_has_receiveraccountid()) {
    _this->_internal_mutable_receiveraccountid()->::proto::AccountID::MergeFrom(
        from._internal_receiveraccountid());
  }
  if (from._internal_serialnumber() != 0) {
    _this->_internal_set_serialnumber(from._internal_serialnumber());
  }
  if (from._internal_is_approval() != 0) {
    _this->_internal_set_is_approval(from._internal_is_approval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NftTransfer::CopyFrom(const NftTransfer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.NftTransfer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NftTransfer::IsInitialized() const {
  return true;
}

void NftTransfer::InternalSwap(NftTransfer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NftTransfer, _impl_.is_approval_)
      + sizeof(NftTransfer::_impl_.is_approval_)
      - PROTOBUF_FIELD_OFFSET(NftTransfer, _impl_.senderaccountid_)>(
          reinterpret_cast<char*>(&_impl_.senderaccountid_),
          reinterpret_cast<char*>(&other->_impl_.senderaccountid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NftTransfer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[8]);
}

// ===================================================================

class TokenTransferList::_Internal {
 public:
  static const ::proto::TokenID& token(const TokenTransferList* msg);
  static const ::PROTOBUF_NAMESPACE_ID::UInt32Value& expected_decimals(const TokenTransferList* msg);
};

const ::proto::TokenID&
TokenTransferList::_Internal::token(const TokenTransferList* msg) {
  return *msg->_impl_.token_;
}
const ::PROTOBUF_NAMESPACE_ID::UInt32Value&
TokenTransferList::_Internal::expected_decimals(const TokenTransferList* msg) {
  return *msg->_impl_.expected_decimals_;
}
void TokenTransferList::clear_expected_decimals() {
  if (GetArenaForAllocation() == nullptr && _impl_.expected_decimals_ != nullptr) {
    delete _impl_.expected_decimals_;
  }
  _impl_.expected_decimals_ = nullptr;
}
TokenTransferList::TokenTransferList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.TokenTransferList)
}
TokenTransferList::TokenTransferList(const TokenTransferList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TokenTransferList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.transfers_){from._impl_.transfers_}
    , decltype(_impl_.nfttransfers_){from._impl_.nfttransfers_}
    , decltype(_impl_.token_){nullptr}
    , decltype(_impl_.expected_decimals_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_token()) {
    _this->_impl_.token_ = new ::proto::TokenID(*from._impl_.token_);
  }
  if (from._internal_has_expected_decimals()) {
    _this->_impl_.expected_decimals_ = new ::PROTOBUF_NAMESPACE_ID::UInt32Value(*from._impl_.expected_decimals_);
  }
  // @@protoc_insertion_point(copy_constructor:proto.TokenTransferList)
}

inline void TokenTransferList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.transfers_){arena}
    , decltype(_impl_.nfttransfers_){arena}
    , decltype(_impl_.token_){nullptr}
    , decltype(_impl_.expected_decimals_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TokenTransferList::~TokenTransferList() {
  // @@protoc_insertion_point(destructor:proto.TokenTransferList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TokenTransferList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.transfers_.~RepeatedPtrField();
  _impl_.nfttransfers_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.token_;
  if (this != internal_default_instance()) delete _impl_.expected_decimals_;
}

void TokenTransferList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TokenTransferList::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.TokenTransferList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.transfers_.Clear();
  _impl_.nfttransfers_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.token_ != nullptr) {
    delete _impl_.token_;
  }
  _impl_.token_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.expected_decimals_ != nullptr) {
    delete _impl_.expected_decimals_;
  }
  _impl_.expected_decimals_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TokenTransferList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.TokenID token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_token(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .proto.AccountAmount transfers = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_transfers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .proto.NftTransfer nftTransfers = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nfttransfers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.UInt32Value expected_decimals = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_expected_decimals(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TokenTransferList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.TokenTransferList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.TokenID token = 1;
  if (this->_internal_has_token()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::token(this),
        _Internal::token(this).GetCachedSize(), target, stream);
  }

  // repeated .proto.AccountAmount transfers = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_transfers_size()); i < n; i++) {
    const auto& repfield = this->_internal_transfers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .proto.NftTransfer nftTransfers = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nfttransfers_size()); i < n; i++) {
    const auto& repfield = this->_internal_nfttransfers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .google.protobuf.UInt32Value expected_decimals = 4;
  if (this->_internal_has_expected_decimals()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::expected_decimals(this),
        _Internal::expected_decimals(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.TokenTransferList)
  return target;
}

size_t TokenTransferList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.TokenTransferList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.AccountAmount transfers = 2;
  total_size += 1UL * this->_internal_transfers_size();
  for (const auto& msg : this->_impl_.transfers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .proto.NftTransfer nftTransfers = 3;
  total_size += 1UL * this->_internal_nfttransfers_size();
  for (const auto& msg : this->_impl_.nfttransfers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .proto.TokenID token = 1;
  if (this->_internal_has_token()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.token_);
  }

  // .google.protobuf.UInt32Value expected_decimals = 4;
  if (this->_internal_has_expected_decimals()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.expected_decimals_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TokenTransferList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TokenTransferList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TokenTransferList::GetClassData() const { return &_class_data_; }


void TokenTransferList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TokenTransferList*>(&to_msg);
  auto& from = static_cast<const TokenTransferList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.TokenTransferList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.transfers_.MergeFrom(from._impl_.transfers_);
  _this->_impl_.nfttransfers_.MergeFrom(from._impl_.nfttransfers_);
  if (from._internal_has_token()) {
    _this->_internal_mutable_token()->::proto::TokenID::MergeFrom(
        from._internal_token());
  }
  if (from._internal_has_expected_decimals()) {
    _this->_internal_mutable_expected_decimals()->::PROTOBUF_NAMESPACE_ID::UInt32Value::MergeFrom(
        from._internal_expected_decimals());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TokenTransferList::CopyFrom(const TokenTransferList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.TokenTransferList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TokenTransferList::IsInitialized() const {
  return true;
}

void TokenTransferList::InternalSwap(TokenTransferList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.transfers_.InternalSwap(&other->_impl_.transfers_);
  _impl_.nfttransfers_.InternalSwap(&other->_impl_.nfttransfers_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TokenTransferList, _impl_.expected_decimals_)
      + sizeof(TokenTransferList::_impl_.expected_decimals_)
      - PROTOBUF_FIELD_OFFSET(TokenTransferList, _impl_.token_)>(
          reinterpret_cast<char*>(&_impl_.token_),
          reinterpret_cast<char*>(&other->_impl_.token_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TokenTransferList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[9]);
}

// ===================================================================

class Fraction::_Internal {
 public:
};

Fraction::Fraction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.Fraction)
}
Fraction::Fraction(const Fraction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Fraction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.numerator_){}
    , decltype(_impl_.denominator_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.numerator_, &from._impl_.numerator_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.denominator_) -
    reinterpret_cast<char*>(&_impl_.numerator_)) + sizeof(_impl_.denominator_));
  // @@protoc_insertion_point(copy_constructor:proto.Fraction)
}

inline void Fraction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.numerator_){int64_t{0}}
    , decltype(_impl_.denominator_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Fraction::~Fraction() {
  // @@protoc_insertion_point(destructor:proto.Fraction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Fraction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Fraction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Fraction::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.Fraction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.numerator_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.denominator_) -
      reinterpret_cast<char*>(&_impl_.numerator_)) + sizeof(_impl_.denominator_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Fraction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 numerator = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.numerator_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 denominator = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.denominator_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Fraction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.Fraction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 numerator = 1;
  if (this->_internal_numerator() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_numerator(), target);
  }

  // int64 denominator = 2;
  if (this->_internal_denominator() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_denominator(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.Fraction)
  return target;
}

size_t Fraction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.Fraction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 numerator = 1;
  if (this->_internal_numerator() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_numerator());
  }

  // int64 denominator = 2;
  if (this->_internal_denominator() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_denominator());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Fraction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Fraction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Fraction::GetClassData() const { return &_class_data_; }


void Fraction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Fraction*>(&to_msg);
  auto& from = static_cast<const Fraction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.Fraction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_numerator() != 0) {
    _this->_internal_set_numerator(from._internal_numerator());
  }
  if (from._internal_denominator() != 0) {
    _this->_internal_set_denominator(from._internal_denominator());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Fraction::CopyFrom(const Fraction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.Fraction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fraction::IsInitialized() const {
  return true;
}

void Fraction::InternalSwap(Fraction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Fraction, _impl_.denominator_)
      + sizeof(Fraction::_impl_.denominator_)
      - PROTOBUF_FIELD_OFFSET(Fraction, _impl_.numerator_)>(
          reinterpret_cast<char*>(&_impl_.numerator_),
          reinterpret_cast<char*>(&other->_impl_.numerator_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Fraction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[10]);
}

// ===================================================================

class TopicID::_Internal {
 public:
};

TopicID::TopicID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.TopicID)
}
TopicID::TopicID(const TopicID& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TopicID* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.shardnum_){}
    , decltype(_impl_.realmnum_){}
    , decltype(_impl_.topicnum_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.shardnum_, &from._impl_.shardnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.topicnum_) -
    reinterpret_cast<char*>(&_impl_.shardnum_)) + sizeof(_impl_.topicnum_));
  // @@protoc_insertion_point(copy_constructor:proto.TopicID)
}

inline void TopicID::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.shardnum_){int64_t{0}}
    , decltype(_impl_.realmnum_){int64_t{0}}
    , decltype(_impl_.topicnum_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TopicID::~TopicID() {
  // @@protoc_insertion_point(destructor:proto.TopicID)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TopicID::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TopicID::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TopicID::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.TopicID)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.shardnum_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.topicnum_) -
      reinterpret_cast<char*>(&_impl_.shardnum_)) + sizeof(_impl_.topicnum_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TopicID::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 shardNum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.shardnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 realmNum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.realmnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 topicNum = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.topicnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TopicID::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.TopicID)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 shardNum = 1;
  if (this->_internal_shardnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_shardnum(), target);
  }

  // int64 realmNum = 2;
  if (this->_internal_realmnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_realmnum(), target);
  }

  // int64 topicNum = 3;
  if (this->_internal_topicnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_topicnum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.TopicID)
  return target;
}

size_t TopicID::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.TopicID)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 shardNum = 1;
  if (this->_internal_shardnum() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shardnum());
  }

  // int64 realmNum = 2;
  if (this->_internal_realmnum() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_realmnum());
  }

  // int64 topicNum = 3;
  if (this->_internal_topicnum() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_topicnum());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TopicID::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TopicID::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TopicID::GetClassData() const { return &_class_data_; }


void TopicID::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TopicID*>(&to_msg);
  auto& from = static_cast<const TopicID&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.TopicID)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_shardnum() != 0) {
    _this->_internal_set_shardnum(from._internal_shardnum());
  }
  if (from._internal_realmnum() != 0) {
    _this->_internal_set_realmnum(from._internal_realmnum());
  }
  if (from._internal_topicnum() != 0) {
    _this->_internal_set_topicnum(from._internal_topicnum());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TopicID::CopyFrom(const TopicID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.TopicID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TopicID::IsInitialized() const {
  return true;
}

void TopicID::InternalSwap(TopicID* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TopicID, _impl_.topicnum_)
      + sizeof(TopicID::_impl_.topicnum_)
      - PROTOBUF_FIELD_OFFSET(TopicID, _impl_.shardnum_)>(
          reinterpret_cast<char*>(&_impl_.shardnum_),
          reinterpret_cast<char*>(&other->_impl_.shardnum_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TopicID::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[11]);
}

// ===================================================================

class TokenID::_Internal {
 public:
};

TokenID::TokenID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.TokenID)
}
TokenID::TokenID(const TokenID& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TokenID* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.shardnum_){}
    , decltype(_impl_.realmnum_){}
    , decltype(_impl_.tokennum_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.shardnum_, &from._impl_.shardnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.tokennum_) -
    reinterpret_cast<char*>(&_impl_.shardnum_)) + sizeof(_impl_.tokennum_));
  // @@protoc_insertion_point(copy_constructor:proto.TokenID)
}

inline void TokenID::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.shardnum_){int64_t{0}}
    , decltype(_impl_.realmnum_){int64_t{0}}
    , decltype(_impl_.tokennum_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TokenID::~TokenID() {
  // @@protoc_insertion_point(destructor:proto.TokenID)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TokenID::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TokenID::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TokenID::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.TokenID)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.shardnum_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.tokennum_) -
      reinterpret_cast<char*>(&_impl_.shardnum_)) + sizeof(_impl_.tokennum_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TokenID::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 shardNum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.shardnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 realmNum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.realmnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 tokenNum = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.tokennum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TokenID::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.TokenID)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 shardNum = 1;
  if (this->_internal_shardnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_shardnum(), target);
  }

  // int64 realmNum = 2;
  if (this->_internal_realmnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_realmnum(), target);
  }

  // int64 tokenNum = 3;
  if (this->_internal_tokennum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_tokennum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.TokenID)
  return target;
}

size_t TokenID::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.TokenID)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 shardNum = 1;
  if (this->_internal_shardnum() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shardnum());
  }

  // int64 realmNum = 2;
  if (this->_internal_realmnum() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_realmnum());
  }

  // int64 tokenNum = 3;
  if (this->_internal_tokennum() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_tokennum());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TokenID::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TokenID::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TokenID::GetClassData() const { return &_class_data_; }


void TokenID::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TokenID*>(&to_msg);
  auto& from = static_cast<const TokenID&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.TokenID)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_shardnum() != 0) {
    _this->_internal_set_shardnum(from._internal_shardnum());
  }
  if (from._internal_realmnum() != 0) {
    _this->_internal_set_realmnum(from._internal_realmnum());
  }
  if (from._internal_tokennum() != 0) {
    _this->_internal_set_tokennum(from._internal_tokennum());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TokenID::CopyFrom(const TokenID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.TokenID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TokenID::IsInitialized() const {
  return true;
}

void TokenID::InternalSwap(TokenID* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TokenID, _impl_.tokennum_)
      + sizeof(TokenID::_impl_.tokennum_)
      - PROTOBUF_FIELD_OFFSET(TokenID, _impl_.shardnum_)>(
          reinterpret_cast<char*>(&_impl_.shardnum_),
          reinterpret_cast<char*>(&other->_impl_.shardnum_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TokenID::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[12]);
}

// ===================================================================

class ScheduleID::_Internal {
 public:
};

ScheduleID::ScheduleID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.ScheduleID)
}
ScheduleID::ScheduleID(const ScheduleID& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ScheduleID* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.shardnum_){}
    , decltype(_impl_.realmnum_){}
    , decltype(_impl_.schedulenum_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.shardnum_, &from._impl_.shardnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.schedulenum_) -
    reinterpret_cast<char*>(&_impl_.shardnum_)) + sizeof(_impl_.schedulenum_));
  // @@protoc_insertion_point(copy_constructor:proto.ScheduleID)
}

inline void ScheduleID::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.shardnum_){int64_t{0}}
    , decltype(_impl_.realmnum_){int64_t{0}}
    , decltype(_impl_.schedulenum_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ScheduleID::~ScheduleID() {
  // @@protoc_insertion_point(destructor:proto.ScheduleID)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ScheduleID::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ScheduleID::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ScheduleID::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.ScheduleID)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.shardnum_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.schedulenum_) -
      reinterpret_cast<char*>(&_impl_.shardnum_)) + sizeof(_impl_.schedulenum_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ScheduleID::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 shardNum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.shardnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 realmNum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.realmnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 scheduleNum = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.schedulenum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScheduleID::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.ScheduleID)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 shardNum = 1;
  if (this->_internal_shardnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_shardnum(), target);
  }

  // int64 realmNum = 2;
  if (this->_internal_realmnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_realmnum(), target);
  }

  // int64 scheduleNum = 3;
  if (this->_internal_schedulenum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_schedulenum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.ScheduleID)
  return target;
}

size_t ScheduleID::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.ScheduleID)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 shardNum = 1;
  if (this->_internal_shardnum() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shardnum());
  }

  // int64 realmNum = 2;
  if (this->_internal_realmnum() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_realmnum());
  }

  // int64 scheduleNum = 3;
  if (this->_internal_schedulenum() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_schedulenum());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ScheduleID::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ScheduleID::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ScheduleID::GetClassData() const { return &_class_data_; }


void ScheduleID::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ScheduleID*>(&to_msg);
  auto& from = static_cast<const ScheduleID&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.ScheduleID)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_shardnum() != 0) {
    _this->_internal_set_shardnum(from._internal_shardnum());
  }
  if (from._internal_realmnum() != 0) {
    _this->_internal_set_realmnum(from._internal_realmnum());
  }
  if (from._internal_schedulenum() != 0) {
    _this->_internal_set_schedulenum(from._internal_schedulenum());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ScheduleID::CopyFrom(const ScheduleID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.ScheduleID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScheduleID::IsInitialized() const {
  return true;
}

void ScheduleID::InternalSwap(ScheduleID* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ScheduleID, _impl_.schedulenum_)
      + sizeof(ScheduleID::_impl_.schedulenum_)
      - PROTOBUF_FIELD_OFFSET(ScheduleID, _impl_.shardnum_)>(
          reinterpret_cast<char*>(&_impl_.shardnum_),
          reinterpret_cast<char*>(&other->_impl_.shardnum_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ScheduleID::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[13]);
}

// ===================================================================

class Key::_Internal {
 public:
  static const ::proto::ContractID& contractid(const Key* msg);
  static const ::proto::ThresholdKey& thresholdkey(const Key* msg);
  static const ::proto::KeyList& keylist(const Key* msg);
  static const ::proto::ContractID& delegatable_contract_id(const Key* msg);
};

const ::proto::ContractID&
Key::_Internal::contractid(const Key* msg) {
  return *msg->_impl_.key_.contractid_;
}
const ::proto::ThresholdKey&
Key::_Internal::thresholdkey(const Key* msg) {
  return *msg->_impl_.key_.thresholdkey_;
}
const ::proto::KeyList&
Key::_Internal::keylist(const Key* msg) {
  return *msg->_impl_.key_.keylist_;
}
const ::proto::ContractID&
Key::_Internal::delegatable_contract_id(const Key* msg) {
  return *msg->_impl_.key_.delegatable_contract_id_;
}
void Key::set_allocated_contractid(::proto::ContractID* contractid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_key();
  if (contractid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contractid);
    if (message_arena != submessage_arena) {
      contractid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contractid, submessage_arena);
    }
    set_has_contractid();
    _impl_.key_.contractid_ = contractid;
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Key.contractID)
}
void Key::set_allocated_thresholdkey(::proto::ThresholdKey* thresholdkey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_key();
  if (thresholdkey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(thresholdkey);
    if (message_arena != submessage_arena) {
      thresholdkey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, thresholdkey, submessage_arena);
    }
    set_has_thresholdkey();
    _impl_.key_.thresholdkey_ = thresholdkey;
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Key.thresholdKey)
}
void Key::set_allocated_keylist(::proto::KeyList* keylist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_key();
  if (keylist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(keylist);
    if (message_arena != submessage_arena) {
      keylist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keylist, submessage_arena);
    }
    set_has_keylist();
    _impl_.key_.keylist_ = keylist;
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Key.keyList)
}
void Key::set_allocated_delegatable_contract_id(::proto::ContractID* delegatable_contract_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_key();
  if (delegatable_contract_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(delegatable_contract_id);
    if (message_arena != submessage_arena) {
      delegatable_contract_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delegatable_contract_id, submessage_arena);
    }
    set_has_delegatable_contract_id();
    _impl_.key_.delegatable_contract_id_ = delegatable_contract_id;
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Key.delegatable_contract_id)
}
Key::Key(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.Key)
}
Key::Key(const Key& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Key* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_key();
  switch (from.key_case()) {
    case kContractID: {
      _this->_internal_mutable_contractid()->::proto::ContractID::MergeFrom(
          from._internal_contractid());
      break;
    }
    case kEd25519: {
      _this->_internal_set_ed25519(from._internal_ed25519());
      break;
    }
    case kRSA3072: {
      _this->_internal_set_rsa_3072(from._internal_rsa_3072());
      break;
    }
    case kECDSA384: {
      _this->_internal_set_ecdsa_384(from._internal_ecdsa_384());
      break;
    }
    case kThresholdKey: {
      _this->_internal_mutable_thresholdkey()->::proto::ThresholdKey::MergeFrom(
          from._internal_thresholdkey());
      break;
    }
    case kKeyList: {
      _this->_internal_mutable_keylist()->::proto::KeyList::MergeFrom(
          from._internal_keylist());
      break;
    }
    case kECDSASecp256K1: {
      _this->_internal_set_ecdsa_secp256k1(from._internal_ecdsa_secp256k1());
      break;
    }
    case kDelegatableContractId: {
      _this->_internal_mutable_delegatable_contract_id()->::proto::ContractID::MergeFrom(
          from._internal_delegatable_contract_id());
      break;
    }
    case KEY_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:proto.Key)
}

inline void Key::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_key();
}

Key::~Key() {
  // @@protoc_insertion_point(destructor:proto.Key)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Key::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_key()) {
    clear_key();
  }
}

void Key::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Key::clear_key() {
// @@protoc_insertion_point(one_of_clear_start:proto.Key)
  switch (key_case()) {
    case kContractID: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.key_.contractid_;
      }
      break;
    }
    case kEd25519: {
      _impl_.key_.ed25519_.Destroy();
      break;
    }
    case kRSA3072: {
      _impl_.key_.rsa_3072_.Destroy();
      break;
    }
    case kECDSA384: {
      _impl_.key_.ecdsa_384_.Destroy();
      break;
    }
    case kThresholdKey: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.key_.thresholdkey_;
      }
      break;
    }
    case kKeyList: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.key_.keylist_;
      }
      break;
    }
    case kECDSASecp256K1: {
      _impl_.key_.ecdsa_secp256k1_.Destroy();
      break;
    }
    case kDelegatableContractId: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.key_.delegatable_contract_id_;
      }
      break;
    }
    case KEY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = KEY_NOT_SET;
}


void Key::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.Key)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_key();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Key::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.ContractID contractID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_contractid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes ed25519 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ed25519();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes RSA_3072 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_rsa_3072();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes ECDSA_384 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_ecdsa_384();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.ThresholdKey thresholdKey = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_thresholdkey(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.KeyList keyList = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_keylist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes ECDSA_secp256k1 = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_ecdsa_secp256k1();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.ContractID delegatable_contract_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_delegatable_contract_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Key::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.Key)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.ContractID contractID = 1;
  if (_internal_has_contractid()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::contractid(this),
        _Internal::contractid(this).GetCachedSize(), target, stream);
  }

  // bytes ed25519 = 2;
  if (_internal_has_ed25519()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_ed25519(), target);
  }

  // bytes RSA_3072 = 3;
  if (_internal_has_rsa_3072()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_rsa_3072(), target);
  }

  // bytes ECDSA_384 = 4;
  if (_internal_has_ecdsa_384()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_ecdsa_384(), target);
  }

  // .proto.ThresholdKey thresholdKey = 5;
  if (_internal_has_thresholdkey()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::thresholdkey(this),
        _Internal::thresholdkey(this).GetCachedSize(), target, stream);
  }

  // .proto.KeyList keyList = 6;
  if (_internal_has_keylist()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::keylist(this),
        _Internal::keylist(this).GetCachedSize(), target, stream);
  }

  // bytes ECDSA_secp256k1 = 7;
  if (_internal_has_ecdsa_secp256k1()) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_ecdsa_secp256k1(), target);
  }

  // .proto.ContractID delegatable_contract_id = 8;
  if (_internal_has_delegatable_contract_id()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::delegatable_contract_id(this),
        _Internal::delegatable_contract_id(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.Key)
  return target;
}

size_t Key::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.Key)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (key_case()) {
    // .proto.ContractID contractID = 1;
    case kContractID: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.key_.contractid_);
      break;
    }
    // bytes ed25519 = 2;
    case kEd25519: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ed25519());
      break;
    }
    // bytes RSA_3072 = 3;
    case kRSA3072: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_rsa_3072());
      break;
    }
    // bytes ECDSA_384 = 4;
    case kECDSA384: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ecdsa_384());
      break;
    }
    // .proto.ThresholdKey thresholdKey = 5;
    case kThresholdKey: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.key_.thresholdkey_);
      break;
    }
    // .proto.KeyList keyList = 6;
    case kKeyList: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.key_.keylist_);
      break;
    }
    // bytes ECDSA_secp256k1 = 7;
    case kECDSASecp256K1: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ecdsa_secp256k1());
      break;
    }
    // .proto.ContractID delegatable_contract_id = 8;
    case kDelegatableContractId: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.key_.delegatable_contract_id_);
      break;
    }
    case KEY_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Key::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Key::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Key::GetClassData() const { return &_class_data_; }


void Key::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Key*>(&to_msg);
  auto& from = static_cast<const Key&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.Key)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.key_case()) {
    case kContractID: {
      _this->_internal_mutable_contractid()->::proto::ContractID::MergeFrom(
          from._internal_contractid());
      break;
    }
    case kEd25519: {
      _this->_internal_set_ed25519(from._internal_ed25519());
      break;
    }
    case kRSA3072: {
      _this->_internal_set_rsa_3072(from._internal_rsa_3072());
      break;
    }
    case kECDSA384: {
      _this->_internal_set_ecdsa_384(from._internal_ecdsa_384());
      break;
    }
    case kThresholdKey: {
      _this->_internal_mutable_thresholdkey()->::proto::ThresholdKey::MergeFrom(
          from._internal_thresholdkey());
      break;
    }
    case kKeyList: {
      _this->_internal_mutable_keylist()->::proto::KeyList::MergeFrom(
          from._internal_keylist());
      break;
    }
    case kECDSASecp256K1: {
      _this->_internal_set_ecdsa_secp256k1(from._internal_ecdsa_secp256k1());
      break;
    }
    case kDelegatableContractId: {
      _this->_internal_mutable_delegatable_contract_id()->::proto::ContractID::MergeFrom(
          from._internal_delegatable_contract_id());
      break;
    }
    case KEY_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Key::CopyFrom(const Key& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.Key)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Key::IsInitialized() const {
  return true;
}

void Key::InternalSwap(Key* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.key_, other->_impl_.key_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Key::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[14]);
}

// ===================================================================

class ThresholdKey::_Internal {
 public:
  static const ::proto::KeyList& keys(const ThresholdKey* msg);
};

const ::proto::KeyList&
ThresholdKey::_Internal::keys(const ThresholdKey* msg) {
  return *msg->_impl_.keys_;
}
ThresholdKey::ThresholdKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.ThresholdKey)
}
ThresholdKey::ThresholdKey(const ThresholdKey& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ThresholdKey* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.keys_){nullptr}
    , decltype(_impl_.threshold_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_keys()) {
    _this->_impl_.keys_ = new ::proto::KeyList(*from._impl_.keys_);
  }
  _this->_impl_.threshold_ = from._impl_.threshold_;
  // @@protoc_insertion_point(copy_constructor:proto.ThresholdKey)
}

inline void ThresholdKey::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.keys_){nullptr}
    , decltype(_impl_.threshold_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ThresholdKey::~ThresholdKey() {
  // @@protoc_insertion_point(destructor:proto.ThresholdKey)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThresholdKey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.keys_;
}

void ThresholdKey::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThresholdKey::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.ThresholdKey)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.keys_ != nullptr) {
    delete _impl_.keys_;
  }
  _impl_.keys_ = nullptr;
  _impl_.threshold_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ThresholdKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 threshold = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.KeyList keys = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_keys(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThresholdKey::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.ThresholdKey)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 threshold = 1;
  if (this->_internal_threshold() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_threshold(), target);
  }

  // .proto.KeyList keys = 2;
  if (this->_internal_has_keys()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::keys(this),
        _Internal::keys(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.ThresholdKey)
  return target;
}

size_t ThresholdKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.ThresholdKey)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.KeyList keys = 2;
  if (this->_internal_has_keys()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.keys_);
  }

  // uint32 threshold = 1;
  if (this->_internal_threshold() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_threshold());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ThresholdKey::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ThresholdKey::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ThresholdKey::GetClassData() const { return &_class_data_; }


void ThresholdKey::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ThresholdKey*>(&to_msg);
  auto& from = static_cast<const ThresholdKey&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.ThresholdKey)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_keys()) {
    _this->_internal_mutable_keys()->::proto::KeyList::MergeFrom(
        from._internal_keys());
  }
  if (from._internal_threshold() != 0) {
    _this->_internal_set_threshold(from._internal_threshold());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ThresholdKey::CopyFrom(const ThresholdKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.ThresholdKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThresholdKey::IsInitialized() const {
  return true;
}

void ThresholdKey::InternalSwap(ThresholdKey* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ThresholdKey, _impl_.threshold_)
      + sizeof(ThresholdKey::_impl_.threshold_)
      - PROTOBUF_FIELD_OFFSET(ThresholdKey, _impl_.keys_)>(
          reinterpret_cast<char*>(&_impl_.keys_),
          reinterpret_cast<char*>(&other->_impl_.keys_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ThresholdKey::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[15]);
}

// ===================================================================

class KeyList::_Internal {
 public:
};

KeyList::KeyList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.KeyList)
}
KeyList::KeyList(const KeyList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  KeyList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.keys_){from._impl_.keys_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.KeyList)
}

inline void KeyList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.keys_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

KeyList::~KeyList() {
  // @@protoc_insertion_point(destructor:proto.KeyList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KeyList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.keys_.~RepeatedPtrField();
}

void KeyList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KeyList::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.KeyList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.keys_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeyList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.Key keys = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeyList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.KeyList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.Key keys = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_keys_size()); i < n; i++) {
    const auto& repfield = this->_internal_keys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.KeyList)
  return target;
}

size_t KeyList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.KeyList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.Key keys = 1;
  total_size += 1UL * this->_internal_keys_size();
  for (const auto& msg : this->_impl_.keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeyList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KeyList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeyList::GetClassData() const { return &_class_data_; }


void KeyList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KeyList*>(&to_msg);
  auto& from = static_cast<const KeyList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.KeyList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.keys_.MergeFrom(from._impl_.keys_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeyList::CopyFrom(const KeyList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.KeyList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyList::IsInitialized() const {
  return true;
}

void KeyList::InternalSwap(KeyList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.keys_.InternalSwap(&other->_impl_.keys_);
}

::PROTOBUF_NAMESPACE_ID::Metadata KeyList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[16]);
}

// ===================================================================

class Signature::_Internal {
 public:
  static const ::proto::ThresholdSignature& thresholdsignature(const Signature* msg);
  static const ::proto::SignatureList& signaturelist(const Signature* msg);
};

const ::proto::ThresholdSignature&
Signature::_Internal::thresholdsignature(const Signature* msg) {
  return *msg->_impl_.signature_.thresholdsignature_;
}
const ::proto::SignatureList&
Signature::_Internal::signaturelist(const Signature* msg) {
  return *msg->_impl_.signature_.signaturelist_;
}
void Signature::set_allocated_thresholdsignature(::proto::ThresholdSignature* thresholdsignature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_signature();
  if (thresholdsignature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(thresholdsignature);
    if (message_arena != submessage_arena) {
      thresholdsignature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, thresholdsignature, submessage_arena);
    }
    set_has_thresholdsignature();
    _impl_.signature_.thresholdsignature_ = thresholdsignature;
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Signature.thresholdSignature)
}
void Signature::set_allocated_signaturelist(::proto::SignatureList* signaturelist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_signature();
  if (signaturelist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(signaturelist);
    if (message_arena != submessage_arena) {
      signaturelist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signaturelist, submessage_arena);
    }
    set_has_signaturelist();
    _impl_.signature_.signaturelist_ = signaturelist;
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Signature.signatureList)
}
Signature::Signature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.Signature)
}
Signature::Signature(const Signature& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Signature* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.signature_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_signature();
  switch (from.signature_case()) {
    case kContract: {
      _this->_internal_set_contract(from._internal_contract());
      break;
    }
    case kEd25519: {
      _this->_internal_set_ed25519(from._internal_ed25519());
      break;
    }
    case kRSA3072: {
      _this->_internal_set_rsa_3072(from._internal_rsa_3072());
      break;
    }
    case kECDSA384: {
      _this->_internal_set_ecdsa_384(from._internal_ecdsa_384());
      break;
    }
    case kThresholdSignature: {
      _this->_internal_mutable_thresholdsignature()->::proto::ThresholdSignature::MergeFrom(
          from._internal_thresholdsignature());
      break;
    }
    case kSignatureList: {
      _this->_internal_mutable_signaturelist()->::proto::SignatureList::MergeFrom(
          from._internal_signaturelist());
      break;
    }
    case SIGNATURE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:proto.Signature)
}

inline void Signature::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.signature_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_signature();
}

Signature::~Signature() {
  // @@protoc_insertion_point(destructor:proto.Signature)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Signature::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_signature()) {
    clear_signature();
  }
}

void Signature::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Signature::clear_signature() {
// @@protoc_insertion_point(one_of_clear_start:proto.Signature)
  switch (signature_case()) {
    case kContract: {
      _impl_.signature_.contract_.Destroy();
      break;
    }
    case kEd25519: {
      _impl_.signature_.ed25519_.Destroy();
      break;
    }
    case kRSA3072: {
      _impl_.signature_.rsa_3072_.Destroy();
      break;
    }
    case kECDSA384: {
      _impl_.signature_.ecdsa_384_.Destroy();
      break;
    }
    case kThresholdSignature: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.signature_.thresholdsignature_;
      }
      break;
    }
    case kSignatureList: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.signature_.signaturelist_;
      }
      break;
    }
    case SIGNATURE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SIGNATURE_NOT_SET;
}


void Signature::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.Signature)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_signature();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Signature::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes contract = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes ed25519 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ed25519();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes RSA_3072 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_rsa_3072();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes ECDSA_384 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_ecdsa_384();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.ThresholdSignature thresholdSignature = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_thresholdsignature(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.SignatureList signatureList = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_signaturelist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Signature::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.Signature)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes contract = 1;
  if (_internal_has_contract()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_contract(), target);
  }

  // bytes ed25519 = 2;
  if (_internal_has_ed25519()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_ed25519(), target);
  }

  // bytes RSA_3072 = 3;
  if (_internal_has_rsa_3072()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_rsa_3072(), target);
  }

  // bytes ECDSA_384 = 4;
  if (_internal_has_ecdsa_384()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_ecdsa_384(), target);
  }

  // .proto.ThresholdSignature thresholdSignature = 5;
  if (_internal_has_thresholdsignature()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::thresholdsignature(this),
        _Internal::thresholdsignature(this).GetCachedSize(), target, stream);
  }

  // .proto.SignatureList signatureList = 6;
  if (_internal_has_signaturelist()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::signaturelist(this),
        _Internal::signaturelist(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.Signature)
  return target;
}

size_t Signature::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.Signature)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (signature_case()) {
    // bytes contract = 1;
    case kContract: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_contract());
      break;
    }
    // bytes ed25519 = 2;
    case kEd25519: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ed25519());
      break;
    }
    // bytes RSA_3072 = 3;
    case kRSA3072: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_rsa_3072());
      break;
    }
    // bytes ECDSA_384 = 4;
    case kECDSA384: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ecdsa_384());
      break;
    }
    // .proto.ThresholdSignature thresholdSignature = 5;
    case kThresholdSignature: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.signature_.thresholdsignature_);
      break;
    }
    // .proto.SignatureList signatureList = 6;
    case kSignatureList: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.signature_.signaturelist_);
      break;
    }
    case SIGNATURE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Signature::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Signature::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Signature::GetClassData() const { return &_class_data_; }


void Signature::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Signature*>(&to_msg);
  auto& from = static_cast<const Signature&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.Signature)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.signature_case()) {
    case kContract: {
      _this->_internal_set_contract(from._internal_contract());
      break;
    }
    case kEd25519: {
      _this->_internal_set_ed25519(from._internal_ed25519());
      break;
    }
    case kRSA3072: {
      _this->_internal_set_rsa_3072(from._internal_rsa_3072());
      break;
    }
    case kECDSA384: {
      _this->_internal_set_ecdsa_384(from._internal_ecdsa_384());
      break;
    }
    case kThresholdSignature: {
      _this->_internal_mutable_thresholdsignature()->::proto::ThresholdSignature::MergeFrom(
          from._internal_thresholdsignature());
      break;
    }
    case kSignatureList: {
      _this->_internal_mutable_signaturelist()->::proto::SignatureList::MergeFrom(
          from._internal_signaturelist());
      break;
    }
    case SIGNATURE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Signature::CopyFrom(const Signature& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.Signature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Signature::IsInitialized() const {
  return true;
}

void Signature::InternalSwap(Signature* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.signature_, other->_impl_.signature_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Signature::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[17]);
}

// ===================================================================

class ThresholdSignature::_Internal {
 public:
  static const ::proto::SignatureList& sigs(const ThresholdSignature* msg);
};

const ::proto::SignatureList&
ThresholdSignature::_Internal::sigs(const ThresholdSignature* msg) {
  return *msg->_impl_.sigs_;
}
ThresholdSignature::ThresholdSignature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.ThresholdSignature)
}
ThresholdSignature::ThresholdSignature(const ThresholdSignature& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ThresholdSignature* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.sigs_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_sigs()) {
    _this->_impl_.sigs_ = new ::proto::SignatureList(*from._impl_.sigs_);
  }
  // @@protoc_insertion_point(copy_constructor:proto.ThresholdSignature)
}

inline void ThresholdSignature::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.sigs_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ThresholdSignature::~ThresholdSignature() {
  // @@protoc_insertion_point(destructor:proto.ThresholdSignature)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThresholdSignature::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.sigs_;
}

void ThresholdSignature::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThresholdSignature::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.ThresholdSignature)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.sigs_ != nullptr) {
    delete _impl_.sigs_;
  }
  _impl_.sigs_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ThresholdSignature::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.SignatureList sigs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_sigs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThresholdSignature::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.ThresholdSignature)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.SignatureList sigs = 2;
  if (this->_internal_has_sigs()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::sigs(this),
        _Internal::sigs(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.ThresholdSignature)
  return target;
}

size_t ThresholdSignature::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.ThresholdSignature)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.SignatureList sigs = 2;
  if (this->_internal_has_sigs()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sigs_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ThresholdSignature::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ThresholdSignature::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ThresholdSignature::GetClassData() const { return &_class_data_; }


void ThresholdSignature::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ThresholdSignature*>(&to_msg);
  auto& from = static_cast<const ThresholdSignature&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.ThresholdSignature)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_sigs()) {
    _this->_internal_mutable_sigs()->::proto::SignatureList::MergeFrom(
        from._internal_sigs());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ThresholdSignature::CopyFrom(const ThresholdSignature& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.ThresholdSignature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThresholdSignature::IsInitialized() const {
  return true;
}

void ThresholdSignature::InternalSwap(ThresholdSignature* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.sigs_, other->_impl_.sigs_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ThresholdSignature::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[18]);
}

// ===================================================================

class SignatureList::_Internal {
 public:
};

SignatureList::SignatureList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.SignatureList)
}
SignatureList::SignatureList(const SignatureList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SignatureList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.sigs_){from._impl_.sigs_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.SignatureList)
}

inline void SignatureList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.sigs_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SignatureList::~SignatureList() {
  // @@protoc_insertion_point(destructor:proto.SignatureList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SignatureList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sigs_.~RepeatedPtrField();
}

void SignatureList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SignatureList::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.SignatureList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sigs_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SignatureList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.Signature sigs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sigs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SignatureList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.SignatureList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.Signature sigs = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sigs_size()); i < n; i++) {
    const auto& repfield = this->_internal_sigs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.SignatureList)
  return target;
}

size_t SignatureList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.SignatureList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.Signature sigs = 2;
  total_size += 1UL * this->_internal_sigs_size();
  for (const auto& msg : this->_impl_.sigs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SignatureList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SignatureList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SignatureList::GetClassData() const { return &_class_data_; }


void SignatureList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SignatureList*>(&to_msg);
  auto& from = static_cast<const SignatureList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.SignatureList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.sigs_.MergeFrom(from._impl_.sigs_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SignatureList::CopyFrom(const SignatureList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.SignatureList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignatureList::IsInitialized() const {
  return true;
}

void SignatureList::InternalSwap(SignatureList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.sigs_.InternalSwap(&other->_impl_.sigs_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SignatureList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[19]);
}

// ===================================================================

class SignaturePair::_Internal {
 public:
};

SignaturePair::SignaturePair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.SignaturePair)
}
SignaturePair::SignaturePair(const SignaturePair& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SignaturePair* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pubkeyprefix_){}
    , decltype(_impl_.signature_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.pubkeyprefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pubkeyprefix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_pubkeyprefix().empty()) {
    _this->_impl_.pubkeyprefix_.Set(from._internal_pubkeyprefix(), 
      _this->GetArenaForAllocation());
  }
  clear_has_signature();
  switch (from.signature_case()) {
    case kContract: {
      _this->_internal_set_contract(from._internal_contract());
      break;
    }
    case kEd25519: {
      _this->_internal_set_ed25519(from._internal_ed25519());
      break;
    }
    case kRSA3072: {
      _this->_internal_set_rsa_3072(from._internal_rsa_3072());
      break;
    }
    case kECDSA384: {
      _this->_internal_set_ecdsa_384(from._internal_ecdsa_384());
      break;
    }
    case kECDSASecp256K1: {
      _this->_internal_set_ecdsa_secp256k1(from._internal_ecdsa_secp256k1());
      break;
    }
    case SIGNATURE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:proto.SignaturePair)
}

inline void SignaturePair::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pubkeyprefix_){}
    , decltype(_impl_.signature_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.pubkeyprefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pubkeyprefix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_signature();
}

SignaturePair::~SignaturePair() {
  // @@protoc_insertion_point(destructor:proto.SignaturePair)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SignaturePair::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pubkeyprefix_.Destroy();
  if (has_signature()) {
    clear_signature();
  }
}

void SignaturePair::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SignaturePair::clear_signature() {
// @@protoc_insertion_point(one_of_clear_start:proto.SignaturePair)
  switch (signature_case()) {
    case kContract: {
      _impl_.signature_.contract_.Destroy();
      break;
    }
    case kEd25519: {
      _impl_.signature_.ed25519_.Destroy();
      break;
    }
    case kRSA3072: {
      _impl_.signature_.rsa_3072_.Destroy();
      break;
    }
    case kECDSA384: {
      _impl_.signature_.ecdsa_384_.Destroy();
      break;
    }
    case kECDSASecp256K1: {
      _impl_.signature_.ecdsa_secp256k1_.Destroy();
      break;
    }
    case SIGNATURE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SIGNATURE_NOT_SET;
}


void SignaturePair::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.SignaturePair)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pubkeyprefix_.ClearToEmpty();
  clear_signature();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SignaturePair::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes pubKeyPrefix = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_pubkeyprefix();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes contract = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_contract();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes ed25519 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ed25519();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes RSA_3072 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_rsa_3072();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes ECDSA_384 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_ecdsa_384();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes ECDSA_secp256k1 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_ecdsa_secp256k1();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SignaturePair::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.SignaturePair)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes pubKeyPrefix = 1;
  if (!this->_internal_pubkeyprefix().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_pubkeyprefix(), target);
  }

  // bytes contract = 2;
  if (_internal_has_contract()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_contract(), target);
  }

  // bytes ed25519 = 3;
  if (_internal_has_ed25519()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_ed25519(), target);
  }

  // bytes RSA_3072 = 4;
  if (_internal_has_rsa_3072()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_rsa_3072(), target);
  }

  // bytes ECDSA_384 = 5;
  if (_internal_has_ecdsa_384()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_ecdsa_384(), target);
  }

  // bytes ECDSA_secp256k1 = 6;
  if (_internal_has_ecdsa_secp256k1()) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_ecdsa_secp256k1(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.SignaturePair)
  return target;
}

size_t SignaturePair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.SignaturePair)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes pubKeyPrefix = 1;
  if (!this->_internal_pubkeyprefix().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_pubkeyprefix());
  }

  switch (signature_case()) {
    // bytes contract = 2;
    case kContract: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_contract());
      break;
    }
    // bytes ed25519 = 3;
    case kEd25519: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ed25519());
      break;
    }
    // bytes RSA_3072 = 4;
    case kRSA3072: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_rsa_3072());
      break;
    }
    // bytes ECDSA_384 = 5;
    case kECDSA384: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ecdsa_384());
      break;
    }
    // bytes ECDSA_secp256k1 = 6;
    case kECDSASecp256K1: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ecdsa_secp256k1());
      break;
    }
    case SIGNATURE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SignaturePair::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SignaturePair::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SignaturePair::GetClassData() const { return &_class_data_; }


void SignaturePair::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SignaturePair*>(&to_msg);
  auto& from = static_cast<const SignaturePair&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.SignaturePair)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_pubkeyprefix().empty()) {
    _this->_internal_set_pubkeyprefix(from._internal_pubkeyprefix());
  }
  switch (from.signature_case()) {
    case kContract: {
      _this->_internal_set_contract(from._internal_contract());
      break;
    }
    case kEd25519: {
      _this->_internal_set_ed25519(from._internal_ed25519());
      break;
    }
    case kRSA3072: {
      _this->_internal_set_rsa_3072(from._internal_rsa_3072());
      break;
    }
    case kECDSA384: {
      _this->_internal_set_ecdsa_384(from._internal_ecdsa_384());
      break;
    }
    case kECDSASecp256K1: {
      _this->_internal_set_ecdsa_secp256k1(from._internal_ecdsa_secp256k1());
      break;
    }
    case SIGNATURE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SignaturePair::CopyFrom(const SignaturePair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.SignaturePair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignaturePair::IsInitialized() const {
  return true;
}

void SignaturePair::InternalSwap(SignaturePair* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pubkeyprefix_, lhs_arena,
      &other->_impl_.pubkeyprefix_, rhs_arena
  );
  swap(_impl_.signature_, other->_impl_.signature_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SignaturePair::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[20]);
}

// ===================================================================

class SignatureMap::_Internal {
 public:
};

SignatureMap::SignatureMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.SignatureMap)
}
SignatureMap::SignatureMap(const SignatureMap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SignatureMap* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.sigpair_){from._impl_.sigpair_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.SignatureMap)
}

inline void SignatureMap::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.sigpair_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SignatureMap::~SignatureMap() {
  // @@protoc_insertion_point(destructor:proto.SignatureMap)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SignatureMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sigpair_.~RepeatedPtrField();
}

void SignatureMap::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SignatureMap::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.SignatureMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sigpair_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SignatureMap::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.SignaturePair sigPair = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sigpair(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SignatureMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.SignatureMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.SignaturePair sigPair = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sigpair_size()); i < n; i++) {
    const auto& repfield = this->_internal_sigpair(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.SignatureMap)
  return target;
}

size_t SignatureMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.SignatureMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.SignaturePair sigPair = 1;
  total_size += 1UL * this->_internal_sigpair_size();
  for (const auto& msg : this->_impl_.sigpair_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SignatureMap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SignatureMap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SignatureMap::GetClassData() const { return &_class_data_; }


void SignatureMap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SignatureMap*>(&to_msg);
  auto& from = static_cast<const SignatureMap&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.SignatureMap)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.sigpair_.MergeFrom(from._impl_.sigpair_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SignatureMap::CopyFrom(const SignatureMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.SignatureMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignatureMap::IsInitialized() const {
  return true;
}

void SignatureMap::InternalSwap(SignatureMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.sigpair_.InternalSwap(&other->_impl_.sigpair_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SignatureMap::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[21]);
}

// ===================================================================

class FeeComponents::_Internal {
 public:
};

FeeComponents::FeeComponents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.FeeComponents)
}
FeeComponents::FeeComponents(const FeeComponents& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FeeComponents* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.min_){}
    , decltype(_impl_.max_){}
    , decltype(_impl_.constant_){}
    , decltype(_impl_.bpt_){}
    , decltype(_impl_.vpt_){}
    , decltype(_impl_.rbh_){}
    , decltype(_impl_.sbh_){}
    , decltype(_impl_.gas_){}
    , decltype(_impl_.tv_){}
    , decltype(_impl_.bpr_){}
    , decltype(_impl_.sbpr_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.min_, &from._impl_.min_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sbpr_) -
    reinterpret_cast<char*>(&_impl_.min_)) + sizeof(_impl_.sbpr_));
  // @@protoc_insertion_point(copy_constructor:proto.FeeComponents)
}

inline void FeeComponents::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.min_){int64_t{0}}
    , decltype(_impl_.max_){int64_t{0}}
    , decltype(_impl_.constant_){int64_t{0}}
    , decltype(_impl_.bpt_){int64_t{0}}
    , decltype(_impl_.vpt_){int64_t{0}}
    , decltype(_impl_.rbh_){int64_t{0}}
    , decltype(_impl_.sbh_){int64_t{0}}
    , decltype(_impl_.gas_){int64_t{0}}
    , decltype(_impl_.tv_){int64_t{0}}
    , decltype(_impl_.bpr_){int64_t{0}}
    , decltype(_impl_.sbpr_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FeeComponents::~FeeComponents() {
  // @@protoc_insertion_point(destructor:proto.FeeComponents)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FeeComponents::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FeeComponents::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FeeComponents::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.FeeComponents)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.min_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.sbpr_) -
      reinterpret_cast<char*>(&_impl_.min_)) + sizeof(_impl_.sbpr_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FeeComponents::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 min = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.min_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 max = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 constant = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.constant_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 bpt = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.bpt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 vpt = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.vpt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 rbh = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.rbh_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 sbh = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.sbh_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 gas = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.gas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 tv = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.tv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 bpr = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.bpr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 sbpr = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.sbpr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FeeComponents::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.FeeComponents)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 min = 1;
  if (this->_internal_min() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_min(), target);
  }

  // int64 max = 2;
  if (this->_internal_max() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_max(), target);
  }

  // int64 constant = 3;
  if (this->_internal_constant() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_constant(), target);
  }

  // int64 bpt = 4;
  if (this->_internal_bpt() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_bpt(), target);
  }

  // int64 vpt = 5;
  if (this->_internal_vpt() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_vpt(), target);
  }

  // int64 rbh = 6;
  if (this->_internal_rbh() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_rbh(), target);
  }

  // int64 sbh = 7;
  if (this->_internal_sbh() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_sbh(), target);
  }

  // int64 gas = 8;
  if (this->_internal_gas() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_gas(), target);
  }

  // int64 tv = 9;
  if (this->_internal_tv() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(9, this->_internal_tv(), target);
  }

  // int64 bpr = 10;
  if (this->_internal_bpr() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(10, this->_internal_bpr(), target);
  }

  // int64 sbpr = 11;
  if (this->_internal_sbpr() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(11, this->_internal_sbpr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.FeeComponents)
  return target;
}

size_t FeeComponents::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.FeeComponents)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 min = 1;
  if (this->_internal_min() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_min());
  }

  // int64 max = 2;
  if (this->_internal_max() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_max());
  }

  // int64 constant = 3;
  if (this->_internal_constant() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_constant());
  }

  // int64 bpt = 4;
  if (this->_internal_bpt() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_bpt());
  }

  // int64 vpt = 5;
  if (this->_internal_vpt() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_vpt());
  }

  // int64 rbh = 6;
  if (this->_internal_rbh() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_rbh());
  }

  // int64 sbh = 7;
  if (this->_internal_sbh() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_sbh());
  }

  // int64 gas = 8;
  if (this->_internal_gas() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_gas());
  }

  // int64 tv = 9;
  if (this->_internal_tv() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_tv());
  }

  // int64 bpr = 10;
  if (this->_internal_bpr() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_bpr());
  }

  // int64 sbpr = 11;
  if (this->_internal_sbpr() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_sbpr());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FeeComponents::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FeeComponents::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FeeComponents::GetClassData() const { return &_class_data_; }


void FeeComponents::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FeeComponents*>(&to_msg);
  auto& from = static_cast<const FeeComponents&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.FeeComponents)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_min() != 0) {
    _this->_internal_set_min(from._internal_min());
  }
  if (from._internal_max() != 0) {
    _this->_internal_set_max(from._internal_max());
  }
  if (from._internal_constant() != 0) {
    _this->_internal_set_constant(from._internal_constant());
  }
  if (from._internal_bpt() != 0) {
    _this->_internal_set_bpt(from._internal_bpt());
  }
  if (from._internal_vpt() != 0) {
    _this->_internal_set_vpt(from._internal_vpt());
  }
  if (from._internal_rbh() != 0) {
    _this->_internal_set_rbh(from._internal_rbh());
  }
  if (from._internal_sbh() != 0) {
    _this->_internal_set_sbh(from._internal_sbh());
  }
  if (from._internal_gas() != 0) {
    _this->_internal_set_gas(from._internal_gas());
  }
  if (from._internal_tv() != 0) {
    _this->_internal_set_tv(from._internal_tv());
  }
  if (from._internal_bpr() != 0) {
    _this->_internal_set_bpr(from._internal_bpr());
  }
  if (from._internal_sbpr() != 0) {
    _this->_internal_set_sbpr(from._internal_sbpr());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FeeComponents::CopyFrom(const FeeComponents& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.FeeComponents)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeeComponents::IsInitialized() const {
  return true;
}

void FeeComponents::InternalSwap(FeeComponents* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FeeComponents, _impl_.sbpr_)
      + sizeof(FeeComponents::_impl_.sbpr_)
      - PROTOBUF_FIELD_OFFSET(FeeComponents, _impl_.min_)>(
          reinterpret_cast<char*>(&_impl_.min_),
          reinterpret_cast<char*>(&other->_impl_.min_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FeeComponents::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[22]);
}

// ===================================================================

class TransactionFeeSchedule::_Internal {
 public:
  static const ::proto::FeeData& feedata(const TransactionFeeSchedule* msg);
};

const ::proto::FeeData&
TransactionFeeSchedule::_Internal::feedata(const TransactionFeeSchedule* msg) {
  return *msg->_impl_.feedata_;
}
TransactionFeeSchedule::TransactionFeeSchedule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.TransactionFeeSchedule)
}
TransactionFeeSchedule::TransactionFeeSchedule(const TransactionFeeSchedule& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TransactionFeeSchedule* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.fees_){from._impl_.fees_}
    , decltype(_impl_.feedata_){nullptr}
    , decltype(_impl_.hederafunctionality_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_feedata()) {
    _this->_impl_.feedata_ = new ::proto::FeeData(*from._impl_.feedata_);
  }
  _this->_impl_.hederafunctionality_ = from._impl_.hederafunctionality_;
  // @@protoc_insertion_point(copy_constructor:proto.TransactionFeeSchedule)
}

inline void TransactionFeeSchedule::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.fees_){arena}
    , decltype(_impl_.feedata_){nullptr}
    , decltype(_impl_.hederafunctionality_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TransactionFeeSchedule::~TransactionFeeSchedule() {
  // @@protoc_insertion_point(destructor:proto.TransactionFeeSchedule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TransactionFeeSchedule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.fees_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.feedata_;
}

void TransactionFeeSchedule::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TransactionFeeSchedule::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.TransactionFeeSchedule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.fees_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.feedata_ != nullptr) {
    delete _impl_.feedata_;
  }
  _impl_.feedata_ = nullptr;
  _impl_.hederafunctionality_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TransactionFeeSchedule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.HederaFunctionality hederaFunctionality = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_hederafunctionality(static_cast<::proto::HederaFunctionality>(val));
        } else
          goto handle_unusual;
        continue;
      // .proto.FeeData feeData = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_feedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .proto.FeeData fees = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fees(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TransactionFeeSchedule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.TransactionFeeSchedule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.HederaFunctionality hederaFunctionality = 1;
  if (this->_internal_hederafunctionality() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_hederafunctionality(), target);
  }

  // .proto.FeeData feeData = 2 [deprecated = true];
  if (this->_internal_has_feedata()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::feedata(this),
        _Internal::feedata(this).GetCachedSize(), target, stream);
  }

  // repeated .proto.FeeData fees = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fees_size()); i < n; i++) {
    const auto& repfield = this->_internal_fees(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.TransactionFeeSchedule)
  return target;
}

size_t TransactionFeeSchedule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.TransactionFeeSchedule)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.FeeData fees = 3;
  total_size += 1UL * this->_internal_fees_size();
  for (const auto& msg : this->_impl_.fees_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .proto.FeeData feeData = 2 [deprecated = true];
  if (this->_internal_has_feedata()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.feedata_);
  }

  // .proto.HederaFunctionality hederaFunctionality = 1;
  if (this->_internal_hederafunctionality() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_hederafunctionality());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TransactionFeeSchedule::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TransactionFeeSchedule::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TransactionFeeSchedule::GetClassData() const { return &_class_data_; }


void TransactionFeeSchedule::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TransactionFeeSchedule*>(&to_msg);
  auto& from = static_cast<const TransactionFeeSchedule&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.TransactionFeeSchedule)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.fees_.MergeFrom(from._impl_.fees_);
  if (from._internal_has_feedata()) {
    _this->_internal_mutable_feedata()->::proto::FeeData::MergeFrom(
        from._internal_feedata());
  }
  if (from._internal_hederafunctionality() != 0) {
    _this->_internal_set_hederafunctionality(from._internal_hederafunctionality());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TransactionFeeSchedule::CopyFrom(const TransactionFeeSchedule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.TransactionFeeSchedule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionFeeSchedule::IsInitialized() const {
  return true;
}

void TransactionFeeSchedule::InternalSwap(TransactionFeeSchedule* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.fees_.InternalSwap(&other->_impl_.fees_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TransactionFeeSchedule, _impl_.hederafunctionality_)
      + sizeof(TransactionFeeSchedule::_impl_.hederafunctionality_)
      - PROTOBUF_FIELD_OFFSET(TransactionFeeSchedule, _impl_.feedata_)>(
          reinterpret_cast<char*>(&_impl_.feedata_),
          reinterpret_cast<char*>(&other->_impl_.feedata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TransactionFeeSchedule::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[23]);
}

// ===================================================================

class FeeData::_Internal {
 public:
  static const ::proto::FeeComponents& nodedata(const FeeData* msg);
  static const ::proto::FeeComponents& networkdata(const FeeData* msg);
  static const ::proto::FeeComponents& servicedata(const FeeData* msg);
};

const ::proto::FeeComponents&
FeeData::_Internal::nodedata(const FeeData* msg) {
  return *msg->_impl_.nodedata_;
}
const ::proto::FeeComponents&
FeeData::_Internal::networkdata(const FeeData* msg) {
  return *msg->_impl_.networkdata_;
}
const ::proto::FeeComponents&
FeeData::_Internal::servicedata(const FeeData* msg) {
  return *msg->_impl_.servicedata_;
}
FeeData::FeeData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.FeeData)
}
FeeData::FeeData(const FeeData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FeeData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nodedata_){nullptr}
    , decltype(_impl_.networkdata_){nullptr}
    , decltype(_impl_.servicedata_){nullptr}
    , decltype(_impl_.subtype_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_nodedata()) {
    _this->_impl_.nodedata_ = new ::proto::FeeComponents(*from._impl_.nodedata_);
  }
  if (from._internal_has_networkdata()) {
    _this->_impl_.networkdata_ = new ::proto::FeeComponents(*from._impl_.networkdata_);
  }
  if (from._internal_has_servicedata()) {
    _this->_impl_.servicedata_ = new ::proto::FeeComponents(*from._impl_.servicedata_);
  }
  _this->_impl_.subtype_ = from._impl_.subtype_;
  // @@protoc_insertion_point(copy_constructor:proto.FeeData)
}

inline void FeeData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nodedata_){nullptr}
    , decltype(_impl_.networkdata_){nullptr}
    , decltype(_impl_.servicedata_){nullptr}
    , decltype(_impl_.subtype_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FeeData::~FeeData() {
  // @@protoc_insertion_point(destructor:proto.FeeData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FeeData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.nodedata_;
  if (this != internal_default_instance()) delete _impl_.networkdata_;
  if (this != internal_default_instance()) delete _impl_.servicedata_;
}

void FeeData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FeeData::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.FeeData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.nodedata_ != nullptr) {
    delete _impl_.nodedata_;
  }
  _impl_.nodedata_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.networkdata_ != nullptr) {
    delete _impl_.networkdata_;
  }
  _impl_.networkdata_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.servicedata_ != nullptr) {
    delete _impl_.servicedata_;
  }
  _impl_.servicedata_ = nullptr;
  _impl_.subtype_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FeeData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.FeeComponents nodedata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nodedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.FeeComponents networkdata = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_networkdata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.FeeComponents servicedata = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_servicedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.SubType subType = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_subtype(static_cast<::proto::SubType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FeeData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.FeeData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.FeeComponents nodedata = 1;
  if (this->_internal_has_nodedata()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::nodedata(this),
        _Internal::nodedata(this).GetCachedSize(), target, stream);
  }

  // .proto.FeeComponents networkdata = 2;
  if (this->_internal_has_networkdata()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::networkdata(this),
        _Internal::networkdata(this).GetCachedSize(), target, stream);
  }

  // .proto.FeeComponents servicedata = 3;
  if (this->_internal_has_servicedata()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::servicedata(this),
        _Internal::servicedata(this).GetCachedSize(), target, stream);
  }

  // .proto.SubType subType = 4;
  if (this->_internal_subtype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_subtype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.FeeData)
  return target;
}

size_t FeeData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.FeeData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.FeeComponents nodedata = 1;
  if (this->_internal_has_nodedata()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nodedata_);
  }

  // .proto.FeeComponents networkdata = 2;
  if (this->_internal_has_networkdata()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.networkdata_);
  }

  // .proto.FeeComponents servicedata = 3;
  if (this->_internal_has_servicedata()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.servicedata_);
  }

  // .proto.SubType subType = 4;
  if (this->_internal_subtype() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_subtype());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FeeData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FeeData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FeeData::GetClassData() const { return &_class_data_; }


void FeeData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FeeData*>(&to_msg);
  auto& from = static_cast<const FeeData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.FeeData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_nodedata()) {
    _this->_internal_mutable_nodedata()->::proto::FeeComponents::MergeFrom(
        from._internal_nodedata());
  }
  if (from._internal_has_networkdata()) {
    _this->_internal_mutable_networkdata()->::proto::FeeComponents::MergeFrom(
        from._internal_networkdata());
  }
  if (from._internal_has_servicedata()) {
    _this->_internal_mutable_servicedata()->::proto::FeeComponents::MergeFrom(
        from._internal_servicedata());
  }
  if (from._internal_subtype() != 0) {
    _this->_internal_set_subtype(from._internal_subtype());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FeeData::CopyFrom(const FeeData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.FeeData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeeData::IsInitialized() const {
  return true;
}

void FeeData::InternalSwap(FeeData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FeeData, _impl_.subtype_)
      + sizeof(FeeData::_impl_.subtype_)
      - PROTOBUF_FIELD_OFFSET(FeeData, _impl_.nodedata_)>(
          reinterpret_cast<char*>(&_impl_.nodedata_),
          reinterpret_cast<char*>(&other->_impl_.nodedata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FeeData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[24]);
}

// ===================================================================

class FeeSchedule::_Internal {
 public:
  static const ::proto::TimestampSeconds& expirytime(const FeeSchedule* msg);
};

const ::proto::TimestampSeconds&
FeeSchedule::_Internal::expirytime(const FeeSchedule* msg) {
  return *msg->_impl_.expirytime_;
}
void FeeSchedule::clear_expirytime() {
  if (GetArenaForAllocation() == nullptr && _impl_.expirytime_ != nullptr) {
    delete _impl_.expirytime_;
  }
  _impl_.expirytime_ = nullptr;
}
FeeSchedule::FeeSchedule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.FeeSchedule)
}
FeeSchedule::FeeSchedule(const FeeSchedule& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FeeSchedule* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.transactionfeeschedule_){from._impl_.transactionfeeschedule_}
    , decltype(_impl_.expirytime_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_expirytime()) {
    _this->_impl_.expirytime_ = new ::proto::TimestampSeconds(*from._impl_.expirytime_);
  }
  // @@protoc_insertion_point(copy_constructor:proto.FeeSchedule)
}

inline void FeeSchedule::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.transactionfeeschedule_){arena}
    , decltype(_impl_.expirytime_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FeeSchedule::~FeeSchedule() {
  // @@protoc_insertion_point(destructor:proto.FeeSchedule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FeeSchedule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.transactionfeeschedule_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.expirytime_;
}

void FeeSchedule::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FeeSchedule::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.FeeSchedule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.transactionfeeschedule_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.expirytime_ != nullptr) {
    delete _impl_.expirytime_;
  }
  _impl_.expirytime_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FeeSchedule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.TransactionFeeSchedule transactionFeeSchedule = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_transactionfeeschedule(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .proto.TimestampSeconds expiryTime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_expirytime(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FeeSchedule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.FeeSchedule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.TransactionFeeSchedule transactionFeeSchedule = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_transactionfeeschedule_size()); i < n; i++) {
    const auto& repfield = this->_internal_transactionfeeschedule(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .proto.TimestampSeconds expiryTime = 2;
  if (this->_internal_has_expirytime()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::expirytime(this),
        _Internal::expirytime(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.FeeSchedule)
  return target;
}

size_t FeeSchedule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.FeeSchedule)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.TransactionFeeSchedule transactionFeeSchedule = 1;
  total_size += 1UL * this->_internal_transactionfeeschedule_size();
  for (const auto& msg : this->_impl_.transactionfeeschedule_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .proto.TimestampSeconds expiryTime = 2;
  if (this->_internal_has_expirytime()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.expirytime_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FeeSchedule::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FeeSchedule::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FeeSchedule::GetClassData() const { return &_class_data_; }


void FeeSchedule::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FeeSchedule*>(&to_msg);
  auto& from = static_cast<const FeeSchedule&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.FeeSchedule)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.transactionfeeschedule_.MergeFrom(from._impl_.transactionfeeschedule_);
  if (from._internal_has_expirytime()) {
    _this->_internal_mutable_expirytime()->::proto::TimestampSeconds::MergeFrom(
        from._internal_expirytime());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FeeSchedule::CopyFrom(const FeeSchedule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.FeeSchedule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeeSchedule::IsInitialized() const {
  return true;
}

void FeeSchedule::InternalSwap(FeeSchedule* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.transactionfeeschedule_.InternalSwap(&other->_impl_.transactionfeeschedule_);
  swap(_impl_.expirytime_, other->_impl_.expirytime_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FeeSchedule::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[25]);
}

// ===================================================================

class CurrentAndNextFeeSchedule::_Internal {
 public:
  static const ::proto::FeeSchedule& currentfeeschedule(const CurrentAndNextFeeSchedule* msg);
  static const ::proto::FeeSchedule& nextfeeschedule(const CurrentAndNextFeeSchedule* msg);
};

const ::proto::FeeSchedule&
CurrentAndNextFeeSchedule::_Internal::currentfeeschedule(const CurrentAndNextFeeSchedule* msg) {
  return *msg->_impl_.currentfeeschedule_;
}
const ::proto::FeeSchedule&
CurrentAndNextFeeSchedule::_Internal::nextfeeschedule(const CurrentAndNextFeeSchedule* msg) {
  return *msg->_impl_.nextfeeschedule_;
}
CurrentAndNextFeeSchedule::CurrentAndNextFeeSchedule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.CurrentAndNextFeeSchedule)
}
CurrentAndNextFeeSchedule::CurrentAndNextFeeSchedule(const CurrentAndNextFeeSchedule& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CurrentAndNextFeeSchedule* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.currentfeeschedule_){nullptr}
    , decltype(_impl_.nextfeeschedule_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_currentfeeschedule()) {
    _this->_impl_.currentfeeschedule_ = new ::proto::FeeSchedule(*from._impl_.currentfeeschedule_);
  }
  if (from._internal_has_nextfeeschedule()) {
    _this->_impl_.nextfeeschedule_ = new ::proto::FeeSchedule(*from._impl_.nextfeeschedule_);
  }
  // @@protoc_insertion_point(copy_constructor:proto.CurrentAndNextFeeSchedule)
}

inline void CurrentAndNextFeeSchedule::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.currentfeeschedule_){nullptr}
    , decltype(_impl_.nextfeeschedule_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CurrentAndNextFeeSchedule::~CurrentAndNextFeeSchedule() {
  // @@protoc_insertion_point(destructor:proto.CurrentAndNextFeeSchedule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CurrentAndNextFeeSchedule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.currentfeeschedule_;
  if (this != internal_default_instance()) delete _impl_.nextfeeschedule_;
}

void CurrentAndNextFeeSchedule::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CurrentAndNextFeeSchedule::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.CurrentAndNextFeeSchedule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.currentfeeschedule_ != nullptr) {
    delete _impl_.currentfeeschedule_;
  }
  _impl_.currentfeeschedule_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.nextfeeschedule_ != nullptr) {
    delete _impl_.nextfeeschedule_;
  }
  _impl_.nextfeeschedule_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CurrentAndNextFeeSchedule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.FeeSchedule currentFeeSchedule = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_currentfeeschedule(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.FeeSchedule nextFeeSchedule = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextfeeschedule(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CurrentAndNextFeeSchedule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.CurrentAndNextFeeSchedule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.FeeSchedule currentFeeSchedule = 1;
  if (this->_internal_has_currentfeeschedule()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::currentfeeschedule(this),
        _Internal::currentfeeschedule(this).GetCachedSize(), target, stream);
  }

  // .proto.FeeSchedule nextFeeSchedule = 2;
  if (this->_internal_has_nextfeeschedule()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::nextfeeschedule(this),
        _Internal::nextfeeschedule(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.CurrentAndNextFeeSchedule)
  return target;
}

size_t CurrentAndNextFeeSchedule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.CurrentAndNextFeeSchedule)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.FeeSchedule currentFeeSchedule = 1;
  if (this->_internal_has_currentfeeschedule()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.currentfeeschedule_);
  }

  // .proto.FeeSchedule nextFeeSchedule = 2;
  if (this->_internal_has_nextfeeschedule()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nextfeeschedule_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CurrentAndNextFeeSchedule::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CurrentAndNextFeeSchedule::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CurrentAndNextFeeSchedule::GetClassData() const { return &_class_data_; }


void CurrentAndNextFeeSchedule::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CurrentAndNextFeeSchedule*>(&to_msg);
  auto& from = static_cast<const CurrentAndNextFeeSchedule&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.CurrentAndNextFeeSchedule)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_currentfeeschedule()) {
    _this->_internal_mutable_currentfeeschedule()->::proto::FeeSchedule::MergeFrom(
        from._internal_currentfeeschedule());
  }
  if (from._internal_has_nextfeeschedule()) {
    _this->_internal_mutable_nextfeeschedule()->::proto::FeeSchedule::MergeFrom(
        from._internal_nextfeeschedule());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CurrentAndNextFeeSchedule::CopyFrom(const CurrentAndNextFeeSchedule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.CurrentAndNextFeeSchedule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CurrentAndNextFeeSchedule::IsInitialized() const {
  return true;
}

void CurrentAndNextFeeSchedule::InternalSwap(CurrentAndNextFeeSchedule* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CurrentAndNextFeeSchedule, _impl_.nextfeeschedule_)
      + sizeof(CurrentAndNextFeeSchedule::_impl_.nextfeeschedule_)
      - PROTOBUF_FIELD_OFFSET(CurrentAndNextFeeSchedule, _impl_.currentfeeschedule_)>(
          reinterpret_cast<char*>(&_impl_.currentfeeschedule_),
          reinterpret_cast<char*>(&other->_impl_.currentfeeschedule_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CurrentAndNextFeeSchedule::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[26]);
}

// ===================================================================

class ServiceEndpoint::_Internal {
 public:
};

ServiceEndpoint::ServiceEndpoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.ServiceEndpoint)
}
ServiceEndpoint::ServiceEndpoint(const ServiceEndpoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ServiceEndpoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ipaddressv4_){}
    , decltype(_impl_.port_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ipaddressv4_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ipaddressv4_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ipaddressv4().empty()) {
    _this->_impl_.ipaddressv4_.Set(from._internal_ipaddressv4(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.port_ = from._impl_.port_;
  // @@protoc_insertion_point(copy_constructor:proto.ServiceEndpoint)
}

inline void ServiceEndpoint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ipaddressv4_){}
    , decltype(_impl_.port_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.ipaddressv4_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ipaddressv4_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ServiceEndpoint::~ServiceEndpoint() {
  // @@protoc_insertion_point(destructor:proto.ServiceEndpoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServiceEndpoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ipaddressv4_.Destroy();
}

void ServiceEndpoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServiceEndpoint::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.ServiceEndpoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ipaddressv4_.ClearToEmpty();
  _impl_.port_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServiceEndpoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes ipAddressV4 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ipaddressv4();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServiceEndpoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.ServiceEndpoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes ipAddressV4 = 1;
  if (!this->_internal_ipaddressv4().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_ipaddressv4(), target);
  }

  // int32 port = 2;
  if (this->_internal_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.ServiceEndpoint)
  return target;
}

size_t ServiceEndpoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.ServiceEndpoint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes ipAddressV4 = 1;
  if (!this->_internal_ipaddressv4().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ipaddressv4());
  }

  // int32 port = 2;
  if (this->_internal_port() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_port());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServiceEndpoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ServiceEndpoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServiceEndpoint::GetClassData() const { return &_class_data_; }


void ServiceEndpoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ServiceEndpoint*>(&to_msg);
  auto& from = static_cast<const ServiceEndpoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.ServiceEndpoint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_ipaddressv4().empty()) {
    _this->_internal_set_ipaddressv4(from._internal_ipaddressv4());
  }
  if (from._internal_port() != 0) {
    _this->_internal_set_port(from._internal_port());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServiceEndpoint::CopyFrom(const ServiceEndpoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.ServiceEndpoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceEndpoint::IsInitialized() const {
  return true;
}

void ServiceEndpoint::InternalSwap(ServiceEndpoint* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ipaddressv4_, lhs_arena,
      &other->_impl_.ipaddressv4_, rhs_arena
  );
  swap(_impl_.port_, other->_impl_.port_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ServiceEndpoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[27]);
}

// ===================================================================

class NodeAddress::_Internal {
 public:
  static const ::proto::AccountID& nodeaccountid(const NodeAddress* msg);
};

const ::proto::AccountID&
NodeAddress::_Internal::nodeaccountid(const NodeAddress* msg) {
  return *msg->_impl_.nodeaccountid_;
}
NodeAddress::NodeAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.NodeAddress)
}
NodeAddress::NodeAddress(const NodeAddress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NodeAddress* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.serviceendpoint_){from._impl_.serviceendpoint_}
    , decltype(_impl_.ipaddress_){}
    , decltype(_impl_.memo_){}
    , decltype(_impl_.rsa_pubkey_){}
    , decltype(_impl_.nodecerthash_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.nodeaccountid_){nullptr}
    , decltype(_impl_.nodeid_){}
    , decltype(_impl_.stake_){}
    , decltype(_impl_.portno_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ipaddress_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ipaddress_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ipaddress().empty()) {
    _this->_impl_.ipaddress_.Set(from._internal_ipaddress(), 
      _this->GetArenaForAllocation());
  }
  _impl_.memo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.memo_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_memo().empty()) {
    _this->_impl_.memo_.Set(from._internal_memo(), 
      _this->GetArenaForAllocation());
  }
  _impl_.rsa_pubkey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rsa_pubkey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_rsa_pubkey().empty()) {
    _this->_impl_.rsa_pubkey_.Set(from._internal_rsa_pubkey(), 
      _this->GetArenaForAllocation());
  }
  _impl_.nodecerthash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodecerthash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nodecerthash().empty()) {
    _this->_impl_.nodecerthash_.Set(from._internal_nodecerthash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_nodeaccountid()) {
    _this->_impl_.nodeaccountid_ = new ::proto::AccountID(*from._impl_.nodeaccountid_);
  }
  ::memcpy(&_impl_.nodeid_, &from._impl_.nodeid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.portno_) -
    reinterpret_cast<char*>(&_impl_.nodeid_)) + sizeof(_impl_.portno_));
  // @@protoc_insertion_point(copy_constructor:proto.NodeAddress)
}

inline void NodeAddress::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.serviceendpoint_){arena}
    , decltype(_impl_.ipaddress_){}
    , decltype(_impl_.memo_){}
    , decltype(_impl_.rsa_pubkey_){}
    , decltype(_impl_.nodecerthash_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.nodeaccountid_){nullptr}
    , decltype(_impl_.nodeid_){int64_t{0}}
    , decltype(_impl_.stake_){int64_t{0}}
    , decltype(_impl_.portno_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.ipaddress_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ipaddress_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.memo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.memo_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rsa_pubkey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rsa_pubkey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nodecerthash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodecerthash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NodeAddress::~NodeAddress() {
  // @@protoc_insertion_point(destructor:proto.NodeAddress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeAddress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.serviceendpoint_.~RepeatedPtrField();
  _impl_.ipaddress_.Destroy();
  _impl_.memo_.Destroy();
  _impl_.rsa_pubkey_.Destroy();
  _impl_.nodecerthash_.Destroy();
  _impl_.description_.Destroy();
  if (this != internal_default_instance()) delete _impl_.nodeaccountid_;
}

void NodeAddress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NodeAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.NodeAddress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.serviceendpoint_.Clear();
  _impl_.ipaddress_.ClearToEmpty();
  _impl_.memo_.ClearToEmpty();
  _impl_.rsa_pubkey_.ClearToEmpty();
  _impl_.nodecerthash_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.nodeaccountid_ != nullptr) {
    delete _impl_.nodeaccountid_;
  }
  _impl_.nodeaccountid_ = nullptr;
  ::memset(&_impl_.nodeid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.portno_) -
      reinterpret_cast<char*>(&_impl_.nodeid_)) + sizeof(_impl_.portno_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeAddress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes ipAddress = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ipaddress();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 portno = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.portno_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes memo = 3 [deprecated = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_memo();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string RSA_PubKey = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_rsa_pubkey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "proto.NodeAddress.RSA_PubKey"));
        } else
          goto handle_unusual;
        continue;
      // int64 nodeId = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.nodeid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.AccountID nodeAccountId = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_nodeaccountid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes nodeCertHash = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_nodecerthash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .proto.ServiceEndpoint serviceEndpoint = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_serviceendpoint(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string description = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "proto.NodeAddress.description"));
        } else
          goto handle_unusual;
        continue;
      // int64 stake = 10 [deprecated = true];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.stake_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeAddress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.NodeAddress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes ipAddress = 1 [deprecated = true];
  if (!this->_internal_ipaddress().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_ipaddress(), target);
  }

  // int32 portno = 2 [deprecated = true];
  if (this->_internal_portno() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_portno(), target);
  }

  // bytes memo = 3 [deprecated = true];
  if (!this->_internal_memo().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_memo(), target);
  }

  // string RSA_PubKey = 4;
  if (!this->_internal_rsa_pubkey().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_rsa_pubkey().data(), static_cast<int>(this->_internal_rsa_pubkey().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.NodeAddress.RSA_PubKey");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_rsa_pubkey(), target);
  }

  // int64 nodeId = 5;
  if (this->_internal_nodeid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_nodeid(), target);
  }

  // .proto.AccountID nodeAccountId = 6;
  if (this->_internal_has_nodeaccountid()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::nodeaccountid(this),
        _Internal::nodeaccountid(this).GetCachedSize(), target, stream);
  }

  // bytes nodeCertHash = 7;
  if (!this->_internal_nodecerthash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_nodecerthash(), target);
  }

  // repeated .proto.ServiceEndpoint serviceEndpoint = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_serviceendpoint_size()); i < n; i++) {
    const auto& repfield = this->_internal_serviceendpoint(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string description = 9;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.NodeAddress.description");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_description(), target);
  }

  // int64 stake = 10 [deprecated = true];
  if (this->_internal_stake() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(10, this->_internal_stake(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.NodeAddress)
  return target;
}

size_t NodeAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.NodeAddress)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.ServiceEndpoint serviceEndpoint = 8;
  total_size += 1UL * this->_internal_serviceendpoint_size();
  for (const auto& msg : this->_impl_.serviceendpoint_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bytes ipAddress = 1 [deprecated = true];
  if (!this->_internal_ipaddress().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ipaddress());
  }

  // bytes memo = 3 [deprecated = true];
  if (!this->_internal_memo().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_memo());
  }

  // string RSA_PubKey = 4;
  if (!this->_internal_rsa_pubkey().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_rsa_pubkey());
  }

  // bytes nodeCertHash = 7;
  if (!this->_internal_nodecerthash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_nodecerthash());
  }

  // string description = 9;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // .proto.AccountID nodeAccountId = 6;
  if (this->_internal_has_nodeaccountid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nodeaccountid_);
  }

  // int64 nodeId = 5;
  if (this->_internal_nodeid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_nodeid());
  }

  // int64 stake = 10 [deprecated = true];
  if (this->_internal_stake() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_stake());
  }

  // int32 portno = 2 [deprecated = true];
  if (this->_internal_portno() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_portno());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeAddress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NodeAddress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeAddress::GetClassData() const { return &_class_data_; }


void NodeAddress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NodeAddress*>(&to_msg);
  auto& from = static_cast<const NodeAddress&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.NodeAddress)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.serviceendpoint_.MergeFrom(from._impl_.serviceendpoint_);
  if (!from._internal_ipaddress().empty()) {
    _this->_internal_set_ipaddress(from._internal_ipaddress());
  }
  if (!from._internal_memo().empty()) {
    _this->_internal_set_memo(from._internal_memo());
  }
  if (!from._internal_rsa_pubkey().empty()) {
    _this->_internal_set_rsa_pubkey(from._internal_rsa_pubkey());
  }
  if (!from._internal_nodecerthash().empty()) {
    _this->_internal_set_nodecerthash(from._internal_nodecerthash());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (from._internal_has_nodeaccountid()) {
    _this->_internal_mutable_nodeaccountid()->::proto::AccountID::MergeFrom(
        from._internal_nodeaccountid());
  }
  if (from._internal_nodeid() != 0) {
    _this->_internal_set_nodeid(from._internal_nodeid());
  }
  if (from._internal_stake() != 0) {
    _this->_internal_set_stake(from._internal_stake());
  }
  if (from._internal_portno() != 0) {
    _this->_internal_set_portno(from._internal_portno());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeAddress::CopyFrom(const NodeAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.NodeAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeAddress::IsInitialized() const {
  return true;
}

void NodeAddress::InternalSwap(NodeAddress* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.serviceendpoint_.InternalSwap(&other->_impl_.serviceendpoint_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ipaddress_, lhs_arena,
      &other->_impl_.ipaddress_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.memo_, lhs_arena,
      &other->_impl_.memo_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.rsa_pubkey_, lhs_arena,
      &other->_impl_.rsa_pubkey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nodecerthash_, lhs_arena,
      &other->_impl_.nodecerthash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NodeAddress, _impl_.portno_)
      + sizeof(NodeAddress::_impl_.portno_)
      - PROTOBUF_FIELD_OFFSET(NodeAddress, _impl_.nodeaccountid_)>(
          reinterpret_cast<char*>(&_impl_.nodeaccountid_),
          reinterpret_cast<char*>(&other->_impl_.nodeaccountid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeAddress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[28]);
}

// ===================================================================

class NodeAddressBook::_Internal {
 public:
};

NodeAddressBook::NodeAddressBook(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.NodeAddressBook)
}
NodeAddressBook::NodeAddressBook(const NodeAddressBook& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NodeAddressBook* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nodeaddress_){from._impl_.nodeaddress_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.NodeAddressBook)
}

inline void NodeAddressBook::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nodeaddress_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NodeAddressBook::~NodeAddressBook() {
  // @@protoc_insertion_point(destructor:proto.NodeAddressBook)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeAddressBook::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nodeaddress_.~RepeatedPtrField();
}

void NodeAddressBook::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NodeAddressBook::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.NodeAddressBook)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nodeaddress_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeAddressBook::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.NodeAddress nodeAddress = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nodeaddress(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeAddressBook::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.NodeAddressBook)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.NodeAddress nodeAddress = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nodeaddress_size()); i < n; i++) {
    const auto& repfield = this->_internal_nodeaddress(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.NodeAddressBook)
  return target;
}

size_t NodeAddressBook::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.NodeAddressBook)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.NodeAddress nodeAddress = 1;
  total_size += 1UL * this->_internal_nodeaddress_size();
  for (const auto& msg : this->_impl_.nodeaddress_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeAddressBook::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NodeAddressBook::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeAddressBook::GetClassData() const { return &_class_data_; }


void NodeAddressBook::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NodeAddressBook*>(&to_msg);
  auto& from = static_cast<const NodeAddressBook&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.NodeAddressBook)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nodeaddress_.MergeFrom(from._impl_.nodeaddress_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeAddressBook::CopyFrom(const NodeAddressBook& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.NodeAddressBook)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeAddressBook::IsInitialized() const {
  return true;
}

void NodeAddressBook::InternalSwap(NodeAddressBook* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nodeaddress_.InternalSwap(&other->_impl_.nodeaddress_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeAddressBook::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[29]);
}

// ===================================================================

class SemanticVersion::_Internal {
 public:
};

SemanticVersion::SemanticVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.SemanticVersion)
}
SemanticVersion::SemanticVersion(const SemanticVersion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SemanticVersion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pre_){}
    , decltype(_impl_.build_){}
    , decltype(_impl_.major_){}
    , decltype(_impl_.minor_){}
    , decltype(_impl_.patch_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.pre_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pre_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_pre().empty()) {
    _this->_impl_.pre_.Set(from._internal_pre(), 
      _this->GetArenaForAllocation());
  }
  _impl_.build_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.build_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_build().empty()) {
    _this->_impl_.build_.Set(from._internal_build(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.major_, &from._impl_.major_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.patch_) -
    reinterpret_cast<char*>(&_impl_.major_)) + sizeof(_impl_.patch_));
  // @@protoc_insertion_point(copy_constructor:proto.SemanticVersion)
}

inline void SemanticVersion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pre_){}
    , decltype(_impl_.build_){}
    , decltype(_impl_.major_){0}
    , decltype(_impl_.minor_){0}
    , decltype(_impl_.patch_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.pre_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pre_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.build_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.build_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SemanticVersion::~SemanticVersion() {
  // @@protoc_insertion_point(destructor:proto.SemanticVersion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SemanticVersion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pre_.Destroy();
  _impl_.build_.Destroy();
}

void SemanticVersion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SemanticVersion::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.SemanticVersion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pre_.ClearToEmpty();
  _impl_.build_.ClearToEmpty();
  ::memset(&_impl_.major_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.patch_) -
      reinterpret_cast<char*>(&_impl_.major_)) + sizeof(_impl_.patch_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SemanticVersion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 major = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.major_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 minor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.minor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 patch = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.patch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string pre = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_pre();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "proto.SemanticVersion.pre"));
        } else
          goto handle_unusual;
        continue;
      // string build = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_build();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "proto.SemanticVersion.build"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SemanticVersion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.SemanticVersion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 major = 1;
  if (this->_internal_major() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_major(), target);
  }

  // int32 minor = 2;
  if (this->_internal_minor() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_minor(), target);
  }

  // int32 patch = 3;
  if (this->_internal_patch() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_patch(), target);
  }

  // string pre = 4;
  if (!this->_internal_pre().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_pre().data(), static_cast<int>(this->_internal_pre().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.SemanticVersion.pre");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_pre(), target);
  }

  // string build = 5;
  if (!this->_internal_build().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_build().data(), static_cast<int>(this->_internal_build().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.SemanticVersion.build");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_build(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.SemanticVersion)
  return target;
}

size_t SemanticVersion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.SemanticVersion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string pre = 4;
  if (!this->_internal_pre().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_pre());
  }

  // string build = 5;
  if (!this->_internal_build().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_build());
  }

  // int32 major = 1;
  if (this->_internal_major() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_major());
  }

  // int32 minor = 2;
  if (this->_internal_minor() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_minor());
  }

  // int32 patch = 3;
  if (this->_internal_patch() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_patch());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SemanticVersion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SemanticVersion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SemanticVersion::GetClassData() const { return &_class_data_; }


void SemanticVersion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SemanticVersion*>(&to_msg);
  auto& from = static_cast<const SemanticVersion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.SemanticVersion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_pre().empty()) {
    _this->_internal_set_pre(from._internal_pre());
  }
  if (!from._internal_build().empty()) {
    _this->_internal_set_build(from._internal_build());
  }
  if (from._internal_major() != 0) {
    _this->_internal_set_major(from._internal_major());
  }
  if (from._internal_minor() != 0) {
    _this->_internal_set_minor(from._internal_minor());
  }
  if (from._internal_patch() != 0) {
    _this->_internal_set_patch(from._internal_patch());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SemanticVersion::CopyFrom(const SemanticVersion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.SemanticVersion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SemanticVersion::IsInitialized() const {
  return true;
}

void SemanticVersion::InternalSwap(SemanticVersion* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pre_, lhs_arena,
      &other->_impl_.pre_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.build_, lhs_arena,
      &other->_impl_.build_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SemanticVersion, _impl_.patch_)
      + sizeof(SemanticVersion::_impl_.patch_)
      - PROTOBUF_FIELD_OFFSET(SemanticVersion, _impl_.major_)>(
          reinterpret_cast<char*>(&_impl_.major_),
          reinterpret_cast<char*>(&other->_impl_.major_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SemanticVersion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[30]);
}

// ===================================================================

class Setting::_Internal {
 public:
};

Setting::Setting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.Setting)
}
Setting::Setting(const Setting& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Setting* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:proto.Setting)
}

inline void Setting::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Setting::~Setting() {
  // @@protoc_insertion_point(destructor:proto.Setting)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Setting::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
  _impl_.data_.Destroy();
}

void Setting::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Setting::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.Setting)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.value_.ClearToEmpty();
  _impl_.data_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Setting::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "proto.Setting.name"));
        } else
          goto handle_unusual;
        continue;
      // string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "proto.Setting.value"));
        } else
          goto handle_unusual;
        continue;
      // bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Setting::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.Setting)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.Setting.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string value = 2;
  if (!this->_internal_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.Setting.value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.Setting)
  return target;
}

size_t Setting::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.Setting)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string value = 2;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Setting::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Setting::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Setting::GetClassData() const { return &_class_data_; }


void Setting::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Setting*>(&to_msg);
  auto& from = static_cast<const Setting&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.Setting)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  if (!from._internal_data().empty()) {
    _this->_internal_set_data(from._internal_data());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Setting::CopyFrom(const Setting& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.Setting)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Setting::IsInitialized() const {
  return true;
}

void Setting::InternalSwap(Setting* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Setting::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[31]);
}

// ===================================================================

class ServicesConfigurationList::_Internal {
 public:
};

ServicesConfigurationList::ServicesConfigurationList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.ServicesConfigurationList)
}
ServicesConfigurationList::ServicesConfigurationList(const ServicesConfigurationList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ServicesConfigurationList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.namevalue_){from._impl_.namevalue_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.ServicesConfigurationList)
}

inline void ServicesConfigurationList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.namevalue_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ServicesConfigurationList::~ServicesConfigurationList() {
  // @@protoc_insertion_point(destructor:proto.ServicesConfigurationList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServicesConfigurationList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.namevalue_.~RepeatedPtrField();
}

void ServicesConfigurationList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServicesConfigurationList::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.ServicesConfigurationList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.namevalue_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServicesConfigurationList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.Setting nameValue = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_namevalue(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServicesConfigurationList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.ServicesConfigurationList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.Setting nameValue = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_namevalue_size()); i < n; i++) {
    const auto& repfield = this->_internal_namevalue(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.ServicesConfigurationList)
  return target;
}

size_t ServicesConfigurationList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.ServicesConfigurationList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.Setting nameValue = 1;
  total_size += 1UL * this->_internal_namevalue_size();
  for (const auto& msg : this->_impl_.namevalue_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServicesConfigurationList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ServicesConfigurationList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServicesConfigurationList::GetClassData() const { return &_class_data_; }


void ServicesConfigurationList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ServicesConfigurationList*>(&to_msg);
  auto& from = static_cast<const ServicesConfigurationList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.ServicesConfigurationList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.namevalue_.MergeFrom(from._impl_.namevalue_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServicesConfigurationList::CopyFrom(const ServicesConfigurationList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.ServicesConfigurationList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServicesConfigurationList::IsInitialized() const {
  return true;
}

void ServicesConfigurationList::InternalSwap(ServicesConfigurationList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.namevalue_.InternalSwap(&other->_impl_.namevalue_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ServicesConfigurationList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[32]);
}

// ===================================================================

class TokenRelationship::_Internal {
 public:
  static const ::proto::TokenID& tokenid(const TokenRelationship* msg);
};

const ::proto::TokenID&
TokenRelationship::_Internal::tokenid(const TokenRelationship* msg) {
  return *msg->_impl_.tokenid_;
}
TokenRelationship::TokenRelationship(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.TokenRelationship)
}
TokenRelationship::TokenRelationship(const TokenRelationship& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TokenRelationship* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.symbol_){}
    , decltype(_impl_.tokenid_){nullptr}
    , decltype(_impl_.balance_){}
    , decltype(_impl_.kycstatus_){}
    , decltype(_impl_.freezestatus_){}
    , decltype(_impl_.decimals_){}
    , decltype(_impl_.automatic_association_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.symbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.symbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_symbol().empty()) {
    _this->_impl_.symbol_.Set(from._internal_symbol(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_tokenid()) {
    _this->_impl_.tokenid_ = new ::proto::TokenID(*from._impl_.tokenid_);
  }
  ::memcpy(&_impl_.balance_, &from._impl_.balance_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.automatic_association_) -
    reinterpret_cast<char*>(&_impl_.balance_)) + sizeof(_impl_.automatic_association_));
  // @@protoc_insertion_point(copy_constructor:proto.TokenRelationship)
}

inline void TokenRelationship::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.symbol_){}
    , decltype(_impl_.tokenid_){nullptr}
    , decltype(_impl_.balance_){uint64_t{0u}}
    , decltype(_impl_.kycstatus_){0}
    , decltype(_impl_.freezestatus_){0}
    , decltype(_impl_.decimals_){0u}
    , decltype(_impl_.automatic_association_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.symbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.symbol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TokenRelationship::~TokenRelationship() {
  // @@protoc_insertion_point(destructor:proto.TokenRelationship)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TokenRelationship::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.symbol_.Destroy();
  if (this != internal_default_instance()) delete _impl_.tokenid_;
}

void TokenRelationship::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TokenRelationship::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.TokenRelationship)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.symbol_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.tokenid_ != nullptr) {
    delete _impl_.tokenid_;
  }
  _impl_.tokenid_ = nullptr;
  ::memset(&_impl_.balance_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.automatic_association_) -
      reinterpret_cast<char*>(&_impl_.balance_)) + sizeof(_impl_.automatic_association_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TokenRelationship::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.TokenID tokenId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_tokenid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string symbol = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_symbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "proto.TokenRelationship.symbol"));
        } else
          goto handle_unusual;
        continue;
      // uint64 balance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.balance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.TokenKycStatus kycStatus = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_kycstatus(static_cast<::proto::TokenKycStatus>(val));
        } else
          goto handle_unusual;
        continue;
      // .proto.TokenFreezeStatus freezeStatus = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_freezestatus(static_cast<::proto::TokenFreezeStatus>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 decimals = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.decimals_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool automatic_association = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.automatic_association_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TokenRelationship::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.TokenRelationship)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.TokenID tokenId = 1;
  if (this->_internal_has_tokenid()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::tokenid(this),
        _Internal::tokenid(this).GetCachedSize(), target, stream);
  }

  // string symbol = 2;
  if (!this->_internal_symbol().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_symbol().data(), static_cast<int>(this->_internal_symbol().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "proto.TokenRelationship.symbol");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_symbol(), target);
  }

  // uint64 balance = 3;
  if (this->_internal_balance() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_balance(), target);
  }

  // .proto.TokenKycStatus kycStatus = 4;
  if (this->_internal_kycstatus() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_kycstatus(), target);
  }

  // .proto.TokenFreezeStatus freezeStatus = 5;
  if (this->_internal_freezestatus() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_freezestatus(), target);
  }

  // uint32 decimals = 6;
  if (this->_internal_decimals() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_decimals(), target);
  }

  // bool automatic_association = 7;
  if (this->_internal_automatic_association() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_automatic_association(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.TokenRelationship)
  return target;
}

size_t TokenRelationship::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.TokenRelationship)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string symbol = 2;
  if (!this->_internal_symbol().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_symbol());
  }

  // .proto.TokenID tokenId = 1;
  if (this->_internal_has_tokenid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tokenid_);
  }

  // uint64 balance = 3;
  if (this->_internal_balance() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_balance());
  }

  // .proto.TokenKycStatus kycStatus = 4;
  if (this->_internal_kycstatus() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_kycstatus());
  }

  // .proto.TokenFreezeStatus freezeStatus = 5;
  if (this->_internal_freezestatus() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_freezestatus());
  }

  // uint32 decimals = 6;
  if (this->_internal_decimals() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_decimals());
  }

  // bool automatic_association = 7;
  if (this->_internal_automatic_association() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TokenRelationship::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TokenRelationship::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TokenRelationship::GetClassData() const { return &_class_data_; }


void TokenRelationship::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TokenRelationship*>(&to_msg);
  auto& from = static_cast<const TokenRelationship&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.TokenRelationship)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_symbol().empty()) {
    _this->_internal_set_symbol(from._internal_symbol());
  }
  if (from._internal_has_tokenid()) {
    _this->_internal_mutable_tokenid()->::proto::TokenID::MergeFrom(
        from._internal_tokenid());
  }
  if (from._internal_balance() != 0) {
    _this->_internal_set_balance(from._internal_balance());
  }
  if (from._internal_kycstatus() != 0) {
    _this->_internal_set_kycstatus(from._internal_kycstatus());
  }
  if (from._internal_freezestatus() != 0) {
    _this->_internal_set_freezestatus(from._internal_freezestatus());
  }
  if (from._internal_decimals() != 0) {
    _this->_internal_set_decimals(from._internal_decimals());
  }
  if (from._internal_automatic_association() != 0) {
    _this->_internal_set_automatic_association(from._internal_automatic_association());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TokenRelationship::CopyFrom(const TokenRelationship& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.TokenRelationship)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TokenRelationship::IsInitialized() const {
  return true;
}

void TokenRelationship::InternalSwap(TokenRelationship* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.symbol_, lhs_arena,
      &other->_impl_.symbol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TokenRelationship, _impl_.automatic_association_)
      + sizeof(TokenRelationship::_impl_.automatic_association_)
      - PROTOBUF_FIELD_OFFSET(TokenRelationship, _impl_.tokenid_)>(
          reinterpret_cast<char*>(&_impl_.tokenid_),
          reinterpret_cast<char*>(&other->_impl_.tokenid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TokenRelationship::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[33]);
}

// ===================================================================

class TokenBalance::_Internal {
 public:
  static const ::proto::TokenID& tokenid(const TokenBalance* msg);
};

const ::proto::TokenID&
TokenBalance::_Internal::tokenid(const TokenBalance* msg) {
  return *msg->_impl_.tokenid_;
}
TokenBalance::TokenBalance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.TokenBalance)
}
TokenBalance::TokenBalance(const TokenBalance& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TokenBalance* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tokenid_){nullptr}
    , decltype(_impl_.balance_){}
    , decltype(_impl_.decimals_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_tokenid()) {
    _this->_impl_.tokenid_ = new ::proto::TokenID(*from._impl_.tokenid_);
  }
  ::memcpy(&_impl_.balance_, &from._impl_.balance_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.decimals_) -
    reinterpret_cast<char*>(&_impl_.balance_)) + sizeof(_impl_.decimals_));
  // @@protoc_insertion_point(copy_constructor:proto.TokenBalance)
}

inline void TokenBalance::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tokenid_){nullptr}
    , decltype(_impl_.balance_){uint64_t{0u}}
    , decltype(_impl_.decimals_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TokenBalance::~TokenBalance() {
  // @@protoc_insertion_point(destructor:proto.TokenBalance)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TokenBalance::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.tokenid_;
}

void TokenBalance::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TokenBalance::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.TokenBalance)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.tokenid_ != nullptr) {
    delete _impl_.tokenid_;
  }
  _impl_.tokenid_ = nullptr;
  ::memset(&_impl_.balance_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.decimals_) -
      reinterpret_cast<char*>(&_impl_.balance_)) + sizeof(_impl_.decimals_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TokenBalance::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.TokenID tokenId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_tokenid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 balance = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.balance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 decimals = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.decimals_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TokenBalance::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.TokenBalance)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.TokenID tokenId = 1;
  if (this->_internal_has_tokenid()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::tokenid(this),
        _Internal::tokenid(this).GetCachedSize(), target, stream);
  }

  // uint64 balance = 2;
  if (this->_internal_balance() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_balance(), target);
  }

  // uint32 decimals = 3;
  if (this->_internal_decimals() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_decimals(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.TokenBalance)
  return target;
}

size_t TokenBalance::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.TokenBalance)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.TokenID tokenId = 1;
  if (this->_internal_has_tokenid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tokenid_);
  }

  // uint64 balance = 2;
  if (this->_internal_balance() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_balance());
  }

  // uint32 decimals = 3;
  if (this->_internal_decimals() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_decimals());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TokenBalance::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TokenBalance::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TokenBalance::GetClassData() const { return &_class_data_; }


void TokenBalance::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TokenBalance*>(&to_msg);
  auto& from = static_cast<const TokenBalance&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.TokenBalance)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tokenid()) {
    _this->_internal_mutable_tokenid()->::proto::TokenID::MergeFrom(
        from._internal_tokenid());
  }
  if (from._internal_balance() != 0) {
    _this->_internal_set_balance(from._internal_balance());
  }
  if (from._internal_decimals() != 0) {
    _this->_internal_set_decimals(from._internal_decimals());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TokenBalance::CopyFrom(const TokenBalance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.TokenBalance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TokenBalance::IsInitialized() const {
  return true;
}

void TokenBalance::InternalSwap(TokenBalance* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TokenBalance, _impl_.decimals_)
      + sizeof(TokenBalance::_impl_.decimals_)
      - PROTOBUF_FIELD_OFFSET(TokenBalance, _impl_.tokenid_)>(
          reinterpret_cast<char*>(&_impl_.tokenid_),
          reinterpret_cast<char*>(&other->_impl_.tokenid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TokenBalance::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[34]);
}

// ===================================================================

class TokenBalances::_Internal {
 public:
};

TokenBalances::TokenBalances(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.TokenBalances)
}
TokenBalances::TokenBalances(const TokenBalances& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TokenBalances* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tokenbalances_){from._impl_.tokenbalances_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.TokenBalances)
}

inline void TokenBalances::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tokenbalances_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TokenBalances::~TokenBalances() {
  // @@protoc_insertion_point(destructor:proto.TokenBalances)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TokenBalances::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tokenbalances_.~RepeatedPtrField();
}

void TokenBalances::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TokenBalances::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.TokenBalances)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tokenbalances_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TokenBalances::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .proto.TokenBalance tokenBalances = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tokenbalances(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TokenBalances::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.TokenBalances)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.TokenBalance tokenBalances = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tokenbalances_size()); i < n; i++) {
    const auto& repfield = this->_internal_tokenbalances(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.TokenBalances)
  return target;
}

size_t TokenBalances::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.TokenBalances)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.TokenBalance tokenBalances = 1;
  total_size += 1UL * this->_internal_tokenbalances_size();
  for (const auto& msg : this->_impl_.tokenbalances_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TokenBalances::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TokenBalances::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TokenBalances::GetClassData() const { return &_class_data_; }


void TokenBalances::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TokenBalances*>(&to_msg);
  auto& from = static_cast<const TokenBalances&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.TokenBalances)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tokenbalances_.MergeFrom(from._impl_.tokenbalances_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TokenBalances::CopyFrom(const TokenBalances& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.TokenBalances)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TokenBalances::IsInitialized() const {
  return true;
}

void TokenBalances::InternalSwap(TokenBalances* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tokenbalances_.InternalSwap(&other->_impl_.tokenbalances_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TokenBalances::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[35]);
}

// ===================================================================

class TokenAssociation::_Internal {
 public:
  static const ::proto::TokenID& token_id(const TokenAssociation* msg);
  static const ::proto::AccountID& account_id(const TokenAssociation* msg);
};

const ::proto::TokenID&
TokenAssociation::_Internal::token_id(const TokenAssociation* msg) {
  return *msg->_impl_.token_id_;
}
const ::proto::AccountID&
TokenAssociation::_Internal::account_id(const TokenAssociation* msg) {
  return *msg->_impl_.account_id_;
}
TokenAssociation::TokenAssociation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.TokenAssociation)
}
TokenAssociation::TokenAssociation(const TokenAssociation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TokenAssociation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.token_id_){nullptr}
    , decltype(_impl_.account_id_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_token_id()) {
    _this->_impl_.token_id_ = new ::proto::TokenID(*from._impl_.token_id_);
  }
  if (from._internal_has_account_id()) {
    _this->_impl_.account_id_ = new ::proto::AccountID(*from._impl_.account_id_);
  }
  // @@protoc_insertion_point(copy_constructor:proto.TokenAssociation)
}

inline void TokenAssociation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.token_id_){nullptr}
    , decltype(_impl_.account_id_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TokenAssociation::~TokenAssociation() {
  // @@protoc_insertion_point(destructor:proto.TokenAssociation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TokenAssociation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.token_id_;
  if (this != internal_default_instance()) delete _impl_.account_id_;
}

void TokenAssociation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TokenAssociation::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.TokenAssociation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.token_id_ != nullptr) {
    delete _impl_.token_id_;
  }
  _impl_.token_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.account_id_ != nullptr) {
    delete _impl_.account_id_;
  }
  _impl_.account_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TokenAssociation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .proto.TokenID token_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_token_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.AccountID account_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_account_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TokenAssociation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.TokenAssociation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .proto.TokenID token_id = 1;
  if (this->_internal_has_token_id()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::token_id(this),
        _Internal::token_id(this).GetCachedSize(), target, stream);
  }

  // .proto.AccountID account_id = 2;
  if (this->_internal_has_account_id()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::account_id(this),
        _Internal::account_id(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.TokenAssociation)
  return target;
}

size_t TokenAssociation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.TokenAssociation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.TokenID token_id = 1;
  if (this->_internal_has_token_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.token_id_);
  }

  // .proto.AccountID account_id = 2;
  if (this->_internal_has_account_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.account_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TokenAssociation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TokenAssociation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TokenAssociation::GetClassData() const { return &_class_data_; }


void TokenAssociation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TokenAssociation*>(&to_msg);
  auto& from = static_cast<const TokenAssociation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.TokenAssociation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_token_id()) {
    _this->_internal_mutable_token_id()->::proto::TokenID::MergeFrom(
        from._internal_token_id());
  }
  if (from._internal_has_account_id()) {
    _this->_internal_mutable_account_id()->::proto::AccountID::MergeFrom(
        from._internal_account_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TokenAssociation::CopyFrom(const TokenAssociation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.TokenAssociation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TokenAssociation::IsInitialized() const {
  return true;
}

void TokenAssociation::InternalSwap(TokenAssociation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TokenAssociation, _impl_.account_id_)
      + sizeof(TokenAssociation::_impl_.account_id_)
      - PROTOBUF_FIELD_OFFSET(TokenAssociation, _impl_.token_id_)>(
          reinterpret_cast<char*>(&_impl_.token_id_),
          reinterpret_cast<char*>(&other->_impl_.token_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TokenAssociation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[36]);
}

// ===================================================================

class StakingInfo::_Internal {
 public:
  static const ::proto::Timestamp& stake_period_start(const StakingInfo* msg);
  static const ::proto::AccountID& staked_account_id(const StakingInfo* msg);
};

const ::proto::Timestamp&
StakingInfo::_Internal::stake_period_start(const StakingInfo* msg) {
  return *msg->_impl_.stake_period_start_;
}
const ::proto::AccountID&
StakingInfo::_Internal::staked_account_id(const StakingInfo* msg) {
  return *msg->_impl_.staked_id_.staked_account_id_;
}
void StakingInfo::clear_stake_period_start() {
  if (GetArenaForAllocation() == nullptr && _impl_.stake_period_start_ != nullptr) {
    delete _impl_.stake_period_start_;
  }
  _impl_.stake_period_start_ = nullptr;
}
void StakingInfo::set_allocated_staked_account_id(::proto::AccountID* staked_account_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_staked_id();
  if (staked_account_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(staked_account_id);
    if (message_arena != submessage_arena) {
      staked_account_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, staked_account_id, submessage_arena);
    }
    set_has_staked_account_id();
    _impl_.staked_id_.staked_account_id_ = staked_account_id;
  }
  // @@protoc_insertion_point(field_set_allocated:proto.StakingInfo.staked_account_id)
}
StakingInfo::StakingInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:proto.StakingInfo)
}
StakingInfo::StakingInfo(const StakingInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StakingInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stake_period_start_){nullptr}
    , decltype(_impl_.pending_reward_){}
    , decltype(_impl_.staked_to_me_){}
    , decltype(_impl_.decline_reward_){}
    , decltype(_impl_.staked_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stake_period_start()) {
    _this->_impl_.stake_period_start_ = new ::proto::Timestamp(*from._impl_.stake_period_start_);
  }
  ::memcpy(&_impl_.pending_reward_, &from._impl_.pending_reward_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.decline_reward_) -
    reinterpret_cast<char*>(&_impl_.pending_reward_)) + sizeof(_impl_.decline_reward_));
  clear_has_staked_id();
  switch (from.staked_id_case()) {
    case kStakedAccountId: {
      _this->_internal_mutable_staked_account_id()->::proto::AccountID::MergeFrom(
          from._internal_staked_account_id());
      break;
    }
    case kStakedNodeId: {
      _this->_internal_set_staked_node_id(from._internal_staked_node_id());
      break;
    }
    case STAKED_ID_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:proto.StakingInfo)
}

inline void StakingInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.stake_period_start_){nullptr}
    , decltype(_impl_.pending_reward_){int64_t{0}}
    , decltype(_impl_.staked_to_me_){int64_t{0}}
    , decltype(_impl_.decline_reward_){false}
    , decltype(_impl_.staked_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_staked_id();
}

StakingInfo::~StakingInfo() {
  // @@protoc_insertion_point(destructor:proto.StakingInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StakingInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.stake_period_start_;
  if (has_staked_id()) {
    clear_staked_id();
  }
}

void StakingInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StakingInfo::clear_staked_id() {
// @@protoc_insertion_point(one_of_clear_start:proto.StakingInfo)
  switch (staked_id_case()) {
    case kStakedAccountId: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.staked_id_.staked_account_id_;
      }
      break;
    }
    case kStakedNodeId: {
      // No need to clear
      break;
    }
    case STAKED_ID_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = STAKED_ID_NOT_SET;
}


void StakingInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.StakingInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.stake_period_start_ != nullptr) {
    delete _impl_.stake_period_start_;
  }
  _impl_.stake_period_start_ = nullptr;
  ::memset(&_impl_.pending_reward_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.decline_reward_) -
      reinterpret_cast<char*>(&_impl_.pending_reward_)) + sizeof(_impl_.decline_reward_));
  clear_staked_id();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StakingInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool decline_reward = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.decline_reward_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.Timestamp stake_period_start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_stake_period_start(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 pending_reward = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.pending_reward_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 staked_to_me = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.staked_to_me_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto.AccountID staked_account_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_staked_account_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 staked_node_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _internal_set_staked_node_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StakingInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.StakingInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool decline_reward = 1;
  if (this->_internal_decline_reward() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_decline_reward(), target);
  }

  // .proto.Timestamp stake_period_start = 2;
  if (this->_internal_has_stake_period_start()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::stake_period_start(this),
        _Internal::stake_period_start(this).GetCachedSize(), target, stream);
  }

  // int64 pending_reward = 3;
  if (this->_internal_pending_reward() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_pending_reward(), target);
  }

  // int64 staked_to_me = 4;
  if (this->_internal_staked_to_me() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_staked_to_me(), target);
  }

  // .proto.AccountID staked_account_id = 5;
  if (_internal_has_staked_account_id()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::staked_account_id(this),
        _Internal::staked_account_id(this).GetCachedSize(), target, stream);
  }

  // int64 staked_node_id = 6;
  if (_internal_has_staked_node_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_staked_node_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.StakingInfo)
  return target;
}

size_t StakingInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.StakingInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .proto.Timestamp stake_period_start = 2;
  if (this->_internal_has_stake_period_start()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.stake_period_start_);
  }

  // int64 pending_reward = 3;
  if (this->_internal_pending_reward() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_pending_reward());
  }

  // int64 staked_to_me = 4;
  if (this->_internal_staked_to_me() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_staked_to_me());
  }

  // bool decline_reward = 1;
  if (this->_internal_decline_reward() != 0) {
    total_size += 1 + 1;
  }

  switch (staked_id_case()) {
    // .proto.AccountID staked_account_id = 5;
    case kStakedAccountId: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.staked_id_.staked_account_id_);
      break;
    }
    // int64 staked_node_id = 6;
    case kStakedNodeId: {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_staked_node_id());
      break;
    }
    case STAKED_ID_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StakingInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StakingInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StakingInfo::GetClassData() const { return &_class_data_; }


void StakingInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StakingInfo*>(&to_msg);
  auto& from = static_cast<const StakingInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:proto.StakingInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stake_period_start()) {
    _this->_internal_mutable_stake_period_start()->::proto::Timestamp::MergeFrom(
        from._internal_stake_period_start());
  }
  if (from._internal_pending_reward() != 0) {
    _this->_internal_set_pending_reward(from._internal_pending_reward());
  }
  if (from._internal_staked_to_me() != 0) {
    _this->_internal_set_staked_to_me(from._internal_staked_to_me());
  }
  if (from._internal_decline_reward() != 0) {
    _this->_internal_set_decline_reward(from._internal_decline_reward());
  }
  switch (from.staked_id_case()) {
    case kStakedAccountId: {
      _this->_internal_mutable_staked_account_id()->::proto::AccountID::MergeFrom(
          from._internal_staked_account_id());
      break;
    }
    case kStakedNodeId: {
      _this->_internal_set_staked_node_id(from._internal_staked_node_id());
      break;
    }
    case STAKED_ID_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StakingInfo::CopyFrom(const StakingInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.StakingInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StakingInfo::IsInitialized() const {
  return true;
}

void StakingInfo::InternalSwap(StakingInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StakingInfo, _impl_.decline_reward_)
      + sizeof(StakingInfo::_impl_.decline_reward_)
      - PROTOBUF_FIELD_OFFSET(StakingInfo, _impl_.stake_period_start_)>(
          reinterpret_cast<char*>(&_impl_.stake_period_start_),
          reinterpret_cast<char*>(&other->_impl_.stake_period_start_));
  swap(_impl_.staked_id_, other->_impl_.staked_id_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata StakingInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_basic_5ftypes_2eproto_getter, &descriptor_table_basic_5ftypes_2eproto_once,
      file_level_metadata_basic_5ftypes_2eproto[37]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::proto::ShardID*
Arena::CreateMaybeMessage< ::proto::ShardID >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::ShardID >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::RealmID*
Arena::CreateMaybeMessage< ::proto::RealmID >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::RealmID >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::AccountID*
Arena::CreateMaybeMessage< ::proto::AccountID >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::AccountID >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::FileID*
Arena::CreateMaybeMessage< ::proto::FileID >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::FileID >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::ContractID*
Arena::CreateMaybeMessage< ::proto::ContractID >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::ContractID >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::TransactionID*
Arena::CreateMaybeMessage< ::proto::TransactionID >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::TransactionID >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::AccountAmount*
Arena::CreateMaybeMessage< ::proto::AccountAmount >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::AccountAmount >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::TransferList*
Arena::CreateMaybeMessage< ::proto::TransferList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::TransferList >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::NftTransfer*
Arena::CreateMaybeMessage< ::proto::NftTransfer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::NftTransfer >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::TokenTransferList*
Arena::CreateMaybeMessage< ::proto::TokenTransferList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::TokenTransferList >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::Fraction*
Arena::CreateMaybeMessage< ::proto::Fraction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::Fraction >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::TopicID*
Arena::CreateMaybeMessage< ::proto::TopicID >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::TopicID >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::TokenID*
Arena::CreateMaybeMessage< ::proto::TokenID >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::TokenID >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::ScheduleID*
Arena::CreateMaybeMessage< ::proto::ScheduleID >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::ScheduleID >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::Key*
Arena::CreateMaybeMessage< ::proto::Key >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::Key >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::ThresholdKey*
Arena::CreateMaybeMessage< ::proto::ThresholdKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::ThresholdKey >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::KeyList*
Arena::CreateMaybeMessage< ::proto::KeyList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::KeyList >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::Signature*
Arena::CreateMaybeMessage< ::proto::Signature >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::Signature >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::ThresholdSignature*
Arena::CreateMaybeMessage< ::proto::ThresholdSignature >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::ThresholdSignature >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::SignatureList*
Arena::CreateMaybeMessage< ::proto::SignatureList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::SignatureList >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::SignaturePair*
Arena::CreateMaybeMessage< ::proto::SignaturePair >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::SignaturePair >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::SignatureMap*
Arena::CreateMaybeMessage< ::proto::SignatureMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::SignatureMap >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::FeeComponents*
Arena::CreateMaybeMessage< ::proto::FeeComponents >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::FeeComponents >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::TransactionFeeSchedule*
Arena::CreateMaybeMessage< ::proto::TransactionFeeSchedule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::TransactionFeeSchedule >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::FeeData*
Arena::CreateMaybeMessage< ::proto::FeeData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::FeeData >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::FeeSchedule*
Arena::CreateMaybeMessage< ::proto::FeeSchedule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::FeeSchedule >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::CurrentAndNextFeeSchedule*
Arena::CreateMaybeMessage< ::proto::CurrentAndNextFeeSchedule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::CurrentAndNextFeeSchedule >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::ServiceEndpoint*
Arena::CreateMaybeMessage< ::proto::ServiceEndpoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::ServiceEndpoint >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::NodeAddress*
Arena::CreateMaybeMessage< ::proto::NodeAddress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::NodeAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::NodeAddressBook*
Arena::CreateMaybeMessage< ::proto::NodeAddressBook >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::NodeAddressBook >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::SemanticVersion*
Arena::CreateMaybeMessage< ::proto::SemanticVersion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::SemanticVersion >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::Setting*
Arena::CreateMaybeMessage< ::proto::Setting >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::Setting >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::ServicesConfigurationList*
Arena::CreateMaybeMessage< ::proto::ServicesConfigurationList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::ServicesConfigurationList >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::TokenRelationship*
Arena::CreateMaybeMessage< ::proto::TokenRelationship >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::TokenRelationship >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::TokenBalance*
Arena::CreateMaybeMessage< ::proto::TokenBalance >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::TokenBalance >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::TokenBalances*
Arena::CreateMaybeMessage< ::proto::TokenBalances >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::TokenBalances >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::TokenAssociation*
Arena::CreateMaybeMessage< ::proto::TokenAssociation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::TokenAssociation >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::StakingInfo*
Arena::CreateMaybeMessage< ::proto::StakingInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto::StakingInfo >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
